
RTOS demo.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003280  00000000  00000000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     0000000c  20000000  00003280  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bkupram      00000000  47000000  47000000  0002000c  2**0
                  CONTENTS
  3 .qspi         00000000  04000000  04000000  0002000c  2**0
                  CONTENTS
  4 .bss          00000f94  2000000c  0000328c  0002000c  2**2
                  ALLOC
  5 .stack        00010000  20000fa0  00004220  0002000c  2**0
                  ALLOC
  6 .ARM.attributes 0000002e  00000000  00000000  0002000c  2**0
                  CONTENTS, READONLY
  7 .comment      00000059  00000000  00000000  0002003a  2**0
                  CONTENTS, READONLY
  8 .debug_info   00023e06  00000000  00000000  00020093  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 0000360a  00000000  00000000  00043e99  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00010389  00000000  00000000  000474a3  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00000e40  00000000  00000000  0005782c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00001258  00000000  00000000  0005866c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00033475  00000000  00000000  000598c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   000133c9  00000000  00000000  0008cd39  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    0012874e  00000000  00000000  000a0102  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  000027dc  00000000  00000000  001c8850  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	a0 0f 01 20 e1 02 00 00 dd 02 00 00 dd 02 00 00     ... ............
      10:	dd 02 00 00 dd 02 00 00 dd 02 00 00 00 00 00 00     ................
	...
      2c:	b1 0e 00 00 dd 02 00 00 00 00 00 00 01 0f 00 00     ................
      3c:	15 10 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
      4c:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
      5c:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
      6c:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
      7c:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
      8c:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
      9c:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
      ac:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
      bc:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
      cc:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
      dc:	dd 02 00 00 dd 02 00 00 dd 02 00 00 00 00 00 00     ................
	...
      f4:	e1 08 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
     104:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
     114:	dd 02 00 00 69 0c 00 00 7d 0c 00 00 91 0c 00 00     ....i...}.......
     124:	a5 0c 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
     134:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
     144:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
     154:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
     164:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
     174:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
     184:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
     194:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
     1a4:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
     1b4:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
     1c4:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
     1d4:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
     1e4:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
     1f4:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
     204:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
     214:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
     224:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
     234:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
     244:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
     254:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................

00000264 <__do_global_dtors_aux>:
     264:	b510      	push	{r4, lr}
     266:	4c05      	ldr	r4, [pc, #20]	; (27c <__do_global_dtors_aux+0x18>)
     268:	7823      	ldrb	r3, [r4, #0]
     26a:	b933      	cbnz	r3, 27a <__do_global_dtors_aux+0x16>
     26c:	4b04      	ldr	r3, [pc, #16]	; (280 <__do_global_dtors_aux+0x1c>)
     26e:	b113      	cbz	r3, 276 <__do_global_dtors_aux+0x12>
     270:	4804      	ldr	r0, [pc, #16]	; (284 <__do_global_dtors_aux+0x20>)
     272:	f3af 8000 	nop.w
     276:	2301      	movs	r3, #1
     278:	7023      	strb	r3, [r4, #0]
     27a:	bd10      	pop	{r4, pc}
     27c:	2000000c 	.word	0x2000000c
     280:	00000000 	.word	0x00000000
     284:	00003280 	.word	0x00003280

00000288 <frame_dummy>:
     288:	4b0c      	ldr	r3, [pc, #48]	; (2bc <frame_dummy+0x34>)
     28a:	b143      	cbz	r3, 29e <frame_dummy+0x16>
     28c:	480c      	ldr	r0, [pc, #48]	; (2c0 <frame_dummy+0x38>)
     28e:	490d      	ldr	r1, [pc, #52]	; (2c4 <frame_dummy+0x3c>)
     290:	b510      	push	{r4, lr}
     292:	f3af 8000 	nop.w
     296:	480c      	ldr	r0, [pc, #48]	; (2c8 <frame_dummy+0x40>)
     298:	6803      	ldr	r3, [r0, #0]
     29a:	b923      	cbnz	r3, 2a6 <frame_dummy+0x1e>
     29c:	bd10      	pop	{r4, pc}
     29e:	480a      	ldr	r0, [pc, #40]	; (2c8 <frame_dummy+0x40>)
     2a0:	6803      	ldr	r3, [r0, #0]
     2a2:	b933      	cbnz	r3, 2b2 <frame_dummy+0x2a>
     2a4:	4770      	bx	lr
     2a6:	4b09      	ldr	r3, [pc, #36]	; (2cc <frame_dummy+0x44>)
     2a8:	2b00      	cmp	r3, #0
     2aa:	d0f7      	beq.n	29c <frame_dummy+0x14>
     2ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     2b0:	4718      	bx	r3
     2b2:	4b06      	ldr	r3, [pc, #24]	; (2cc <frame_dummy+0x44>)
     2b4:	2b00      	cmp	r3, #0
     2b6:	d0f5      	beq.n	2a4 <frame_dummy+0x1c>
     2b8:	4718      	bx	r3
     2ba:	bf00      	nop
     2bc:	00000000 	.word	0x00000000
     2c0:	00003280 	.word	0x00003280
     2c4:	20000010 	.word	0x20000010
     2c8:	00003280 	.word	0x00003280
     2cc:	00000000 	.word	0x00000000

000002d0 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
     2d0:	b508      	push	{r3, lr}
	system_init();
     2d2:	4b01      	ldr	r3, [pc, #4]	; (2d8 <atmel_start_init+0x8>)
     2d4:	4798      	blx	r3
     2d6:	bd08      	pop	{r3, pc}
     2d8:	00000441 	.word	0x00000441

000002dc <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     2dc:	e7fe      	b.n	2dc <Dummy_Handler>
	...

000002e0 <Reset_Handler>:
{
     2e0:	b508      	push	{r3, lr}
        if (pSrc != pDest) {
     2e2:	4b15      	ldr	r3, [pc, #84]	; (338 <Reset_Handler+0x58>)
     2e4:	4a15      	ldr	r2, [pc, #84]	; (33c <Reset_Handler+0x5c>)
     2e6:	429a      	cmp	r2, r3
     2e8:	d009      	beq.n	2fe <Reset_Handler+0x1e>
     2ea:	4b13      	ldr	r3, [pc, #76]	; (338 <Reset_Handler+0x58>)
     2ec:	4a13      	ldr	r2, [pc, #76]	; (33c <Reset_Handler+0x5c>)
     2ee:	e003      	b.n	2f8 <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
     2f0:	6811      	ldr	r1, [r2, #0]
     2f2:	6019      	str	r1, [r3, #0]
     2f4:	3304      	adds	r3, #4
     2f6:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
     2f8:	4911      	ldr	r1, [pc, #68]	; (340 <Reset_Handler+0x60>)
     2fa:	428b      	cmp	r3, r1
     2fc:	d3f8      	bcc.n	2f0 <Reset_Handler+0x10>
                        *pDest++ = *pSrc++;
     2fe:	4b11      	ldr	r3, [pc, #68]	; (344 <Reset_Handler+0x64>)
     300:	e002      	b.n	308 <Reset_Handler+0x28>
                *pDest++ = 0;
     302:	2200      	movs	r2, #0
     304:	601a      	str	r2, [r3, #0]
     306:	3304      	adds	r3, #4
        for (pDest = &_szero; pDest < &_ezero;) {
     308:	4a0f      	ldr	r2, [pc, #60]	; (348 <Reset_Handler+0x68>)
     30a:	4293      	cmp	r3, r2
     30c:	d3f9      	bcc.n	302 <Reset_Handler+0x22>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     30e:	4b0f      	ldr	r3, [pc, #60]	; (34c <Reset_Handler+0x6c>)
     310:	4a0f      	ldr	r2, [pc, #60]	; (350 <Reset_Handler+0x70>)
     312:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
     316:	609a      	str	r2, [r3, #8]
        SCB->CPACR |=  (0xFu << 20);
     318:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
     31c:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
     320:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
     324:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
     328:	f3bf 8f6f 	isb	sy
        __libc_init_array();
     32c:	4b09      	ldr	r3, [pc, #36]	; (354 <Reset_Handler+0x74>)
     32e:	4798      	blx	r3
        main();
     330:	4b09      	ldr	r3, [pc, #36]	; (358 <Reset_Handler+0x78>)
     332:	4798      	blx	r3
     334:	e7fe      	b.n	334 <Reset_Handler+0x54>
     336:	bf00      	nop
     338:	20000000 	.word	0x20000000
     33c:	00003280 	.word	0x00003280
     340:	2000000c 	.word	0x2000000c
     344:	2000000c 	.word	0x2000000c
     348:	20000fa0 	.word	0x20000fa0
     34c:	e000ed00 	.word	0xe000ed00
     350:	00000000 	.word	0x00000000
     354:	0000306d 	.word	0x0000306d
     358:	00000cf5 	.word	0x00000cf5

0000035c <EDBG_COM_PORT_init>:
static inline void hri_port_write_PINCFG_PMUXEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                    bool value)
{
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     35c:	4b10      	ldr	r3, [pc, #64]	; (3a0 <EDBG_COM_PORT_init+0x44>)
     35e:	f893 20d9 	ldrb.w	r2, [r3, #217]	; 0xd9
	tmp &= ~PORT_PINCFG_PMUXEN;
     362:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     366:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     36a:	f883 20d9 	strb.w	r2, [r3, #217]	; 0xd9
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     36e:	f893 20bc 	ldrb.w	r2, [r3, #188]	; 0xbc
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     372:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     376:	f042 0230 	orr.w	r2, r2, #48	; 0x30
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     37a:	f883 20bc 	strb.w	r2, [r3, #188]	; 0xbc
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     37e:	f893 20d8 	ldrb.w	r2, [r3, #216]	; 0xd8
	tmp &= ~PORT_PINCFG_PMUXEN;
     382:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     386:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     38a:	f883 20d8 	strb.w	r2, [r3, #216]	; 0xd8
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     38e:	f893 20bc 	ldrb.w	r2, [r3, #188]	; 0xbc
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     392:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     396:	f042 0203 	orr.w	r2, r2, #3
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     39a:	f883 20bc 	strb.w	r2, [r3, #188]	; 0xbc
     39e:	4770      	bx	lr
     3a0:	41008000 	.word	0x41008000

000003a4 <EDBG_COM_CLOCK_init>:
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
     3a4:	4b06      	ldr	r3, [pc, #24]	; (3c0 <EDBG_COM_CLOCK_init+0x1c>)
     3a6:	2240      	movs	r2, #64	; 0x40
     3a8:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
     3ac:	2243      	movs	r2, #67	; 0x43
     3ae:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
}

static inline void hri_mclk_set_APBBMASK_SERCOM2_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_SERCOM2;
     3b2:	4a04      	ldr	r2, [pc, #16]	; (3c4 <EDBG_COM_CLOCK_init+0x20>)
     3b4:	6993      	ldr	r3, [r2, #24]
     3b6:	f443 7300 	orr.w	r3, r3, #512	; 0x200
     3ba:	6193      	str	r3, [r2, #24]
     3bc:	4770      	bx	lr
     3be:	bf00      	nop
     3c0:	40001c00 	.word	0x40001c00
     3c4:	40000800 	.word	0x40000800

000003c8 <EDBG_COM_init>:

	hri_mclk_set_APBBMASK_SERCOM2_bit(MCLK);
}

void EDBG_COM_init(void)
{
     3c8:	b530      	push	{r4, r5, lr}
     3ca:	b083      	sub	sp, #12

	EDBG_COM_CLOCK_init();
     3cc:	4b14      	ldr	r3, [pc, #80]	; (420 <EDBG_COM_init+0x58>)
     3ce:	4798      	blx	r3
	uint32_t irq = SERCOM2_0_IRQn;
	for (uint32_t i = 0; i < 4; i++) {
     3d0:	2000      	movs	r0, #0
	uint32_t irq = SERCOM2_0_IRQn;
     3d2:	2336      	movs	r3, #54	; 0x36
	for (uint32_t i = 0; i < 4; i++) {
     3d4:	e00a      	b.n	3ec <EDBG_COM_init+0x24>
		NVIC_SetPriority((IRQn_Type)irq, PERIPHERAL_INTERRUPT_PRIORITY);
     3d6:	b21a      	sxth	r2, r3
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
     3d8:	2a00      	cmp	r2, #0
     3da:	da19      	bge.n	410 <EDBG_COM_init+0x48>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
     3dc:	f003 010f 	and.w	r1, r3, #15
     3e0:	4a10      	ldr	r2, [pc, #64]	; (424 <EDBG_COM_init+0x5c>)
     3e2:	440a      	add	r2, r1
     3e4:	21c0      	movs	r1, #192	; 0xc0
     3e6:	7611      	strb	r1, [r2, #24]
		irq++;
     3e8:	3301      	adds	r3, #1
	for (uint32_t i = 0; i < 4; i++) {
     3ea:	3001      	adds	r0, #1
     3ec:	2803      	cmp	r0, #3
     3ee:	d9f2      	bls.n	3d6 <EDBG_COM_init+0xe>
	}
	usart_os_init(&EDBG_COM, SERCOM2, EDBG_COM_buffer, EDBG_COM_BUFFER_SIZE, (void *)NULL);
     3f0:	4c0d      	ldr	r4, [pc, #52]	; (428 <EDBG_COM_init+0x60>)
     3f2:	2300      	movs	r3, #0
     3f4:	9300      	str	r3, [sp, #0]
     3f6:	2310      	movs	r3, #16
     3f8:	4a0c      	ldr	r2, [pc, #48]	; (42c <EDBG_COM_init+0x64>)
     3fa:	490d      	ldr	r1, [pc, #52]	; (430 <EDBG_COM_init+0x68>)
     3fc:	4620      	mov	r0, r4
     3fe:	4d0d      	ldr	r5, [pc, #52]	; (434 <EDBG_COM_init+0x6c>)
     400:	47a8      	blx	r5
	usart_os_enable(&EDBG_COM);
     402:	4620      	mov	r0, r4
     404:	4b0c      	ldr	r3, [pc, #48]	; (438 <EDBG_COM_init+0x70>)
     406:	4798      	blx	r3
	EDBG_COM_PORT_init();
     408:	4b0c      	ldr	r3, [pc, #48]	; (43c <EDBG_COM_init+0x74>)
     40a:	4798      	blx	r3
}
     40c:	b003      	add	sp, #12
     40e:	bd30      	pop	{r4, r5, pc}
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
     410:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
     414:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
     418:	21c0      	movs	r1, #192	; 0xc0
     41a:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
     41e:	e7e3      	b.n	3e8 <EDBG_COM_init+0x20>
     420:	000003a5 	.word	0x000003a5
     424:	e000ecfc 	.word	0xe000ecfc
     428:	20000f44 	.word	0x20000f44
     42c:	20000f34 	.word	0x20000f34
     430:	41012000 	.word	0x41012000
     434:	00000621 	.word	0x00000621
     438:	0000071d 	.word	0x0000071d
     43c:	0000035d 	.word	0x0000035d

00000440 <system_init>:

void system_init(void)
{
     440:	b508      	push	{r3, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
     442:	4b0c      	ldr	r3, [pc, #48]	; (474 <system_init+0x34>)
     444:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     446:	4b0c      	ldr	r3, [pc, #48]	; (478 <system_init+0x38>)
     448:	f44f 2280 	mov.w	r2, #262144	; 0x40000
     44c:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     450:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     454:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
     458:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
     45c:	4a07      	ldr	r2, [pc, #28]	; (47c <system_init+0x3c>)
     45e:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     462:	f893 2152 	ldrb.w	r2, [r3, #338]	; 0x152
	tmp &= ~PORT_PINCFG_PMUXEN;
     466:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     46a:	f883 2152 	strb.w	r2, [r3, #338]	; 0x152
	// Set pin direction to output
	gpio_set_pin_direction(LED0, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(LED0, GPIO_PIN_FUNCTION_OFF);

	EDBG_COM_init();
     46e:	4b04      	ldr	r3, [pc, #16]	; (480 <system_init+0x40>)
     470:	4798      	blx	r3
     472:	bd08      	pop	{r3, pc}
     474:	00000841 	.word	0x00000841
     478:	41008000 	.word	0x41008000
     47c:	c0000004 	.word	0xc0000004
     480:	000003c9 	.word	0x000003c9

00000484 <atomic_enter_critical>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
     484:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
     488:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
     48a:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
     48c:	f3bf 8f5f 	dmb	sy
     490:	4770      	bx	lr

00000492 <atomic_leave_critical>:
     492:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
     496:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
     498:	f383 8810 	msr	PRIMASK, r3
     49c:	4770      	bx	lr
	...

000004a0 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
     4a0:	b570      	push	{r4, r5, r6, lr}
     4a2:	460d      	mov	r5, r1
     4a4:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
     4a6:	4604      	mov	r4, r0
     4a8:	b168      	cbz	r0, 4c6 <io_write+0x26>
     4aa:	b151      	cbz	r1, 4c2 <io_write+0x22>
     4ac:	2001      	movs	r0, #1
     4ae:	2234      	movs	r2, #52	; 0x34
     4b0:	4906      	ldr	r1, [pc, #24]	; (4cc <io_write+0x2c>)
     4b2:	4b07      	ldr	r3, [pc, #28]	; (4d0 <io_write+0x30>)
     4b4:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
     4b6:	6823      	ldr	r3, [r4, #0]
     4b8:	4632      	mov	r2, r6
     4ba:	4629      	mov	r1, r5
     4bc:	4620      	mov	r0, r4
     4be:	4798      	blx	r3
}
     4c0:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(io_descr && buf);
     4c2:	2000      	movs	r0, #0
     4c4:	e7f3      	b.n	4ae <io_write+0xe>
     4c6:	2000      	movs	r0, #0
     4c8:	e7f1      	b.n	4ae <io_write+0xe>
     4ca:	bf00      	nop
     4cc:	000030ec 	.word	0x000030ec
     4d0:	00000749 	.word	0x00000749

000004d4 <usart_os_error>:
 * \brief Process error interrupt
 *
 * \param[in] device The pointer to device structure
 */
static void usart_os_error(struct _usart_async_device *device)
{
     4d4:	b508      	push	{r3, lr}
	struct usart_os_descriptor *descr = CONTAINER_OF(device, struct usart_os_descriptor, device);

	sem_up(&descr->rx_sem);
     4d6:	303c      	adds	r0, #60	; 0x3c
     4d8:	4b01      	ldr	r3, [pc, #4]	; (4e0 <usart_os_error+0xc>)
     4da:	4798      	blx	r3
     4dc:	bd08      	pop	{r3, pc}
     4de:	bf00      	nop
     4e0:	00000d79 	.word	0x00000d79

000004e4 <usart_os_transmission_complete>:
{
     4e4:	b508      	push	{r3, lr}
	sem_up(&descr->tx_sem);
     4e6:	3040      	adds	r0, #64	; 0x40
     4e8:	4b01      	ldr	r3, [pc, #4]	; (4f0 <usart_os_transmission_complete+0xc>)
     4ea:	4798      	blx	r3
     4ec:	bd08      	pop	{r3, pc}
     4ee:	bf00      	nop
     4f0:	00000d79 	.word	0x00000d79

000004f4 <usart_os_fill_rx_buffer>:
{
     4f4:	b510      	push	{r4, lr}
	if (descr->rx_buffer == NULL) {
     4f6:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
     4f8:	b143      	cbz	r3, 50c <usart_os_fill_rx_buffer+0x18>
		descr->rx_buffer[descr->rx_size++] = data;
     4fa:	8e02      	ldrh	r2, [r0, #48]	; 0x30
     4fc:	1c54      	adds	r4, r2, #1
     4fe:	8604      	strh	r4, [r0, #48]	; 0x30
     500:	5499      	strb	r1, [r3, r2]
		if (descr->rx_size >= descr->rx_length) {
     502:	8e02      	ldrh	r2, [r0, #48]	; 0x30
     504:	8e43      	ldrh	r3, [r0, #50]	; 0x32
     506:	429a      	cmp	r2, r3
     508:	d204      	bcs.n	514 <usart_os_fill_rx_buffer+0x20>
     50a:	bd10      	pop	{r4, pc}
		ringbuffer_put(&descr->rx, data);
     50c:	301c      	adds	r0, #28
     50e:	4b04      	ldr	r3, [pc, #16]	; (520 <usart_os_fill_rx_buffer+0x2c>)
     510:	4798      	blx	r3
     512:	bd10      	pop	{r4, pc}
			descr->rx_buffer = NULL;
     514:	2300      	movs	r3, #0
     516:	62c3      	str	r3, [r0, #44]	; 0x2c
			sem_up(&descr->rx_sem);
     518:	303c      	adds	r0, #60	; 0x3c
     51a:	4b02      	ldr	r3, [pc, #8]	; (524 <usart_os_fill_rx_buffer+0x30>)
     51c:	4798      	blx	r3
}
     51e:	e7f4      	b.n	50a <usart_os_fill_rx_buffer+0x16>
     520:	000007dd 	.word	0x000007dd
     524:	00000d79 	.word	0x00000d79

00000528 <usart_os_write>:
{
     528:	b510      	push	{r4, lr}
     52a:	4614      	mov	r4, r2
	descr->tx_buffer        = (uint8_t *)buf;
     52c:	63c1      	str	r1, [r0, #60]	; 0x3c
	descr->tx_buffer_length = length;
     52e:	f8a0 2042 	strh.w	r2, [r0, #66]	; 0x42
	descr->tx_por           = 0;
     532:	2300      	movs	r3, #0
     534:	f8a0 3040 	strh.w	r3, [r0, #64]	; 0x40
	_usart_async_enable_byte_sent_irq(&descr->device);
     538:	3008      	adds	r0, #8
     53a:	4b02      	ldr	r3, [pc, #8]	; (544 <usart_os_write+0x1c>)
     53c:	4798      	blx	r3
}
     53e:	4620      	mov	r0, r4
     540:	bd10      	pop	{r4, pc}
     542:	bf00      	nop
     544:	00000be7 	.word	0x00000be7

00000548 <usart_os_process_byte_sent>:
{
     548:	b510      	push	{r4, lr}
     54a:	4604      	mov	r4, r0
	if (descr->tx_por != descr->tx_buffer_length) {
     54c:	8f03      	ldrh	r3, [r0, #56]	; 0x38
     54e:	8f42      	ldrh	r2, [r0, #58]	; 0x3a
     550:	4293      	cmp	r3, r2
     552:	d009      	beq.n	568 <usart_os_process_byte_sent+0x20>
		_usart_async_write_byte(&descr->device, descr->tx_buffer[descr->tx_por++]);
     554:	6b42      	ldr	r2, [r0, #52]	; 0x34
     556:	1c59      	adds	r1, r3, #1
     558:	8701      	strh	r1, [r0, #56]	; 0x38
     55a:	5cd1      	ldrb	r1, [r2, r3]
     55c:	4b04      	ldr	r3, [pc, #16]	; (570 <usart_os_process_byte_sent+0x28>)
     55e:	4798      	blx	r3
		_usart_async_enable_byte_sent_irq(&descr->device);
     560:	4620      	mov	r0, r4
     562:	4b04      	ldr	r3, [pc, #16]	; (574 <usart_os_process_byte_sent+0x2c>)
     564:	4798      	blx	r3
     566:	bd10      	pop	{r4, pc}
		_usart_async_enable_tx_done_irq(&descr->device);
     568:	4b03      	ldr	r3, [pc, #12]	; (578 <usart_os_process_byte_sent+0x30>)
     56a:	4798      	blx	r3
     56c:	bd10      	pop	{r4, pc}
     56e:	bf00      	nop
     570:	00000be1 	.word	0x00000be1
     574:	00000be7 	.word	0x00000be7
     578:	00000bef 	.word	0x00000bef

0000057c <usart_os_read>:
{
     57c:	b5f0      	push	{r4, r5, r6, r7, lr}
     57e:	b083      	sub	sp, #12
     580:	4604      	mov	r4, r0
     582:	4616      	mov	r6, r2
	ASSERT(buf);
     584:	460f      	mov	r7, r1
     586:	1c08      	adds	r0, r1, #0
     588:	bf18      	it	ne
     58a:	2001      	movne	r0, #1
     58c:	f240 1225 	movw	r2, #293	; 0x125
     590:	491c      	ldr	r1, [pc, #112]	; (604 <usart_os_read+0x88>)
     592:	4b1d      	ldr	r3, [pc, #116]	; (608 <usart_os_read+0x8c>)
     594:	4798      	blx	r3
	if (ringbuffer_num(&descr->rx) < length) {
     596:	f104 0524 	add.w	r5, r4, #36	; 0x24
     59a:	4628      	mov	r0, r5
     59c:	4b1b      	ldr	r3, [pc, #108]	; (60c <usart_os_read+0x90>)
     59e:	4798      	blx	r3
     5a0:	42b0      	cmp	r0, r6
     5a2:	d301      	bcc.n	5a8 <usart_os_read+0x2c>
     5a4:	2100      	movs	r1, #0
     5a6:	e028      	b.n	5fa <usart_os_read+0x7e>
		CRITICAL_SECTION_ENTER()
     5a8:	a801      	add	r0, sp, #4
     5aa:	4b19      	ldr	r3, [pc, #100]	; (610 <usart_os_read+0x94>)
     5ac:	4798      	blx	r3
		descr->rx_size   = 0;
     5ae:	2300      	movs	r3, #0
     5b0:	8723      	strh	r3, [r4, #56]	; 0x38
		descr->rx_length = length;
     5b2:	8766      	strh	r6, [r4, #58]	; 0x3a
		descr->rx_buffer = buf;
     5b4:	6367      	str	r7, [r4, #52]	; 0x34
		while (ringbuffer_num(&descr->rx) > 0) {
     5b6:	e007      	b.n	5c8 <usart_os_read+0x4c>
			ringbuffer_get(&descr->rx, &descr->rx_buffer[descr->rx_size++]);
     5b8:	6b61      	ldr	r1, [r4, #52]	; 0x34
     5ba:	8f23      	ldrh	r3, [r4, #56]	; 0x38
     5bc:	1c5a      	adds	r2, r3, #1
     5be:	8722      	strh	r2, [r4, #56]	; 0x38
     5c0:	4419      	add	r1, r3
     5c2:	4628      	mov	r0, r5
     5c4:	4b13      	ldr	r3, [pc, #76]	; (614 <usart_os_read+0x98>)
     5c6:	4798      	blx	r3
		while (ringbuffer_num(&descr->rx) > 0) {
     5c8:	4628      	mov	r0, r5
     5ca:	4b10      	ldr	r3, [pc, #64]	; (60c <usart_os_read+0x90>)
     5cc:	4798      	blx	r3
     5ce:	2800      	cmp	r0, #0
     5d0:	d1f2      	bne.n	5b8 <usart_os_read+0x3c>
		CRITICAL_SECTION_LEAVE()
     5d2:	a801      	add	r0, sp, #4
     5d4:	4b10      	ldr	r3, [pc, #64]	; (618 <usart_os_read+0x9c>)
     5d6:	4798      	blx	r3
		if (sem_down(&descr->rx_sem, timeout) != 0) {
     5d8:	f04f 31ff 	mov.w	r1, #4294967295
     5dc:	f104 0044 	add.w	r0, r4, #68	; 0x44
     5e0:	4b0e      	ldr	r3, [pc, #56]	; (61c <usart_os_read+0xa0>)
     5e2:	4798      	blx	r3
     5e4:	b158      	cbz	r0, 5fe <usart_os_read+0x82>
			return ERR_TIMEOUT;
     5e6:	f06f 0007 	mvn.w	r0, #7
     5ea:	e009      	b.n	600 <usart_os_read+0x84>
			ringbuffer_get(&descr->rx, &buf[was_read++]);
     5ec:	1c4c      	adds	r4, r1, #1
     5ee:	b2a4      	uxth	r4, r4
     5f0:	4439      	add	r1, r7
     5f2:	4628      	mov	r0, r5
     5f4:	4b07      	ldr	r3, [pc, #28]	; (614 <usart_os_read+0x98>)
     5f6:	4798      	blx	r3
     5f8:	4621      	mov	r1, r4
		while (was_read < length) {
     5fa:	42b1      	cmp	r1, r6
     5fc:	d3f6      	bcc.n	5ec <usart_os_read+0x70>
	return (int32_t)length;
     5fe:	4630      	mov	r0, r6
}
     600:	b003      	add	sp, #12
     602:	bdf0      	pop	{r4, r5, r6, r7, pc}
     604:	00003100 	.word	0x00003100
     608:	00000749 	.word	0x00000749
     60c:	0000081d 	.word	0x0000081d
     610:	00000485 	.word	0x00000485
     614:	00000795 	.word	0x00000795
     618:	00000493 	.word	0x00000493
     61c:	00000dbd 	.word	0x00000dbd

00000620 <usart_os_init>:
{
     620:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
     624:	460f      	mov	r7, r1
     626:	4615      	mov	r5, r2
     628:	461e      	mov	r6, r3
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
     62a:	4604      	mov	r4, r0
     62c:	2800      	cmp	r0, #0
     62e:	d046      	beq.n	6be <usart_os_init+0x9e>
     630:	2900      	cmp	r1, #0
     632:	d046      	beq.n	6c2 <usart_os_init+0xa2>
     634:	2a00      	cmp	r2, #0
     636:	d046      	beq.n	6c6 <usart_os_init+0xa6>
     638:	2b00      	cmp	r3, #0
     63a:	d146      	bne.n	6ca <usart_os_init+0xaa>
     63c:	2000      	movs	r0, #0
     63e:	2240      	movs	r2, #64	; 0x40
     640:	4929      	ldr	r1, [pc, #164]	; (6e8 <usart_os_init+0xc8>)
     642:	4b2a      	ldr	r3, [pc, #168]	; (6ec <usart_os_init+0xcc>)
     644:	4798      	blx	r3
	if (ERR_NONE != ringbuffer_init(&descr->rx, rx_buffer, rx_buffer_length)) {
     646:	4632      	mov	r2, r6
     648:	4629      	mov	r1, r5
     64a:	f104 0024 	add.w	r0, r4, #36	; 0x24
     64e:	4b28      	ldr	r3, [pc, #160]	; (6f0 <usart_os_init+0xd0>)
     650:	4798      	blx	r3
     652:	2800      	cmp	r0, #0
     654:	d145      	bne.n	6e2 <usart_os_init+0xc2>
	rc = sem_init(&descr->rx_sem, 0);
     656:	f104 0644 	add.w	r6, r4, #68	; 0x44
     65a:	2100      	movs	r1, #0
     65c:	4630      	mov	r0, r6
     65e:	4b25      	ldr	r3, [pc, #148]	; (6f4 <usart_os_init+0xd4>)
     660:	4798      	blx	r3
	if (rc < 0) {
     662:	1e05      	subs	r5, r0, #0
     664:	db28      	blt.n	6b8 <usart_os_init+0x98>
	rc = sem_init(&descr->tx_sem, 0);
     666:	f104 0948 	add.w	r9, r4, #72	; 0x48
     66a:	2100      	movs	r1, #0
     66c:	4648      	mov	r0, r9
     66e:	4b21      	ldr	r3, [pc, #132]	; (6f4 <usart_os_init+0xd4>)
     670:	4798      	blx	r3
	if (rc < 0) {
     672:	1e05      	subs	r5, r0, #0
     674:	db2b      	blt.n	6ce <usart_os_init+0xae>
	rc = _usart_async_init(&descr->device, hw);
     676:	f104 0808 	add.w	r8, r4, #8
     67a:	4639      	mov	r1, r7
     67c:	4640      	mov	r0, r8
     67e:	4b1e      	ldr	r3, [pc, #120]	; (6f8 <usart_os_init+0xd8>)
     680:	4798      	blx	r3
	if (rc) {
     682:	4605      	mov	r5, r0
     684:	bb38      	cbnz	r0, 6d6 <usart_os_init+0xb6>
	descr->rx_buffer = NULL;
     686:	2300      	movs	r3, #0
     688:	6363      	str	r3, [r4, #52]	; 0x34
	descr->rx_size   = 0;
     68a:	8723      	strh	r3, [r4, #56]	; 0x38
	descr->rx_length = 0;
     68c:	8763      	strh	r3, [r4, #58]	; 0x3a
	descr->io.read  = usart_os_read;
     68e:	4b1b      	ldr	r3, [pc, #108]	; (6fc <usart_os_init+0xdc>)
     690:	6063      	str	r3, [r4, #4]
	descr->io.write = usart_os_write;
     692:	4b1b      	ldr	r3, [pc, #108]	; (700 <usart_os_init+0xe0>)
     694:	6023      	str	r3, [r4, #0]
	descr->device.usart_cb.tx_byte_sent = usart_os_process_byte_sent;
     696:	4b1b      	ldr	r3, [pc, #108]	; (704 <usart_os_init+0xe4>)
     698:	60a3      	str	r3, [r4, #8]
	descr->device.usart_cb.rx_done_cb   = usart_os_fill_rx_buffer;
     69a:	4b1b      	ldr	r3, [pc, #108]	; (708 <usart_os_init+0xe8>)
     69c:	60e3      	str	r3, [r4, #12]
	descr->device.usart_cb.tx_done_cb   = usart_os_transmission_complete;
     69e:	4b1b      	ldr	r3, [pc, #108]	; (70c <usart_os_init+0xec>)
     6a0:	6123      	str	r3, [r4, #16]
	descr->device.usart_cb.error_cb     = usart_os_error;
     6a2:	4b1b      	ldr	r3, [pc, #108]	; (710 <usart_os_init+0xf0>)
     6a4:	6163      	str	r3, [r4, #20]
	_usart_async_set_irq_state(&descr->device, USART_ASYNC_RX_DONE, true);
     6a6:	2201      	movs	r2, #1
     6a8:	4611      	mov	r1, r2
     6aa:	4640      	mov	r0, r8
     6ac:	4c19      	ldr	r4, [pc, #100]	; (714 <usart_os_init+0xf4>)
     6ae:	47a0      	blx	r4
	_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, true);
     6b0:	2201      	movs	r2, #1
     6b2:	2103      	movs	r1, #3
     6b4:	4640      	mov	r0, r8
     6b6:	47a0      	blx	r4
}
     6b8:	4628      	mov	r0, r5
     6ba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
     6be:	2000      	movs	r0, #0
     6c0:	e7bd      	b.n	63e <usart_os_init+0x1e>
     6c2:	2000      	movs	r0, #0
     6c4:	e7bb      	b.n	63e <usart_os_init+0x1e>
     6c6:	2000      	movs	r0, #0
     6c8:	e7b9      	b.n	63e <usart_os_init+0x1e>
     6ca:	2001      	movs	r0, #1
     6cc:	e7b7      	b.n	63e <usart_os_init+0x1e>
		sem_deinit(&descr->tx_sem);
     6ce:	4648      	mov	r0, r9
     6d0:	4b11      	ldr	r3, [pc, #68]	; (718 <usart_os_init+0xf8>)
     6d2:	4798      	blx	r3
		return rc;
     6d4:	e7f0      	b.n	6b8 <usart_os_init+0x98>
		sem_deinit(&descr->tx_sem);
     6d6:	4648      	mov	r0, r9
     6d8:	4c0f      	ldr	r4, [pc, #60]	; (718 <usart_os_init+0xf8>)
     6da:	47a0      	blx	r4
		sem_deinit(&descr->rx_sem);
     6dc:	4630      	mov	r0, r6
     6de:	47a0      	blx	r4
		return rc;
     6e0:	e7ea      	b.n	6b8 <usart_os_init+0x98>
		return ERR_INVALID_ARG;
     6e2:	f06f 050c 	mvn.w	r5, #12
     6e6:	e7e7      	b.n	6b8 <usart_os_init+0x98>
     6e8:	00003100 	.word	0x00003100
     6ec:	00000749 	.word	0x00000749
     6f0:	00000751 	.word	0x00000751
     6f4:	00000d41 	.word	0x00000d41
     6f8:	00000b49 	.word	0x00000b49
     6fc:	0000057d 	.word	0x0000057d
     700:	00000529 	.word	0x00000529
     704:	00000549 	.word	0x00000549
     708:	000004f5 	.word	0x000004f5
     70c:	000004e5 	.word	0x000004e5
     710:	000004d5 	.word	0x000004d5
     714:	00000bf9 	.word	0x00000bf9
     718:	00000dd5 	.word	0x00000dd5

0000071c <usart_os_enable>:
{
     71c:	b510      	push	{r4, lr}
	ASSERT(descr);
     71e:	4604      	mov	r4, r0
     720:	227b      	movs	r2, #123	; 0x7b
     722:	4906      	ldr	r1, [pc, #24]	; (73c <usart_os_enable+0x20>)
     724:	3000      	adds	r0, #0
     726:	bf18      	it	ne
     728:	2001      	movne	r0, #1
     72a:	4b05      	ldr	r3, [pc, #20]	; (740 <usart_os_enable+0x24>)
     72c:	4798      	blx	r3
	_usart_async_enable(&descr->device);
     72e:	f104 0008 	add.w	r0, r4, #8
     732:	4b04      	ldr	r3, [pc, #16]	; (744 <usart_os_enable+0x28>)
     734:	4798      	blx	r3
}
     736:	2000      	movs	r0, #0
     738:	bd10      	pop	{r4, pc}
     73a:	bf00      	nop
     73c:	00003100 	.word	0x00003100
     740:	00000749 	.word	0x00000749
     744:	00000bcd 	.word	0x00000bcd

00000748 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
     748:	b900      	cbnz	r0, 74c <assert+0x4>
		__asm("BKPT #0");
     74a:	be00      	bkpt	0x0000
     74c:	4770      	bx	lr
	...

00000750 <ringbuffer_init>:

/**
 * \brief Ringbuffer init
 */
int32_t ringbuffer_init(struct ringbuffer *const rb, void *buf, uint32_t size)
{
     750:	b570      	push	{r4, r5, r6, lr}
     752:	460e      	mov	r6, r1
     754:	4615      	mov	r5, r2
	ASSERT(rb && buf && size);
     756:	4604      	mov	r4, r0
     758:	b178      	cbz	r0, 77a <ringbuffer_init+0x2a>
     75a:	b181      	cbz	r1, 77e <ringbuffer_init+0x2e>
     75c:	b98a      	cbnz	r2, 782 <ringbuffer_init+0x32>
     75e:	2000      	movs	r0, #0
     760:	2228      	movs	r2, #40	; 0x28
     762:	490a      	ldr	r1, [pc, #40]	; (78c <ringbuffer_init+0x3c>)
     764:	4b0a      	ldr	r3, [pc, #40]	; (790 <ringbuffer_init+0x40>)
     766:	4798      	blx	r3

	/*
	 * buf size must be aligned to power of 2
	 */
	if ((size & (size - 1)) != 0) {
     768:	1e6b      	subs	r3, r5, #1
     76a:	421d      	tst	r5, r3
     76c:	d10b      	bne.n	786 <ringbuffer_init+0x36>
		return ERR_INVALID_ARG;
	}

	/* size - 1 is faster in calculation */
	rb->size        = size - 1;
     76e:	6063      	str	r3, [r4, #4]
	rb->read_index  = 0;
     770:	2000      	movs	r0, #0
     772:	60a0      	str	r0, [r4, #8]
	rb->write_index = rb->read_index;
     774:	60e0      	str	r0, [r4, #12]
	rb->buf         = (uint8_t *)buf;
     776:	6026      	str	r6, [r4, #0]

	return ERR_NONE;
     778:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(rb && buf && size);
     77a:	2000      	movs	r0, #0
     77c:	e7f0      	b.n	760 <ringbuffer_init+0x10>
     77e:	2000      	movs	r0, #0
     780:	e7ee      	b.n	760 <ringbuffer_init+0x10>
     782:	2001      	movs	r0, #1
     784:	e7ec      	b.n	760 <ringbuffer_init+0x10>
		return ERR_INVALID_ARG;
     786:	f06f 000c 	mvn.w	r0, #12
}
     78a:	bd70      	pop	{r4, r5, r6, pc}
     78c:	0000311c 	.word	0x0000311c
     790:	00000749 	.word	0x00000749

00000794 <ringbuffer_get>:
/**
 * \brief Get one byte from ringbuffer
 *
 */
int32_t ringbuffer_get(struct ringbuffer *const rb, uint8_t *data)
{
     794:	b538      	push	{r3, r4, r5, lr}
     796:	460d      	mov	r5, r1
	ASSERT(rb && data);
     798:	4604      	mov	r4, r0
     79a:	b1a8      	cbz	r0, 7c8 <ringbuffer_get+0x34>
     79c:	b191      	cbz	r1, 7c4 <ringbuffer_get+0x30>
     79e:	2001      	movs	r0, #1
     7a0:	2240      	movs	r2, #64	; 0x40
     7a2:	490c      	ldr	r1, [pc, #48]	; (7d4 <ringbuffer_get+0x40>)
     7a4:	4b0c      	ldr	r3, [pc, #48]	; (7d8 <ringbuffer_get+0x44>)
     7a6:	4798      	blx	r3

	if (rb->write_index != rb->read_index) {
     7a8:	68e2      	ldr	r2, [r4, #12]
     7aa:	68a3      	ldr	r3, [r4, #8]
     7ac:	429a      	cmp	r2, r3
     7ae:	d00d      	beq.n	7cc <ringbuffer_get+0x38>
		*data = rb->buf[rb->read_index & rb->size];
     7b0:	6822      	ldr	r2, [r4, #0]
     7b2:	6861      	ldr	r1, [r4, #4]
     7b4:	400b      	ands	r3, r1
     7b6:	5cd3      	ldrb	r3, [r2, r3]
     7b8:	702b      	strb	r3, [r5, #0]
		rb->read_index++;
     7ba:	68a3      	ldr	r3, [r4, #8]
     7bc:	3301      	adds	r3, #1
     7be:	60a3      	str	r3, [r4, #8]
		return ERR_NONE;
     7c0:	2000      	movs	r0, #0
     7c2:	bd38      	pop	{r3, r4, r5, pc}
	ASSERT(rb && data);
     7c4:	2000      	movs	r0, #0
     7c6:	e7eb      	b.n	7a0 <ringbuffer_get+0xc>
     7c8:	2000      	movs	r0, #0
     7ca:	e7e9      	b.n	7a0 <ringbuffer_get+0xc>
	}

	return ERR_NOT_FOUND;
     7cc:	f06f 0009 	mvn.w	r0, #9
}
     7d0:	bd38      	pop	{r3, r4, r5, pc}
     7d2:	bf00      	nop
     7d4:	0000311c 	.word	0x0000311c
     7d8:	00000749 	.word	0x00000749

000007dc <ringbuffer_put>:
/**
 * \brief Put one byte to ringbuffer
 *
 */
int32_t ringbuffer_put(struct ringbuffer *const rb, uint8_t data)
{
     7dc:	b538      	push	{r3, r4, r5, lr}
     7de:	460d      	mov	r5, r1
	ASSERT(rb);
     7e0:	4604      	mov	r4, r0
     7e2:	2251      	movs	r2, #81	; 0x51
     7e4:	490b      	ldr	r1, [pc, #44]	; (814 <ringbuffer_put+0x38>)
     7e6:	3000      	adds	r0, #0
     7e8:	bf18      	it	ne
     7ea:	2001      	movne	r0, #1
     7ec:	4b0a      	ldr	r3, [pc, #40]	; (818 <ringbuffer_put+0x3c>)
     7ee:	4798      	blx	r3

	rb->buf[rb->write_index & rb->size] = data;
     7f0:	6822      	ldr	r2, [r4, #0]
     7f2:	68e3      	ldr	r3, [r4, #12]
     7f4:	6861      	ldr	r1, [r4, #4]
     7f6:	400b      	ands	r3, r1
     7f8:	54d5      	strb	r5, [r2, r3]

	/*
	 * buffer full strategy: new data will overwrite the oldest data in
	 * the buffer
	 */
	if ((rb->write_index - rb->read_index) > rb->size) {
     7fa:	68e3      	ldr	r3, [r4, #12]
     7fc:	68a2      	ldr	r2, [r4, #8]
     7fe:	1a9a      	subs	r2, r3, r2
     800:	6861      	ldr	r1, [r4, #4]
     802:	428a      	cmp	r2, r1
     804:	d901      	bls.n	80a <ringbuffer_put+0x2e>
		rb->read_index = rb->write_index - rb->size;
     806:	1a59      	subs	r1, r3, r1
     808:	60a1      	str	r1, [r4, #8]
	}

	rb->write_index++;
     80a:	3301      	adds	r3, #1
     80c:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
}
     80e:	2000      	movs	r0, #0
     810:	bd38      	pop	{r3, r4, r5, pc}
     812:	bf00      	nop
     814:	0000311c 	.word	0x0000311c
     818:	00000749 	.word	0x00000749

0000081c <ringbuffer_num>:

/**
 * \brief Return the element number of ringbuffer
 */
uint32_t ringbuffer_num(const struct ringbuffer *const rb)
{
     81c:	b510      	push	{r4, lr}
	ASSERT(rb);
     81e:	4604      	mov	r4, r0
     820:	2267      	movs	r2, #103	; 0x67
     822:	4905      	ldr	r1, [pc, #20]	; (838 <ringbuffer_num+0x1c>)
     824:	3000      	adds	r0, #0
     826:	bf18      	it	ne
     828:	2001      	movne	r0, #1
     82a:	4b04      	ldr	r3, [pc, #16]	; (83c <ringbuffer_num+0x20>)
     82c:	4798      	blx	r3

	return rb->write_index - rb->read_index;
     82e:	68e0      	ldr	r0, [r4, #12]
     830:	68a3      	ldr	r3, [r4, #8]
}
     832:	1ac0      	subs	r0, r0, r3
     834:	bd10      	pop	{r4, pc}
     836:	bf00      	nop
     838:	0000311c 	.word	0x0000311c
     83c:	00000749 	.word	0x00000749

00000840 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
     840:	b508      	push	{r3, lr}
}

static inline void hri_nvmctrl_set_CTRLA_RWS_bf(const void *const hw, hri_nvmctrl_ctrla_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLA.reg |= NVMCTRL_CTRLA_RWS(mask);
     842:	4a08      	ldr	r2, [pc, #32]	; (864 <_init_chip+0x24>)
     844:	8813      	ldrh	r3, [r2, #0]
     846:	b29b      	uxth	r3, r3
     848:	8013      	strh	r3, [r2, #0]
	hri_nvmctrl_set_CTRLA_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_osc32kctrl_init_sources();
     84a:	4b07      	ldr	r3, [pc, #28]	; (868 <_init_chip+0x28>)
     84c:	4798      	blx	r3
	_oscctrl_init_sources();
     84e:	4b07      	ldr	r3, [pc, #28]	; (86c <_init_chip+0x2c>)
     850:	4798      	blx	r3
	_mclk_init();
     852:	4b07      	ldr	r3, [pc, #28]	; (870 <_init_chip+0x30>)
     854:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
#endif
	_oscctrl_init_referenced_generators();
     856:	4b07      	ldr	r3, [pc, #28]	; (874 <_init_chip+0x34>)
     858:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
     85a:	f640 70ff 	movw	r0, #4095	; 0xfff
     85e:	4b06      	ldr	r3, [pc, #24]	; (878 <_init_chip+0x38>)
     860:	4798      	blx	r3
     862:	bd08      	pop	{r3, pc}
     864:	41004000 	.word	0x41004000
     868:	000008ad 	.word	0x000008ad
     86c:	000008c1 	.word	0x000008c1
     870:	000008a1 	.word	0x000008a1
     874:	000008dd 	.word	0x000008dd
     878:	0000087d 	.word	0x0000087d

0000087c <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
     87c:	f010 0f01 	tst.w	r0, #1
     880:	d008      	beq.n	894 <_gclk_init_generators_by_fref+0x18>
	((Gclk *)hw)->GENCTRL[index].reg = data;
     882:	4a05      	ldr	r2, [pc, #20]	; (898 <_gclk_init_generators_by_fref+0x1c>)
     884:	4b05      	ldr	r3, [pc, #20]	; (89c <_gclk_init_generators_by_fref+0x20>)
     886:	621a      	str	r2, [r3, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
     888:	4b04      	ldr	r3, [pc, #16]	; (89c <_gclk_init_generators_by_fref+0x20>)
     88a:	685a      	ldr	r2, [r3, #4]
     88c:	f643 73fd 	movw	r3, #16381	; 0x3ffd
     890:	421a      	tst	r2, r3
     892:	d1f9      	bne.n	888 <_gclk_init_generators_by_fref+0xc>
     894:	4770      	bx	lr
     896:	bf00      	nop
     898:	00010101 	.word	0x00010101
     89c:	40001c00 	.word	0x40001c00

000008a0 <_mclk_init>:
	((Mclk *)hw)->CPUDIV.reg = data;
     8a0:	2201      	movs	r2, #1
     8a2:	4b01      	ldr	r3, [pc, #4]	; (8a8 <_mclk_init+0x8>)
     8a4:	715a      	strb	r2, [r3, #5]
     8a6:	4770      	bx	lr
     8a8:	40000800 	.word	0x40000800

000008ac <_osc32kctrl_init_sources>:
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
     8ac:	4b03      	ldr	r3, [pc, #12]	; (8bc <_osc32kctrl_init_sources+0x10>)
     8ae:	69da      	ldr	r2, [r3, #28]
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSCULP32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSCULP32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
     8b0:	f402 527c 	and.w	r2, r2, #16128	; 0x3f00
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
     8b4:	61da      	str	r2, [r3, #28]
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
     8b6:	2200      	movs	r2, #0
     8b8:	741a      	strb	r2, [r3, #16]
     8ba:	4770      	bx	lr
     8bc:	40001400 	.word	0x40001400

000008c0 <_oscctrl_init_sources>:
}

static inline void hri_oscctrl_write_XOSCCTRL_reg(const void *const hw, uint8_t index, hri_oscctrl_xoscctrl_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->XOSCCTRL[index].reg = data;
     8c0:	4a04      	ldr	r2, [pc, #16]	; (8d4 <_oscctrl_init_sources+0x14>)
     8c2:	4b05      	ldr	r3, [pc, #20]	; (8d8 <_oscctrl_init_sources+0x18>)
     8c4:	619a      	str	r2, [r3, #24]
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_XOSCRDY1) >> OSCCTRL_STATUS_XOSCRDY1_Pos;
     8c6:	4b04      	ldr	r3, [pc, #16]	; (8d8 <_oscctrl_init_sources+0x18>)
     8c8:	691b      	ldr	r3, [r3, #16]
	        | (CONF_XOSC1_XTALEN << OSCCTRL_XOSCCTRL_XTALEN_Pos) | (CONF_XOSC1_ENABLE << OSCCTRL_XOSCCTRL_ENABLE_Pos));
#endif

#if CONF_XOSC1_CONFIG == 1
#if CONF_XOSC1_ENABLE == 1
	while (!hri_oscctrl_get_STATUS_XOSCRDY1_bit(hw))
     8ca:	f013 0f02 	tst.w	r3, #2
     8ce:	d0fa      	beq.n	8c6 <_oscctrl_init_sources+0x6>
	hri_oscctrl_set_XOSCCTRL_ONDEMAND_bit(hw, 1);
#endif
#endif

	(void)hw;
}
     8d0:	4770      	bx	lr
     8d2:	bf00      	nop
     8d4:	03002606 	.word	0x03002606
     8d8:	40001000 	.word	0x40001000

000008dc <_oscctrl_init_referenced_generators>:

void _oscctrl_init_referenced_generators(void)
{
     8dc:	4770      	bx	lr
	...

000008e0 <RAMECC_Handler>:

/**
 * \internal RAMECC interrupt handler
 */
void RAMECC_Handler(void)
{
     8e0:	b500      	push	{lr}
     8e2:	b083      	sub	sp, #12
	return tmp;
}

static inline hri_ramecc_intflag_reg_t hri_ramecc_read_INTFLAG_reg(const void *const hw)
{
	return ((Ramecc *)hw)->INTFLAG.reg;
     8e4:	4b0d      	ldr	r3, [pc, #52]	; (91c <RAMECC_Handler+0x3c>)
     8e6:	789b      	ldrb	r3, [r3, #2]
     8e8:	b2db      	uxtb	r3, r3
	struct _ramecc_device *dev      = (struct _ramecc_device *)&device;
	volatile uint32_t      int_mask = hri_ramecc_read_INTFLAG_reg(RAMECC);
     8ea:	9301      	str	r3, [sp, #4]

	if (int_mask & RAMECC_INTFLAG_DUALE && dev->ramecc_cb.dual_bit_err) {
     8ec:	9b01      	ldr	r3, [sp, #4]
     8ee:	f013 0f02 	tst.w	r3, #2
     8f2:	d006      	beq.n	902 <RAMECC_Handler+0x22>
     8f4:	4b0a      	ldr	r3, [pc, #40]	; (920 <RAMECC_Handler+0x40>)
     8f6:	681b      	ldr	r3, [r3, #0]
     8f8:	b11b      	cbz	r3, 902 <RAMECC_Handler+0x22>
	return tmp;
}

static inline hri_ramecc_erraddr_reg_t hri_ramecc_read_ERRADDR_reg(const void *const hw)
{
	return ((Ramecc *)hw)->ERRADDR.reg;
     8fa:	4a08      	ldr	r2, [pc, #32]	; (91c <RAMECC_Handler+0x3c>)
     8fc:	6850      	ldr	r0, [r2, #4]
		dev->ramecc_cb.dual_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
     8fe:	4798      	blx	r3
     900:	e009      	b.n	916 <RAMECC_Handler+0x36>
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
     902:	9b01      	ldr	r3, [sp, #4]
     904:	f013 0f01 	tst.w	r3, #1
     908:	d005      	beq.n	916 <RAMECC_Handler+0x36>
     90a:	4b05      	ldr	r3, [pc, #20]	; (920 <RAMECC_Handler+0x40>)
     90c:	685b      	ldr	r3, [r3, #4]
     90e:	b113      	cbz	r3, 916 <RAMECC_Handler+0x36>
     910:	4a02      	ldr	r2, [pc, #8]	; (91c <RAMECC_Handler+0x3c>)
     912:	6850      	ldr	r0, [r2, #4]
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
     914:	4798      	blx	r3
	} else {
		return;
	}
}
     916:	b003      	add	sp, #12
     918:	f85d fb04 	ldr.w	pc, [sp], #4
     91c:	41020000 	.word	0x41020000
     920:	20000f90 	.word	0x20000f90

00000924 <_sercom_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given sercom hardware instance
 */
static uint8_t _sercom_get_hardware_index(const void *const hw)
{
     924:	b470      	push	{r4, r5, r6}
     926:	b089      	sub	sp, #36	; 0x24
     928:	4606      	mov	r6, r0
	Sercom *const sercom_modules[] = SERCOM_INSTS;
     92a:	466c      	mov	r4, sp
     92c:	4d0c      	ldr	r5, [pc, #48]	; (960 <_sercom_get_hardware_index+0x3c>)
     92e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
     930:	c40f      	stmia	r4!, {r0, r1, r2, r3}
     932:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
     936:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	/* Find index for SERCOM instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
     93a:	2000      	movs	r0, #0
     93c:	2807      	cmp	r0, #7
     93e:	d80a      	bhi.n	956 <_sercom_get_hardware_index+0x32>
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
     940:	ab08      	add	r3, sp, #32
     942:	eb03 0380 	add.w	r3, r3, r0, lsl #2
     946:	f853 3c20 	ldr.w	r3, [r3, #-32]
     94a:	42b3      	cmp	r3, r6
     94c:	d001      	beq.n	952 <_sercom_get_hardware_index+0x2e>
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
     94e:	3001      	adds	r0, #1
     950:	e7f4      	b.n	93c <_sercom_get_hardware_index+0x18>
			return i;
     952:	b2c0      	uxtb	r0, r0
     954:	e000      	b.n	958 <_sercom_get_hardware_index+0x34>
		}
	}
	return 0;
     956:	2000      	movs	r0, #0
}
     958:	b009      	add	sp, #36	; 0x24
     95a:	bc70      	pop	{r4, r5, r6}
     95c:	4770      	bx	lr
     95e:	bf00      	nop
     960:	00003140 	.word	0x00003140

00000964 <_sercom_usart_interrupt_handler>:
 * \internal Sercom interrupt handler
 *
 * \param[in] p The pointer to interrupt parameter
 */
static void _sercom_usart_interrupt_handler(struct _usart_async_device *device)
{
     964:	b510      	push	{r4, lr}
	void *hw = device->hw;
     966:	6984      	ldr	r4, [r0, #24]
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
}

static inline bool hri_sercomusart_get_interrupt_DRE_bit(const void *const hw)
{
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
     968:	7e23      	ldrb	r3, [r4, #24]

	if (hri_sercomusart_get_interrupt_DRE_bit(hw) && hri_sercomusart_get_INTEN_DRE_bit(hw)) {
     96a:	f013 0f01 	tst.w	r3, #1
     96e:	d003      	beq.n	978 <_sercom_usart_interrupt_handler+0x14>
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
}

static inline bool hri_sercomusart_get_INTEN_DRE_bit(const void *const hw)
{
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_DRE) >> SERCOM_USART_INTENSET_DRE_Pos;
     970:	7da3      	ldrb	r3, [r4, #22]
     972:	f013 0f01 	tst.w	r3, #1
     976:	d112      	bne.n	99e <_sercom_usart_interrupt_handler+0x3a>
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
     978:	7e23      	ldrb	r3, [r4, #24]
		hri_sercomusart_clear_INTEN_DRE_bit(hw);
		device->usart_cb.tx_byte_sent(device);
	} else if (hri_sercomusart_get_interrupt_TXC_bit(hw) && hri_sercomusart_get_INTEN_TXC_bit(hw)) {
     97a:	f013 0f02 	tst.w	r3, #2
     97e:	d003      	beq.n	988 <_sercom_usart_interrupt_handler+0x24>
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
}

static inline bool hri_sercomusart_get_INTEN_TXC_bit(const void *const hw)
{
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_TXC) >> SERCOM_USART_INTENSET_TXC_Pos;
     980:	7da3      	ldrb	r3, [r4, #22]
     982:	f013 0f02 	tst.w	r3, #2
     986:	d10f      	bne.n	9a8 <_sercom_usart_interrupt_handler+0x44>
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
     988:	7e23      	ldrb	r3, [r4, #24]
		hri_sercomusart_clear_INTEN_TXC_bit(hw);
		device->usart_cb.tx_done_cb(device);
	} else if (hri_sercomusart_get_interrupt_RXC_bit(hw)) {
     98a:	f013 0f04 	tst.w	r3, #4
     98e:	d015      	beq.n	9bc <_sercom_usart_interrupt_handler+0x58>
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_status_reg_t hri_sercomusart_read_STATUS_reg(const void *const hw)
{
	return ((Sercom *)hw)->USART.STATUS.reg;
     990:	8b63      	ldrh	r3, [r4, #26]
		if (hri_sercomusart_read_STATUS_reg(hw)
     992:	f003 0337 	and.w	r3, r3, #55	; 0x37
     996:	b163      	cbz	r3, 9b2 <_sercom_usart_interrupt_handler+0x4e>
	((Sercom *)hw)->USART.STATUS.reg = mask;
     998:	23ff      	movs	r3, #255	; 0xff
     99a:	8363      	strh	r3, [r4, #26]
     99c:	bd10      	pop	{r4, pc}
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
     99e:	2301      	movs	r3, #1
     9a0:	7523      	strb	r3, [r4, #20]
		device->usart_cb.tx_byte_sent(device);
     9a2:	6803      	ldr	r3, [r0, #0]
     9a4:	4798      	blx	r3
     9a6:	bd10      	pop	{r4, pc}
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
     9a8:	2302      	movs	r3, #2
     9aa:	7523      	strb	r3, [r4, #20]
		device->usart_cb.tx_done_cb(device);
     9ac:	6883      	ldr	r3, [r0, #8]
     9ae:	4798      	blx	r3
     9b0:	bd10      	pop	{r4, pc}
		       | SERCOM_USART_STATUS_ISF | SERCOM_USART_STATUS_COLL)) {
			hri_sercomusart_clear_STATUS_reg(hw, SERCOM_USART_STATUS_MASK);
			return;
		}

		device->usart_cb.rx_done_cb(device, hri_sercomusart_read_DATA_reg(hw));
     9b2:	6843      	ldr	r3, [r0, #4]
	return ((Sercom *)hw)->USART.DATA.reg;
     9b4:	6aa1      	ldr	r1, [r4, #40]	; 0x28
     9b6:	b2c9      	uxtb	r1, r1
     9b8:	4798      	blx	r3
     9ba:	bd10      	pop	{r4, pc}
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_ERROR) >> SERCOM_USART_INTFLAG_ERROR_Pos;
     9bc:	7e23      	ldrb	r3, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_ERROR_bit(hw)) {
     9be:	09db      	lsrs	r3, r3, #7
     9c0:	d100      	bne.n	9c4 <_sercom_usart_interrupt_handler+0x60>
     9c2:	bd10      	pop	{r4, pc}
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
     9c4:	2380      	movs	r3, #128	; 0x80
     9c6:	7623      	strb	r3, [r4, #24]
		uint32_t status;

		hri_sercomusart_clear_interrupt_ERROR_bit(hw);
		device->usart_cb.error_cb(device);
     9c8:	68c3      	ldr	r3, [r0, #12]
     9ca:	4798      	blx	r3
	return ((Sercom *)hw)->USART.STATUS.reg;
     9cc:	8b63      	ldrh	r3, [r4, #26]
     9ce:	b29b      	uxth	r3, r3
	((Sercom *)hw)->USART.STATUS.reg = mask;
     9d0:	8363      	strh	r3, [r4, #26]
     9d2:	e7f6      	b.n	9c2 <_sercom_usart_interrupt_handler+0x5e>

000009d4 <_sercom_init_irq_param>:
 * \brief Init irq param with the given sercom hardware instance
 */
static void _sercom_init_irq_param(const void *const hw, void *dev)
{

	if (hw == SERCOM2) {
     9d4:	4b03      	ldr	r3, [pc, #12]	; (9e4 <_sercom_init_irq_param+0x10>)
     9d6:	4298      	cmp	r0, r3
     9d8:	d000      	beq.n	9dc <_sercom_init_irq_param+0x8>
     9da:	4770      	bx	lr
		_sercom2_dev = (struct _usart_async_device *)dev;
     9dc:	4b02      	ldr	r3, [pc, #8]	; (9e8 <_sercom_init_irq_param+0x14>)
     9de:	6019      	str	r1, [r3, #0]
	}
}
     9e0:	e7fb      	b.n	9da <_sercom_init_irq_param+0x6>
     9e2:	bf00      	nop
     9e4:	41012000 	.word	0x41012000
     9e8:	20000028 	.word	0x20000028

000009ec <_sercom_get_irq_num>:

/**
 * \brief Retrieve IRQ number for the given hardware instance
 */
static uint8_t _sercom_get_irq_num(const void *const hw)
{
     9ec:	b508      	push	{r3, lr}
	return SERCOM0_0_IRQn + (_sercom_get_hardware_index(hw) << 2);
     9ee:	4b04      	ldr	r3, [pc, #16]	; (a00 <_sercom_get_irq_num+0x14>)
     9f0:	4798      	blx	r3
     9f2:	0080      	lsls	r0, r0, #2
     9f4:	b2c0      	uxtb	r0, r0
     9f6:	302e      	adds	r0, #46	; 0x2e
}
     9f8:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
     9fc:	bd08      	pop	{r3, pc}
     9fe:	bf00      	nop
     a00:	00000925 	.word	0x00000925

00000a04 <_get_sercom_index>:
{
     a04:	b508      	push	{r3, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
     a06:	4b0c      	ldr	r3, [pc, #48]	; (a38 <_get_sercom_index+0x34>)
     a08:	4798      	blx	r3
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
     a0a:	2300      	movs	r3, #0
     a0c:	b143      	cbz	r3, a20 <_get_sercom_index+0x1c>
	ASSERT(false);
     a0e:	f240 226b 	movw	r2, #619	; 0x26b
     a12:	490a      	ldr	r1, [pc, #40]	; (a3c <_get_sercom_index+0x38>)
     a14:	2000      	movs	r0, #0
     a16:	4b0a      	ldr	r3, [pc, #40]	; (a40 <_get_sercom_index+0x3c>)
     a18:	4798      	blx	r3
	return 0;
     a1a:	2300      	movs	r3, #0
}
     a1c:	4618      	mov	r0, r3
     a1e:	bd08      	pop	{r3, pc}
		if (_usarts[i].number == sercom_offset) {
     a20:	eb03 0243 	add.w	r2, r3, r3, lsl #1
     a24:	00d1      	lsls	r1, r2, #3
     a26:	4a07      	ldr	r2, [pc, #28]	; (a44 <_get_sercom_index+0x40>)
     a28:	440a      	add	r2, r1
     a2a:	f892 2020 	ldrb.w	r2, [r2, #32]
     a2e:	4290      	cmp	r0, r2
     a30:	d0f4      	beq.n	a1c <_get_sercom_index+0x18>
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
     a32:	3301      	adds	r3, #1
     a34:	b2db      	uxtb	r3, r3
     a36:	e7e9      	b.n	a0c <_get_sercom_index+0x8>
     a38:	00000925 	.word	0x00000925
     a3c:	000031b4 	.word	0x000031b4
     a40:	00000749 	.word	0x00000749
     a44:	00003140 	.word	0x00003140

00000a48 <_usart_init>:
{
     a48:	b538      	push	{r3, r4, r5, lr}
     a4a:	4604      	mov	r4, r0
	uint8_t i = _get_sercom_index(hw);
     a4c:	4b3c      	ldr	r3, [pc, #240]	; (b40 <_usart_init+0xf8>)
     a4e:	4798      	blx	r3
	return ((Sercom *)hw)->USART.SYNCBUSY.reg & reg;
     a50:	69e3      	ldr	r3, [r4, #28]
	if (!hri_sercomusart_is_syncing(hw, SERCOM_USART_SYNCBUSY_SWRST)) {
     a52:	f013 0f01 	tst.w	r3, #1
     a56:	d122      	bne.n	a9e <_usart_init+0x56>
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
     a58:	eb00 0340 	add.w	r3, r0, r0, lsl #1
     a5c:	00da      	lsls	r2, r3, #3
     a5e:	4b39      	ldr	r3, [pc, #228]	; (b44 <_usart_init+0xfc>)
     a60:	4413      	add	r3, r2
     a62:	6a5a      	ldr	r2, [r3, #36]	; 0x24
     a64:	f002 021c 	and.w	r2, r2, #28
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     a68:	69e3      	ldr	r3, [r4, #28]
     a6a:	f013 0f03 	tst.w	r3, #3
     a6e:	d1fb      	bne.n	a68 <_usart_init+0x20>
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
     a70:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
     a72:	f013 0f02 	tst.w	r3, #2
     a76:	d00b      	beq.n	a90 <_usart_init+0x48>
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
     a78:	6823      	ldr	r3, [r4, #0]
     a7a:	f023 0302 	bic.w	r3, r3, #2
     a7e:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     a80:	69e3      	ldr	r3, [r4, #28]
     a82:	f013 0f03 	tst.w	r3, #3
     a86:	d1fb      	bne.n	a80 <_usart_init+0x38>
     a88:	69e3      	ldr	r3, [r4, #28]
     a8a:	f013 0f02 	tst.w	r3, #2
     a8e:	d1fb      	bne.n	a88 <_usart_init+0x40>
		hri_sercomusart_write_CTRLA_reg(hw, SERCOM_USART_CTRLA_SWRST | mode);
     a90:	f042 0201 	orr.w	r2, r2, #1
	((Sercom *)hw)->USART.CTRLA.reg = data;
     a94:	6022      	str	r2, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     a96:	69e3      	ldr	r3, [r4, #28]
     a98:	f013 0f03 	tst.w	r3, #3
     a9c:	d1fb      	bne.n	a96 <_usart_init+0x4e>
     a9e:	69e3      	ldr	r3, [r4, #28]
     aa0:	f013 0f01 	tst.w	r3, #1
     aa4:	d1fb      	bne.n	a9e <_usart_init+0x56>
	hri_sercomusart_write_CTRLA_reg(hw, _usarts[i].ctrl_a);
     aa6:	eb00 0340 	add.w	r3, r0, r0, lsl #1
     aaa:	00da      	lsls	r2, r3, #3
     aac:	4b25      	ldr	r3, [pc, #148]	; (b44 <_usart_init+0xfc>)
     aae:	4413      	add	r3, r2
     ab0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
	((Sercom *)hw)->USART.CTRLA.reg = data;
     ab2:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     ab4:	69e3      	ldr	r3, [r4, #28]
     ab6:	f013 0f03 	tst.w	r3, #3
     aba:	d1fb      	bne.n	ab4 <_usart_init+0x6c>
	hri_sercomusart_write_CTRLB_reg(hw, _usarts[i].ctrl_b);
     abc:	eb00 0340 	add.w	r3, r0, r0, lsl #1
     ac0:	00da      	lsls	r2, r3, #3
     ac2:	4b20      	ldr	r3, [pc, #128]	; (b44 <_usart_init+0xfc>)
     ac4:	4413      	add	r3, r2
     ac6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
	((Sercom *)hw)->USART.CTRLB.reg = data;
     ac8:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     aca:	69e3      	ldr	r3, [r4, #28]
     acc:	f013 0f1f 	tst.w	r3, #31
     ad0:	d1fb      	bne.n	aca <_usart_init+0x82>
	hri_sercomusart_write_CTRLC_reg(hw, _usarts[i].ctrl_c);
     ad2:	0042      	lsls	r2, r0, #1
     ad4:	4402      	add	r2, r0
     ad6:	00d1      	lsls	r1, r2, #3
     ad8:	4b1a      	ldr	r3, [pc, #104]	; (b44 <_usart_init+0xfc>)
     ada:	440b      	add	r3, r1
     adc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
	((Sercom *)hw)->USART.CTRLC.reg = data;
     ade:	60a2      	str	r2, [r4, #8]
	if ((_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x1)) || (_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x3))) {
     ae0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     ae2:	f413 5f00 	tst.w	r3, #8192	; 0x2000
     ae6:	d10a      	bne.n	afe <_usart_init+0xb6>
     ae8:	f413 4fc0 	tst.w	r3, #24576	; 0x6000
     aec:	d107      	bne.n	afe <_usart_init+0xb6>
		hri_sercomusart_write_BAUD_reg(hw, _usarts[i].baud);
     aee:	eb00 0340 	add.w	r3, r0, r0, lsl #1
     af2:	00da      	lsls	r2, r3, #3
     af4:	4b13      	ldr	r3, [pc, #76]	; (b44 <_usart_init+0xfc>)
     af6:	4413      	add	r3, r2
     af8:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
	((Sercom *)hw)->USART.BAUD.reg = data;
     afa:	81a3      	strh	r3, [r4, #12]
     afc:	e00f      	b.n	b1e <_usart_init+0xd6>
		((Sercom *)hw)->USART.BAUD.FRAC.BAUD = _usarts[i].baud;
     afe:	0042      	lsls	r2, r0, #1
     b00:	4402      	add	r2, r0
     b02:	00d1      	lsls	r1, r2, #3
     b04:	4b0f      	ldr	r3, [pc, #60]	; (b44 <_usart_init+0xfc>)
     b06:	440b      	add	r3, r1
     b08:	8e19      	ldrh	r1, [r3, #48]	; 0x30
     b0a:	89a2      	ldrh	r2, [r4, #12]
     b0c:	f361 020c 	bfi	r2, r1, #0, #13
     b10:	81a2      	strh	r2, [r4, #12]
		((Sercom *)hw)->USART.BAUD.FRAC.FP   = _usarts[i].fractional;
     b12:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
     b16:	89a3      	ldrh	r3, [r4, #12]
     b18:	f362 334f 	bfi	r3, r2, #13, #3
     b1c:	81a3      	strh	r3, [r4, #12]
	hri_sercomusart_write_RXPL_reg(hw, _usarts[i].rxpl);
     b1e:	4a09      	ldr	r2, [pc, #36]	; (b44 <_usart_init+0xfc>)
     b20:	0043      	lsls	r3, r0, #1
     b22:	181d      	adds	r5, r3, r0
     b24:	00e9      	lsls	r1, r5, #3
     b26:	460d      	mov	r5, r1
     b28:	4411      	add	r1, r2
     b2a:	f891 1033 	ldrb.w	r1, [r1, #51]	; 0x33
	((Sercom *)hw)->USART.RXPL.reg = data;
     b2e:	73a1      	strb	r1, [r4, #14]
	hri_sercomusart_write_DBGCTRL_reg(hw, _usarts[i].debug_ctrl);
     b30:	442a      	add	r2, r5
     b32:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
     b36:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
}
     b3a:	2000      	movs	r0, #0
     b3c:	bd38      	pop	{r3, r4, r5, pc}
     b3e:	bf00      	nop
     b40:	00000a05 	.word	0x00000a05
     b44:	00003140 	.word	0x00003140

00000b48 <_usart_async_init>:
{
     b48:	b570      	push	{r4, r5, r6, lr}
     b4a:	460c      	mov	r4, r1
	ASSERT(device);
     b4c:	4606      	mov	r6, r0
     b4e:	22cb      	movs	r2, #203	; 0xcb
     b50:	4918      	ldr	r1, [pc, #96]	; (bb4 <_usart_async_init+0x6c>)
     b52:	3000      	adds	r0, #0
     b54:	bf18      	it	ne
     b56:	2001      	movne	r0, #1
     b58:	4b17      	ldr	r3, [pc, #92]	; (bb8 <_usart_async_init+0x70>)
     b5a:	4798      	blx	r3
	init_status = _usart_init(hw);
     b5c:	4620      	mov	r0, r4
     b5e:	4b17      	ldr	r3, [pc, #92]	; (bbc <_usart_async_init+0x74>)
     b60:	4798      	blx	r3
	if (init_status) {
     b62:	4605      	mov	r5, r0
     b64:	b108      	cbz	r0, b6a <_usart_async_init+0x22>
}
     b66:	4628      	mov	r0, r5
     b68:	bd70      	pop	{r4, r5, r6, pc}
	device->hw = hw;
     b6a:	61b4      	str	r4, [r6, #24]
	_sercom_init_irq_param(hw, (void *)device);
     b6c:	4631      	mov	r1, r6
     b6e:	4620      	mov	r0, r4
     b70:	4b13      	ldr	r3, [pc, #76]	; (bc0 <_usart_async_init+0x78>)
     b72:	4798      	blx	r3
	uint8_t irq = _sercom_get_irq_num(hw);
     b74:	4620      	mov	r0, r4
     b76:	4b13      	ldr	r3, [pc, #76]	; (bc4 <_usart_async_init+0x7c>)
     b78:	4798      	blx	r3
	for (uint32_t i = 0; i < 4; i++) {
     b7a:	2400      	movs	r4, #0
     b7c:	e016      	b.n	bac <_usart_async_init+0x64>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     b7e:	0941      	lsrs	r1, r0, #5
     b80:	f000 021f 	and.w	r2, r0, #31
     b84:	2301      	movs	r3, #1
     b86:	4093      	lsls	r3, r2
     b88:	4a0f      	ldr	r2, [pc, #60]	; (bc8 <_usart_async_init+0x80>)
     b8a:	f101 0620 	add.w	r6, r1, #32
     b8e:	f842 3026 	str.w	r3, [r2, r6, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
     b92:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
     b96:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     b9a:	f101 0660 	add.w	r6, r1, #96	; 0x60
     b9e:	f842 3026 	str.w	r3, [r2, r6, lsl #2]
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     ba2:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
		irq++;
     ba6:	3001      	adds	r0, #1
     ba8:	b2c0      	uxtb	r0, r0
	for (uint32_t i = 0; i < 4; i++) {
     baa:	3401      	adds	r4, #1
     bac:	2c03      	cmp	r4, #3
     bae:	d9e6      	bls.n	b7e <_usart_async_init+0x36>
     bb0:	e7d9      	b.n	b66 <_usart_async_init+0x1e>
     bb2:	bf00      	nop
     bb4:	000031b4 	.word	0x000031b4
     bb8:	00000749 	.word	0x00000749
     bbc:	00000a49 	.word	0x00000a49
     bc0:	000009d5 	.word	0x000009d5
     bc4:	000009ed 	.word	0x000009ed
     bc8:	e000e100 	.word	0xe000e100

00000bcc <_usart_async_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
     bcc:	6982      	ldr	r2, [r0, #24]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
     bce:	6813      	ldr	r3, [r2, #0]
     bd0:	f043 0302 	orr.w	r3, r3, #2
     bd4:	6013      	str	r3, [r2, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     bd6:	69d3      	ldr	r3, [r2, #28]
     bd8:	f013 0f03 	tst.w	r3, #3
     bdc:	d1fb      	bne.n	bd6 <_usart_async_enable+0xa>
}
     bde:	4770      	bx	lr

00000be0 <_usart_async_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
     be0:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.DATA.reg = data;
     be2:	6299      	str	r1, [r3, #40]	; 0x28
     be4:	4770      	bx	lr

00000be6 <_usart_async_enable_byte_sent_irq>:
	hri_sercomusart_set_INTEN_DRE_bit(device->hw);
     be6:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
     be8:	2201      	movs	r2, #1
     bea:	759a      	strb	r2, [r3, #22]
     bec:	4770      	bx	lr

00000bee <_usart_async_enable_tx_done_irq>:
	hri_sercomusart_set_INTEN_TXC_bit(device->hw);
     bee:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
     bf0:	2202      	movs	r2, #2
     bf2:	759a      	strb	r2, [r3, #22]
     bf4:	4770      	bx	lr
	...

00000bf8 <_usart_async_set_irq_state>:
{
     bf8:	b570      	push	{r4, r5, r6, lr}
     bfa:	460c      	mov	r4, r1
     bfc:	4615      	mov	r5, r2
	ASSERT(device);
     bfe:	4606      	mov	r6, r0
     c00:	f240 222b 	movw	r2, #555	; 0x22b
     c04:	4916      	ldr	r1, [pc, #88]	; (c60 <_usart_async_set_irq_state+0x68>)
     c06:	3000      	adds	r0, #0
     c08:	bf18      	it	ne
     c0a:	2001      	movne	r0, #1
     c0c:	4b15      	ldr	r3, [pc, #84]	; (c64 <_usart_async_set_irq_state+0x6c>)
     c0e:	4798      	blx	r3
	if (USART_ASYNC_BYTE_SENT == type || USART_ASYNC_TX_DONE == type) {
     c10:	b134      	cbz	r4, c20 <_usart_async_set_irq_state+0x28>
     c12:	2c02      	cmp	r4, #2
     c14:	d004      	beq.n	c20 <_usart_async_set_irq_state+0x28>
	} else if (USART_ASYNC_RX_DONE == type) {
     c16:	2c01      	cmp	r4, #1
     c18:	d011      	beq.n	c3e <_usart_async_set_irq_state+0x46>
	} else if (USART_ASYNC_ERROR == type) {
     c1a:	2c03      	cmp	r4, #3
     c1c:	d017      	beq.n	c4e <_usart_async_set_irq_state+0x56>
     c1e:	bd70      	pop	{r4, r5, r6, pc}
		hri_sercomusart_write_INTEN_DRE_bit(device->hw, state);
     c20:	69b3      	ldr	r3, [r6, #24]
	if (value == 0x0) {
     c22:	b935      	cbnz	r5, c32 <_usart_async_set_irq_state+0x3a>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
     c24:	2201      	movs	r2, #1
     c26:	751a      	strb	r2, [r3, #20]
		hri_sercomusart_write_INTEN_TXC_bit(device->hw, state);
     c28:	69b3      	ldr	r3, [r6, #24]
	if (value == 0x0) {
     c2a:	b92d      	cbnz	r5, c38 <_usart_async_set_irq_state+0x40>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
     c2c:	2202      	movs	r2, #2
     c2e:	751a      	strb	r2, [r3, #20]
     c30:	bd70      	pop	{r4, r5, r6, pc}
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
     c32:	2201      	movs	r2, #1
     c34:	759a      	strb	r2, [r3, #22]
     c36:	e7f7      	b.n	c28 <_usart_async_set_irq_state+0x30>
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
     c38:	2202      	movs	r2, #2
     c3a:	759a      	strb	r2, [r3, #22]
     c3c:	bd70      	pop	{r4, r5, r6, pc}
		hri_sercomusart_write_INTEN_RXC_bit(device->hw, state);
     c3e:	69b3      	ldr	r3, [r6, #24]
	if (value == 0x0) {
     c40:	b915      	cbnz	r5, c48 <_usart_async_set_irq_state+0x50>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_RXC;
     c42:	2204      	movs	r2, #4
     c44:	751a      	strb	r2, [r3, #20]
     c46:	bd70      	pop	{r4, r5, r6, pc}
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_RXC;
     c48:	2204      	movs	r2, #4
     c4a:	759a      	strb	r2, [r3, #22]
     c4c:	bd70      	pop	{r4, r5, r6, pc}
		hri_sercomusart_write_INTEN_ERROR_bit(device->hw, state);
     c4e:	69b3      	ldr	r3, [r6, #24]
	if (value == 0x0) {
     c50:	b115      	cbz	r5, c58 <_usart_async_set_irq_state+0x60>
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_ERROR;
     c52:	2280      	movs	r2, #128	; 0x80
     c54:	759a      	strb	r2, [r3, #22]
}
     c56:	e7e2      	b.n	c1e <_usart_async_set_irq_state+0x26>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_ERROR;
     c58:	2280      	movs	r2, #128	; 0x80
     c5a:	751a      	strb	r2, [r3, #20]
     c5c:	bd70      	pop	{r4, r5, r6, pc}
     c5e:	bf00      	nop
     c60:	000031b4 	.word	0x000031b4
     c64:	00000749 	.word	0x00000749

00000c68 <SERCOM2_0_Handler>:

/**
 * \internal Sercom interrupt handler
 */
void SERCOM2_0_Handler(void)
{
     c68:	b508      	push	{r3, lr}
	_sercom_usart_interrupt_handler(_sercom2_dev);
     c6a:	4b02      	ldr	r3, [pc, #8]	; (c74 <SERCOM2_0_Handler+0xc>)
     c6c:	6818      	ldr	r0, [r3, #0]
     c6e:	4b02      	ldr	r3, [pc, #8]	; (c78 <SERCOM2_0_Handler+0x10>)
     c70:	4798      	blx	r3
     c72:	bd08      	pop	{r3, pc}
     c74:	20000028 	.word	0x20000028
     c78:	00000965 	.word	0x00000965

00000c7c <SERCOM2_1_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM2_1_Handler(void)
{
     c7c:	b508      	push	{r3, lr}
	_sercom_usart_interrupt_handler(_sercom2_dev);
     c7e:	4b02      	ldr	r3, [pc, #8]	; (c88 <SERCOM2_1_Handler+0xc>)
     c80:	6818      	ldr	r0, [r3, #0]
     c82:	4b02      	ldr	r3, [pc, #8]	; (c8c <SERCOM2_1_Handler+0x10>)
     c84:	4798      	blx	r3
     c86:	bd08      	pop	{r3, pc}
     c88:	20000028 	.word	0x20000028
     c8c:	00000965 	.word	0x00000965

00000c90 <SERCOM2_2_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM2_2_Handler(void)
{
     c90:	b508      	push	{r3, lr}
	_sercom_usart_interrupt_handler(_sercom2_dev);
     c92:	4b02      	ldr	r3, [pc, #8]	; (c9c <SERCOM2_2_Handler+0xc>)
     c94:	6818      	ldr	r0, [r3, #0]
     c96:	4b02      	ldr	r3, [pc, #8]	; (ca0 <SERCOM2_2_Handler+0x10>)
     c98:	4798      	blx	r3
     c9a:	bd08      	pop	{r3, pc}
     c9c:	20000028 	.word	0x20000028
     ca0:	00000965 	.word	0x00000965

00000ca4 <SERCOM2_3_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM2_3_Handler(void)
{
     ca4:	b508      	push	{r3, lr}
	_sercom_usart_interrupt_handler(_sercom2_dev);
     ca6:	4b02      	ldr	r3, [pc, #8]	; (cb0 <SERCOM2_3_Handler+0xc>)
     ca8:	6818      	ldr	r0, [r3, #0]
     caa:	4b02      	ldr	r3, [pc, #8]	; (cb4 <SERCOM2_3_Handler+0x10>)
     cac:	4798      	blx	r3
     cae:	bd08      	pop	{r3, pc}
     cb0:	20000028 	.word	0x20000028
     cb4:	00000965 	.word	0x00000965

00000cb8 <str_write>:

/**
 * \brief Write string to console
 */
static void str_write(const char *s)
{
     cb8:	b510      	push	{r4, lr}
     cba:	4604      	mov	r4, r0
	io_write(&EDBG_COM.io, (const uint8_t *)s, strlen(s));
     cbc:	4b03      	ldr	r3, [pc, #12]	; (ccc <str_write+0x14>)
     cbe:	4798      	blx	r3
     cc0:	b282      	uxth	r2, r0
     cc2:	4621      	mov	r1, r4
     cc4:	4802      	ldr	r0, [pc, #8]	; (cd0 <str_write+0x18>)
     cc6:	4b03      	ldr	r3, [pc, #12]	; (cd4 <str_write+0x1c>)
     cc8:	4798      	blx	r3
     cca:	bd10      	pop	{r4, pc}
     ccc:	000030db 	.word	0x000030db
     cd0:	20000f44 	.word	0x20000f44
     cd4:	000004a1 	.word	0x000004a1

00000cd8 <exampleTask>:
{
	vTaskStartScheduler();
}

static void exampleTask( void * parameters )
{
     cd8:	b508      	push	{r3, lr}
    ( void ) parameters;

    for( ; ; )
    {
        /* Example Task Code */
        vTaskDelay( 100 ); /* delay 100 ticks */
     cda:	2064      	movs	r0, #100	; 0x64
     cdc:	4b02      	ldr	r3, [pc, #8]	; (ce8 <exampleTask+0x10>)
     cde:	4798      	blx	r3
	    str_write( "exampleTask \r\n" );
     ce0:	4802      	ldr	r0, [pc, #8]	; (cec <exampleTask+0x14>)
     ce2:	4b03      	ldr	r3, [pc, #12]	; (cf0 <exampleTask+0x18>)
     ce4:	4798      	blx	r3
     ce6:	e7f8      	b.n	cda <exampleTask+0x2>
     ce8:	000025bd 	.word	0x000025bd
     cec:	000031d0 	.word	0x000031d0
     cf0:	00000cb9 	.word	0x00000cb9

00000cf4 <main>:
    }
}

int main(void)
{
     cf4:	b500      	push	{lr}
     cf6:	b085      	sub	sp, #20
	atmel_start_init();
     cf8:	4b09      	ldr	r3, [pc, #36]	; (d20 <main+0x2c>)
     cfa:	4798      	blx	r3

    static StaticTask_t exampleTaskTCB;
    static StackType_t exampleTaskStack[ configMINIMAL_STACK_SIZE ];

    str_write("\r\nExample FreeRTOS Project\r\n");
     cfc:	4809      	ldr	r0, [pc, #36]	; (d24 <main+0x30>)
     cfe:	4b0a      	ldr	r3, [pc, #40]	; (d28 <main+0x34>)
     d00:	4798      	blx	r3

    ( void ) xTaskCreateStatic( exampleTask,
     d02:	4b0a      	ldr	r3, [pc, #40]	; (d2c <main+0x38>)
     d04:	9302      	str	r3, [sp, #8]
     d06:	3354      	adds	r3, #84	; 0x54
     d08:	9301      	str	r3, [sp, #4]
     d0a:	2304      	movs	r3, #4
     d0c:	9300      	str	r3, [sp, #0]
     d0e:	2300      	movs	r3, #0
     d10:	2240      	movs	r2, #64	; 0x40
     d12:	4907      	ldr	r1, [pc, #28]	; (d30 <main+0x3c>)
     d14:	4807      	ldr	r0, [pc, #28]	; (d34 <main+0x40>)
     d16:	4c08      	ldr	r4, [pc, #32]	; (d38 <main+0x44>)
     d18:	47a0      	blx	r4
                                configMAX_PRIORITIES - 1U,
                                &( exampleTaskStack[ 0 ] ),
                                &( exampleTaskTCB ) );

    /* Start the scheduler. */
    vTaskStartScheduler();
     d1a:	4b08      	ldr	r3, [pc, #32]	; (d3c <main+0x48>)
     d1c:	4798      	blx	r3
     d1e:	e7fe      	b.n	d1e <main+0x2a>
     d20:	000002d1 	.word	0x000002d1
     d24:	000031e0 	.word	0x000031e0
     d28:	00000cb9 	.word	0x00000cb9
     d2c:	2000002c 	.word	0x2000002c
     d30:	00003200 	.word	0x00003200
     d34:	00000cd9 	.word	0x00000cd9
     d38:	00002261 	.word	0x00002261
     d3c:	00002c11 	.word	0x00002c11

00000d40 <sem_init>:

/**
 * \brief Semaphore initialization
 */
int32_t sem_init(sem_t *sem, uint32_t count)
{
     d40:	b538      	push	{r3, r4, r5, lr}
     d42:	4605      	mov	r5, r0
     d44:	460c      	mov	r4, r1
	ASSERT(count <= SEMAPHORE_MAX_COUNT);
     d46:	222b      	movs	r2, #43	; 0x2b
     d48:	4908      	ldr	r1, [pc, #32]	; (d6c <sem_init+0x2c>)
     d4a:	2c01      	cmp	r4, #1
     d4c:	bf8c      	ite	hi
     d4e:	2000      	movhi	r0, #0
     d50:	2001      	movls	r0, #1
     d52:	4b07      	ldr	r3, [pc, #28]	; (d70 <sem_init+0x30>)
     d54:	4798      	blx	r3

	*sem = xSemaphoreCreateCounting((uint32_t)SEMAPHORE_MAX_COUNT, count);
     d56:	4621      	mov	r1, r4
     d58:	2001      	movs	r0, #1
     d5a:	4b06      	ldr	r3, [pc, #24]	; (d74 <sem_init+0x34>)
     d5c:	4798      	blx	r3
     d5e:	6028      	str	r0, [r5, #0]

	return *sem ? ERR_NONE : ERR_NOT_INITIALIZED;
     d60:	b108      	cbz	r0, d66 <sem_init+0x26>
     d62:	2000      	movs	r0, #0
     d64:	bd38      	pop	{r3, r4, r5, pc}
     d66:	f06f 0013 	mvn.w	r0, #19
}
     d6a:	bd38      	pop	{r3, r4, r5, pc}
     d6c:	00003208 	.word	0x00003208
     d70:	00000749 	.word	0x00000749
     d74:	000017f5 	.word	0x000017f5

00000d78 <sem_up>:

/**
 * \brief Semaphore up
 */
int32_t sem_up(sem_t *sem)
{
     d78:	b510      	push	{r4, lr}
 * \brief Check if it's in ISR handling
 * \return \c true if it's in ISR
 */
static inline bool _is_in_isr(void)
{
	return (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk);
     d7a:	4b0d      	ldr	r3, [pc, #52]	; (db0 <sem_up+0x38>)
     d7c:	685b      	ldr	r3, [r3, #4]
     d7e:	f3c3 0308 	ubfx	r3, r3, #0, #9
	return is_in_isr() ? (xSemaphoreGiveFromISR(*sem, pdFALSE) ? 0 : ERR_ABORTED)
	                   : (xSemaphoreGive(*sem) ? ERR_NONE : ERR_ABORTED);
     d82:	b133      	cbz	r3, d92 <sem_up+0x1a>
	return is_in_isr() ? (xSemaphoreGiveFromISR(*sem, pdFALSE) ? 0 : ERR_ABORTED)
     d84:	2100      	movs	r1, #0
     d86:	6800      	ldr	r0, [r0, #0]
     d88:	4b0a      	ldr	r3, [pc, #40]	; (db4 <sem_up+0x3c>)
     d8a:	4798      	blx	r3
	                   : (xSemaphoreGive(*sem) ? ERR_NONE : ERR_ABORTED);
     d8c:	b150      	cbz	r0, da4 <sem_up+0x2c>
     d8e:	2000      	movs	r0, #0
     d90:	bd10      	pop	{r4, pc}
     d92:	2300      	movs	r3, #0
     d94:	461a      	mov	r2, r3
     d96:	4619      	mov	r1, r3
     d98:	6800      	ldr	r0, [r0, #0]
     d9a:	4c07      	ldr	r4, [pc, #28]	; (db8 <sem_up+0x40>)
     d9c:	47a0      	blx	r4
     d9e:	b120      	cbz	r0, daa <sem_up+0x32>
     da0:	2000      	movs	r0, #0
     da2:	bd10      	pop	{r4, pc}
     da4:	f06f 0002 	mvn.w	r0, #2
     da8:	bd10      	pop	{r4, pc}
     daa:	f06f 0002 	mvn.w	r0, #2
}
     dae:	bd10      	pop	{r4, pc}
     db0:	e000ed00 	.word	0xe000ed00
     db4:	00001a0d 	.word	0x00001a0d
     db8:	00001829 	.word	0x00001829

00000dbc <sem_down>:

/**
 * \brief Semaphore down, may suspend the caller thread
 */
int32_t sem_down(sem_t *sem, uint32_t timeout)
{
     dbc:	b508      	push	{r3, lr}
	return xSemaphoreTake(*sem, timeout) ? ERR_NONE : ERR_TIMEOUT;
     dbe:	6800      	ldr	r0, [r0, #0]
     dc0:	4b03      	ldr	r3, [pc, #12]	; (dd0 <sem_down+0x14>)
     dc2:	4798      	blx	r3
     dc4:	b108      	cbz	r0, dca <sem_down+0xe>
     dc6:	2000      	movs	r0, #0
     dc8:	bd08      	pop	{r3, pc}
     dca:	f06f 0007 	mvn.w	r0, #7
}
     dce:	bd08      	pop	{r3, pc}
     dd0:	00001ca5 	.word	0x00001ca5

00000dd4 <sem_deinit>:
/**
 * \brief Semaphore deinitialization
 */
int32_t sem_deinit(sem_t *sem)
{
	if (*sem != NULL) {
     dd4:	6803      	ldr	r3, [r0, #0]
     dd6:	b143      	cbz	r3, dea <sem_deinit+0x16>
{
     dd8:	b510      	push	{r4, lr}
     dda:	4604      	mov	r4, r0
		vSemaphoreDelete(*sem);
     ddc:	4618      	mov	r0, r3
     dde:	4b04      	ldr	r3, [pc, #16]	; (df0 <sem_deinit+0x1c>)
     de0:	4798      	blx	r3
		*sem = NULL;
     de2:	2300      	movs	r3, #0
     de4:	6023      	str	r3, [r4, #0]
	}

	return ERR_NONE;
}
     de6:	2000      	movs	r0, #0
     de8:	bd10      	pop	{r4, pc}
     dea:	2000      	movs	r0, #0
     dec:	4770      	bx	lr
     dee:	bf00      	nop
     df0:	00001e71 	.word	0x00001e71

00000df4 <vListInitialise>:
    traceENTER_vListInitialise( pxList );

    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );
     df4:	f100 0308 	add.w	r3, r0, #8
     df8:	6043      	str	r3, [r0, #4]

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
     dfa:	f04f 32ff 	mov.w	r2, #4294967295
     dfe:	6082      	str	r2, [r0, #8]

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );
     e00:	60c3      	str	r3, [r0, #12]
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );
     e02:	6103      	str	r3, [r0, #16]
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     e04:	2300      	movs	r3, #0
     e06:	6003      	str	r3, [r0, #0]
     e08:	4770      	bx	lr

00000e0a <vListInitialiseItem>:
void vListInitialiseItem( ListItem_t * const pxItem )
{
    traceENTER_vListInitialiseItem( pxItem );

    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
     e0a:	2300      	movs	r3, #0
     e0c:	6103      	str	r3, [r0, #16]
     e0e:	4770      	bx	lr

00000e10 <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
     e10:	b430      	push	{r4, r5}
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     e12:	680d      	ldr	r5, [r1, #0]
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
     e14:	f1b5 3fff 	cmp.w	r5, #4294967295
     e18:	d002      	beq.n	e20 <vListInsert+0x10>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     e1a:	f100 0208 	add.w	r2, r0, #8
     e1e:	e002      	b.n	e26 <vListInsert+0x16>
        pxIterator = pxList->xListEnd.pxPrevious;
     e20:	6902      	ldr	r2, [r0, #16]
     e22:	e004      	b.n	e2e <vListInsert+0x1e>
        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     e24:	461a      	mov	r2, r3
     e26:	6853      	ldr	r3, [r2, #4]
     e28:	681c      	ldr	r4, [r3, #0]
     e2a:	42a5      	cmp	r5, r4
     e2c:	d2fa      	bcs.n	e24 <vListInsert+0x14>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
     e2e:	6853      	ldr	r3, [r2, #4]
     e30:	604b      	str	r3, [r1, #4]
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     e32:	6099      	str	r1, [r3, #8]
    pxNewListItem->pxPrevious = pxIterator;
     e34:	608a      	str	r2, [r1, #8]
    pxIterator->pxNext = pxNewListItem;
     e36:	6051      	str	r1, [r2, #4]

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
     e38:	6108      	str	r0, [r1, #16]

    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems + 1U );
     e3a:	6803      	ldr	r3, [r0, #0]
     e3c:	3301      	adds	r3, #1
     e3e:	6003      	str	r3, [r0, #0]

    traceRETURN_vListInsert();
}
     e40:	bc30      	pop	{r4, r5}
     e42:	4770      	bx	lr

00000e44 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    /* The list item knows which list it is in.  Obtain the list from the list
     * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
     e44:	6903      	ldr	r3, [r0, #16]

    traceENTER_uxListRemove( pxItemToRemove );

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     e46:	6842      	ldr	r2, [r0, #4]
     e48:	6881      	ldr	r1, [r0, #8]
     e4a:	6091      	str	r1, [r2, #8]
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     e4c:	6882      	ldr	r2, [r0, #8]
     e4e:	6841      	ldr	r1, [r0, #4]
     e50:	6051      	str	r1, [r2, #4]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
     e52:	685a      	ldr	r2, [r3, #4]
     e54:	4290      	cmp	r0, r2
     e56:	d005      	beq.n	e64 <uxListRemove+0x20>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
     e58:	2200      	movs	r2, #0
     e5a:	6102      	str	r2, [r0, #16]
    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems - 1U );
     e5c:	6818      	ldr	r0, [r3, #0]
     e5e:	3801      	subs	r0, #1
     e60:	6018      	str	r0, [r3, #0]

    traceRETURN_uxListRemove( pxList->uxNumberOfItems );

    return pxList->uxNumberOfItems;
}
     e62:	4770      	bx	lr
        pxList->pxIndex = pxItemToRemove->pxPrevious;
     e64:	6882      	ldr	r2, [r0, #8]
     e66:	605a      	str	r2, [r3, #4]
     e68:	e7f6      	b.n	e58 <uxListRemove+0x14>
	...

00000e6c <prvTaskExitError>:
    return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
     e6c:	b082      	sub	sp, #8
    volatile uint32_t ulDummy = 0;
     e6e:	2300      	movs	r3, #0
     e70:	9301      	str	r3, [sp, #4]
     * its caller as there is nothing to return to.  If a task wants to exit it
     * should instead call vTaskDelete( NULL ).
     *
     * Artificially force an assert() to be triggered if configASSERT() is
     * defined, then stop here so application writers can catch the error. */
    configASSERT( uxCriticalNesting == ~0UL );
     e72:	4b0d      	ldr	r3, [pc, #52]	; (ea8 <prvTaskExitError+0x3c>)
     e74:	681b      	ldr	r3, [r3, #0]
     e76:	f1b3 3fff 	cmp.w	r3, #4294967295
     e7a:	d008      	beq.n	e8e <prvTaskExitError+0x22>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
    uint32_t ulNewBASEPRI;

    __asm volatile
     e7c:	f04f 0380 	mov.w	r3, #128	; 0x80
     e80:	f383 8811 	msr	BASEPRI, r3
     e84:	f3bf 8f6f 	isb	sy
     e88:	f3bf 8f4f 	dsb	sy
     e8c:	e7fe      	b.n	e8c <prvTaskExitError+0x20>
     e8e:	f04f 0380 	mov.w	r3, #128	; 0x80
     e92:	f383 8811 	msr	BASEPRI, r3
     e96:	f3bf 8f6f 	isb	sy
     e9a:	f3bf 8f4f 	dsb	sy
    portDISABLE_INTERRUPTS();

    while( ulDummy == 0 )
     e9e:	9b01      	ldr	r3, [sp, #4]
     ea0:	2b00      	cmp	r3, #0
     ea2:	d0fc      	beq.n	e9e <prvTaskExitError+0x32>
         * about code appearing after this function is called - making ulDummy
         * volatile makes the compiler think the function could return and
         * therefore not output an 'unreachable code' warning for code that appears
         * after it. */
    }
}
     ea4:	b002      	add	sp, #8
     ea6:	4770      	bx	lr
     ea8:	20000000 	.word	0x20000000
     eac:	00000000 	.word	0x00000000

00000eb0 <SVCall_Handler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
    __asm volatile (
     eb0:	4b07      	ldr	r3, [pc, #28]	; (ed0 <pxCurrentTCBConst2>)
     eb2:	6819      	ldr	r1, [r3, #0]
     eb4:	6808      	ldr	r0, [r1, #0]
     eb6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     eba:	f380 8809 	msr	PSP, r0
     ebe:	f3bf 8f6f 	isb	sy
     ec2:	f04f 0000 	mov.w	r0, #0
     ec6:	f380 8811 	msr	BASEPRI, r0
     eca:	4770      	bx	lr
     ecc:	f3af 8000 	nop.w

00000ed0 <pxCurrentTCBConst2>:
     ed0:	20000bc0 	.word	0x20000bc0

00000ed4 <prvPortStartFirstTask>:
{
    /* Start the first task.  This also clears the bit that indicates the FPU is
     * in use in case the FPU was used before the scheduler was started - which
     * would otherwise result in the unnecessary leaving of space in the SVC stack
     * for lazy saving of FPU registers. */
    __asm volatile (
     ed4:	4808      	ldr	r0, [pc, #32]	; (ef8 <prvPortStartFirstTask+0x24>)
     ed6:	6800      	ldr	r0, [r0, #0]
     ed8:	6800      	ldr	r0, [r0, #0]
     eda:	f380 8808 	msr	MSP, r0
     ede:	f04f 0000 	mov.w	r0, #0
     ee2:	f380 8814 	msr	CONTROL, r0
     ee6:	b662      	cpsie	i
     ee8:	b661      	cpsie	f
     eea:	f3bf 8f4f 	dsb	sy
     eee:	f3bf 8f6f 	isb	sy
     ef2:	df00      	svc	0
     ef4:	bf00      	nop
     ef6:	0000      	.short	0x0000
     ef8:	e000ed08 	.word	0xe000ed08
     efc:	00000000 	.word	0x00000000

00000f00 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
    /* This is a naked function. */

    __asm volatile
     f00:	f3ef 8009 	mrs	r0, PSP
     f04:	f3bf 8f6f 	isb	sy
     f08:	4b15      	ldr	r3, [pc, #84]	; (f60 <pxCurrentTCBConst>)
     f0a:	681a      	ldr	r2, [r3, #0]
     f0c:	f01e 0f10 	tst.w	lr, #16
     f10:	bf08      	it	eq
     f12:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
     f16:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     f1a:	6010      	str	r0, [r2, #0]
     f1c:	e92d 0009 	stmdb	sp!, {r0, r3}
     f20:	f04f 0080 	mov.w	r0, #128	; 0x80
     f24:	f380 8811 	msr	BASEPRI, r0
     f28:	f3bf 8f4f 	dsb	sy
     f2c:	f3bf 8f6f 	isb	sy
     f30:	f001 fb74 	bl	261c <vTaskSwitchContext>
     f34:	f04f 0000 	mov.w	r0, #0
     f38:	f380 8811 	msr	BASEPRI, r0
     f3c:	bc09      	pop	{r0, r3}
     f3e:	6819      	ldr	r1, [r3, #0]
     f40:	6808      	ldr	r0, [r1, #0]
     f42:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     f46:	f01e 0f10 	tst.w	lr, #16
     f4a:	bf08      	it	eq
     f4c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
     f50:	f380 8809 	msr	PSP, r0
     f54:	f3bf 8f6f 	isb	sy
     f58:	4770      	bx	lr
     f5a:	bf00      	nop
     f5c:	f3af 8000 	nop.w

00000f60 <pxCurrentTCBConst>:
     f60:	20000bc0 	.word	0x20000bc0

00000f64 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
    __asm volatile
     f64:	f8df 000c 	ldr.w	r0, [pc, #12]	; f74 <vPortEnableVFP+0x10>
     f68:	6801      	ldr	r1, [r0, #0]
     f6a:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
     f6e:	6001      	str	r1, [r0, #0]
     f70:	4770      	bx	lr
     f72:	0000      	.short	0x0000
     f74:	e000ed88 	.word	0xe000ed88

00000f78 <pxPortInitialiseStack>:
    *pxTopOfStack = portINITIAL_XPSR;                                    /* xPSR */
     f78:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
     f7c:	f840 3c04 	str.w	r3, [r0, #-4]
    *pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK; /* PC */
     f80:	f021 0101 	bic.w	r1, r1, #1
     f84:	f840 1c08 	str.w	r1, [r0, #-8]
    *pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;             /* LR */
     f88:	4b05      	ldr	r3, [pc, #20]	; (fa0 <pxPortInitialiseStack+0x28>)
     f8a:	f840 3c0c 	str.w	r3, [r0, #-12]
    *pxTopOfStack = ( StackType_t ) pvParameters; /* R0 */
     f8e:	f840 2c20 	str.w	r2, [r0, #-32]
    *pxTopOfStack = portINITIAL_EXC_RETURN;
     f92:	f06f 0302 	mvn.w	r3, #2
     f96:	f840 3c24 	str.w	r3, [r0, #-36]
}
     f9a:	3844      	subs	r0, #68	; 0x44
     f9c:	4770      	bx	lr
     f9e:	bf00      	nop
     fa0:	00000e6d 	.word	0x00000e6d

00000fa4 <vPortEnterCritical>:
     fa4:	f04f 0380 	mov.w	r3, #128	; 0x80
     fa8:	f383 8811 	msr	BASEPRI, r3
     fac:	f3bf 8f6f 	isb	sy
     fb0:	f3bf 8f4f 	dsb	sy
    uxCriticalNesting++;
     fb4:	4a0a      	ldr	r2, [pc, #40]	; (fe0 <vPortEnterCritical+0x3c>)
     fb6:	6813      	ldr	r3, [r2, #0]
     fb8:	3301      	adds	r3, #1
     fba:	6013      	str	r3, [r2, #0]
    if( uxCriticalNesting == 1 )
     fbc:	2b01      	cmp	r3, #1
     fbe:	d10d      	bne.n	fdc <vPortEnterCritical+0x38>
        configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
     fc0:	4b08      	ldr	r3, [pc, #32]	; (fe4 <vPortEnterCritical+0x40>)
     fc2:	681b      	ldr	r3, [r3, #0]
     fc4:	f013 0fff 	tst.w	r3, #255	; 0xff
     fc8:	d008      	beq.n	fdc <vPortEnterCritical+0x38>
     fca:	f04f 0380 	mov.w	r3, #128	; 0x80
     fce:	f383 8811 	msr	BASEPRI, r3
     fd2:	f3bf 8f6f 	isb	sy
     fd6:	f3bf 8f4f 	dsb	sy
     fda:	e7fe      	b.n	fda <vPortEnterCritical+0x36>
     fdc:	4770      	bx	lr
     fde:	bf00      	nop
     fe0:	20000000 	.word	0x20000000
     fe4:	e000ed04 	.word	0xe000ed04

00000fe8 <vPortExitCritical>:
    configASSERT( uxCriticalNesting );
     fe8:	4b09      	ldr	r3, [pc, #36]	; (1010 <vPortExitCritical+0x28>)
     fea:	681b      	ldr	r3, [r3, #0]
     fec:	b943      	cbnz	r3, 1000 <vPortExitCritical+0x18>
     fee:	f04f 0380 	mov.w	r3, #128	; 0x80
     ff2:	f383 8811 	msr	BASEPRI, r3
     ff6:	f3bf 8f6f 	isb	sy
     ffa:	f3bf 8f4f 	dsb	sy
     ffe:	e7fe      	b.n	ffe <vPortExitCritical+0x16>
    uxCriticalNesting--;
    1000:	3b01      	subs	r3, #1
    1002:	4a03      	ldr	r2, [pc, #12]	; (1010 <vPortExitCritical+0x28>)
    1004:	6013      	str	r3, [r2, #0]
    if( uxCriticalNesting == 0 )
    1006:	b90b      	cbnz	r3, 100c <vPortExitCritical+0x24>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
    __asm volatile
    1008:	f383 8811 	msr	BASEPRI, r3
    100c:	4770      	bx	lr
    100e:	bf00      	nop
    1010:	20000000 	.word	0x20000000

00001014 <SysTick_Handler>:
{
    1014:	b508      	push	{r3, lr}
    __asm volatile
    1016:	f04f 0380 	mov.w	r3, #128	; 0x80
    101a:	f383 8811 	msr	BASEPRI, r3
    101e:	f3bf 8f6f 	isb	sy
    1022:	f3bf 8f4f 	dsb	sy
        if( xTaskIncrementTick() != pdFALSE )
    1026:	4b05      	ldr	r3, [pc, #20]	; (103c <SysTick_Handler+0x28>)
    1028:	4798      	blx	r3
    102a:	b118      	cbz	r0, 1034 <SysTick_Handler+0x20>
            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
    102c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    1030:	4b03      	ldr	r3, [pc, #12]	; (1040 <SysTick_Handler+0x2c>)
    1032:	601a      	str	r2, [r3, #0]
    __asm volatile
    1034:	2300      	movs	r3, #0
    1036:	f383 8811 	msr	BASEPRI, r3
    103a:	bd08      	pop	{r3, pc}
    103c:	000022c1 	.word	0x000022c1
    1040:	e000ed04 	.word	0xe000ed04

00001044 <vPortSetupTimerInterrupt>:
    portNVIC_SYSTICK_CTRL_REG = 0UL;
    1044:	4b05      	ldr	r3, [pc, #20]	; (105c <vPortSetupTimerInterrupt+0x18>)
    1046:	2200      	movs	r2, #0
    1048:	601a      	str	r2, [r3, #0]
    portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
    104a:	4905      	ldr	r1, [pc, #20]	; (1060 <vPortSetupTimerInterrupt+0x1c>)
    104c:	600a      	str	r2, [r1, #0]
    portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
    104e:	f642 61df 	movw	r1, #11999	; 0x2edf
    1052:	4a04      	ldr	r2, [pc, #16]	; (1064 <vPortSetupTimerInterrupt+0x20>)
    1054:	6011      	str	r1, [r2, #0]
    portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT_CONFIG | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
    1056:	2207      	movs	r2, #7
    1058:	601a      	str	r2, [r3, #0]
    105a:	4770      	bx	lr
    105c:	e000e010 	.word	0xe000e010
    1060:	e000e018 	.word	0xe000e018
    1064:	e000e014 	.word	0xe000e014

00001068 <xPortStartScheduler>:
    configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
    1068:	4b54      	ldr	r3, [pc, #336]	; (11bc <xPortStartScheduler+0x154>)
    106a:	681a      	ldr	r2, [r3, #0]
    106c:	4b54      	ldr	r3, [pc, #336]	; (11c0 <xPortStartScheduler+0x158>)
    106e:	429a      	cmp	r2, r3
    1070:	d108      	bne.n	1084 <xPortStartScheduler+0x1c>
    __asm volatile
    1072:	f04f 0380 	mov.w	r3, #128	; 0x80
    1076:	f383 8811 	msr	BASEPRI, r3
    107a:	f3bf 8f6f 	isb	sy
    107e:	f3bf 8f4f 	dsb	sy
    1082:	e7fe      	b.n	1082 <xPortStartScheduler+0x1a>
    configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
    1084:	4b4d      	ldr	r3, [pc, #308]	; (11bc <xPortStartScheduler+0x154>)
    1086:	681a      	ldr	r2, [r3, #0]
    1088:	4b4e      	ldr	r3, [pc, #312]	; (11c4 <xPortStartScheduler+0x15c>)
    108a:	429a      	cmp	r2, r3
    108c:	d108      	bne.n	10a0 <xPortStartScheduler+0x38>
    108e:	f04f 0380 	mov.w	r3, #128	; 0x80
    1092:	f383 8811 	msr	BASEPRI, r3
    1096:	f3bf 8f6f 	isb	sy
    109a:	f3bf 8f4f 	dsb	sy
    109e:	e7fe      	b.n	109e <xPortStartScheduler+0x36>
        const portISR_t * const pxVectorTable = portSCB_VTOR_REG;
    10a0:	4b49      	ldr	r3, [pc, #292]	; (11c8 <xPortStartScheduler+0x160>)
    10a2:	681b      	ldr	r3, [r3, #0]
        configASSERT( pxVectorTable[ portVECTOR_INDEX_SVC ] == vPortSVCHandler );
    10a4:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
    10a6:	4a49      	ldr	r2, [pc, #292]	; (11cc <xPortStartScheduler+0x164>)
    10a8:	4291      	cmp	r1, r2
    10aa:	d008      	beq.n	10be <xPortStartScheduler+0x56>
    10ac:	f04f 0380 	mov.w	r3, #128	; 0x80
    10b0:	f383 8811 	msr	BASEPRI, r3
    10b4:	f3bf 8f6f 	isb	sy
    10b8:	f3bf 8f4f 	dsb	sy
    10bc:	e7fe      	b.n	10bc <xPortStartScheduler+0x54>
        configASSERT( pxVectorTable[ portVECTOR_INDEX_PENDSV ] == xPortPendSVHandler );
    10be:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    10c0:	4b43      	ldr	r3, [pc, #268]	; (11d0 <xPortStartScheduler+0x168>)
    10c2:	429a      	cmp	r2, r3
    10c4:	d008      	beq.n	10d8 <xPortStartScheduler+0x70>
    10c6:	f04f 0380 	mov.w	r3, #128	; 0x80
    10ca:	f383 8811 	msr	BASEPRI, r3
    10ce:	f3bf 8f6f 	isb	sy
    10d2:	f3bf 8f4f 	dsb	sy
    10d6:	e7fe      	b.n	10d6 <xPortStartScheduler+0x6e>
{
    10d8:	b510      	push	{r4, lr}
    10da:	b082      	sub	sp, #8
        volatile uint32_t ulImplementedPrioBits = 0;
    10dc:	2300      	movs	r3, #0
    10de:	9301      	str	r3, [sp, #4]
        ucOriginalPriority = *pucFirstUserPriorityRegister;
    10e0:	4b3c      	ldr	r3, [pc, #240]	; (11d4 <xPortStartScheduler+0x16c>)
    10e2:	781a      	ldrb	r2, [r3, #0]
    10e4:	b2d2      	uxtb	r2, r2
    10e6:	f88d 2002 	strb.w	r2, [sp, #2]
        *pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
    10ea:	22ff      	movs	r2, #255	; 0xff
    10ec:	701a      	strb	r2, [r3, #0]
        ucMaxPriorityValue = *pucFirstUserPriorityRegister;
    10ee:	781b      	ldrb	r3, [r3, #0]
    10f0:	b2db      	uxtb	r3, r3
    10f2:	f88d 3003 	strb.w	r3, [sp, #3]
        ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    10f6:	f89d 3003 	ldrb.w	r3, [sp, #3]
    10fa:	f003 0380 	and.w	r3, r3, #128	; 0x80
    10fe:	4a36      	ldr	r2, [pc, #216]	; (11d8 <xPortStartScheduler+0x170>)
    1100:	7013      	strb	r3, [r2, #0]
        configASSERT( ucMaxSysCallPriority );
    1102:	b943      	cbnz	r3, 1116 <xPortStartScheduler+0xae>
    1104:	f04f 0380 	mov.w	r3, #128	; 0x80
    1108:	f383 8811 	msr	BASEPRI, r3
    110c:	f3bf 8f6f 	isb	sy
    1110:	f3bf 8f4f 	dsb	sy
    1114:	e7fe      	b.n	1114 <xPortStartScheduler+0xac>
        configASSERT( ( configMAX_SYSCALL_INTERRUPT_PRIORITY & ( ~ucMaxPriorityValue ) ) == 0U );
    1116:	f89d 3003 	ldrb.w	r3, [sp, #3]
    111a:	09db      	lsrs	r3, r3, #7
    111c:	d111      	bne.n	1142 <xPortStartScheduler+0xda>
    111e:	f04f 0380 	mov.w	r3, #128	; 0x80
    1122:	f383 8811 	msr	BASEPRI, r3
    1126:	f3bf 8f6f 	isb	sy
    112a:	f3bf 8f4f 	dsb	sy
    112e:	e7fe      	b.n	112e <xPortStartScheduler+0xc6>
            ulImplementedPrioBits++;
    1130:	9b01      	ldr	r3, [sp, #4]
    1132:	3301      	adds	r3, #1
    1134:	9301      	str	r3, [sp, #4]
            ucMaxPriorityValue <<= ( uint8_t ) 0x01;
    1136:	f89d 3003 	ldrb.w	r3, [sp, #3]
    113a:	005b      	lsls	r3, r3, #1
    113c:	b2db      	uxtb	r3, r3
    113e:	f88d 3003 	strb.w	r3, [sp, #3]
        while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
    1142:	f89d 3003 	ldrb.w	r3, [sp, #3]
    1146:	f013 0f80 	tst.w	r3, #128	; 0x80
    114a:	d1f1      	bne.n	1130 <xPortStartScheduler+0xc8>
        if( ulImplementedPrioBits == 8 )
    114c:	9b01      	ldr	r3, [sp, #4]
    114e:	2b08      	cmp	r3, #8
    1150:	d12d      	bne.n	11ae <xPortStartScheduler+0x146>
            ulMaxPRIGROUPValue = 0;
    1152:	2200      	movs	r2, #0
    1154:	4b20      	ldr	r3, [pc, #128]	; (11d8 <xPortStartScheduler+0x170>)
    1156:	605a      	str	r2, [r3, #4]
        ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
    1158:	4a1f      	ldr	r2, [pc, #124]	; (11d8 <xPortStartScheduler+0x170>)
    115a:	6853      	ldr	r3, [r2, #4]
    115c:	021b      	lsls	r3, r3, #8
        ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
    115e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    1162:	6053      	str	r3, [r2, #4]
        *pucFirstUserPriorityRegister = ucOriginalPriority;
    1164:	f89d 3002 	ldrb.w	r3, [sp, #2]
    1168:	b2db      	uxtb	r3, r3
    116a:	4a1a      	ldr	r2, [pc, #104]	; (11d4 <xPortStartScheduler+0x16c>)
    116c:	7013      	strb	r3, [r2, #0]
    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
    116e:	4b1b      	ldr	r3, [pc, #108]	; (11dc <xPortStartScheduler+0x174>)
    1170:	681a      	ldr	r2, [r3, #0]
    1172:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
    1176:	601a      	str	r2, [r3, #0]
    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
    1178:	681a      	ldr	r2, [r3, #0]
    117a:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
    117e:	601a      	str	r2, [r3, #0]
    portNVIC_SHPR2_REG = 0;
    1180:	2400      	movs	r4, #0
    1182:	3b04      	subs	r3, #4
    1184:	601c      	str	r4, [r3, #0]
    vPortSetupTimerInterrupt();
    1186:	4b16      	ldr	r3, [pc, #88]	; (11e0 <xPortStartScheduler+0x178>)
    1188:	4798      	blx	r3
    uxCriticalNesting = 0;
    118a:	4b16      	ldr	r3, [pc, #88]	; (11e4 <xPortStartScheduler+0x17c>)
    118c:	601c      	str	r4, [r3, #0]
    vPortEnableVFP();
    118e:	4b16      	ldr	r3, [pc, #88]	; (11e8 <xPortStartScheduler+0x180>)
    1190:	4798      	blx	r3
    *( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
    1192:	4a16      	ldr	r2, [pc, #88]	; (11ec <xPortStartScheduler+0x184>)
    1194:	6813      	ldr	r3, [r2, #0]
    1196:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
    119a:	6013      	str	r3, [r2, #0]
    prvPortStartFirstTask();
    119c:	4b14      	ldr	r3, [pc, #80]	; (11f0 <xPortStartScheduler+0x188>)
    119e:	4798      	blx	r3
    vTaskSwitchContext();
    11a0:	4b14      	ldr	r3, [pc, #80]	; (11f4 <xPortStartScheduler+0x18c>)
    11a2:	4798      	blx	r3
    prvTaskExitError();
    11a4:	4b14      	ldr	r3, [pc, #80]	; (11f8 <xPortStartScheduler+0x190>)
    11a6:	4798      	blx	r3
}
    11a8:	4620      	mov	r0, r4
    11aa:	b002      	add	sp, #8
    11ac:	bd10      	pop	{r4, pc}
            ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS - ulImplementedPrioBits;
    11ae:	9b01      	ldr	r3, [sp, #4]
    11b0:	f1c3 0307 	rsb	r3, r3, #7
    11b4:	4a08      	ldr	r2, [pc, #32]	; (11d8 <xPortStartScheduler+0x170>)
    11b6:	6053      	str	r3, [r2, #4]
    11b8:	e7ce      	b.n	1158 <xPortStartScheduler+0xf0>
    11ba:	bf00      	nop
    11bc:	e000ed00 	.word	0xe000ed00
    11c0:	410fc271 	.word	0x410fc271
    11c4:	410fc270 	.word	0x410fc270
    11c8:	e000ed08 	.word	0xe000ed08
    11cc:	00000eb1 	.word	0x00000eb1
    11d0:	00000f01 	.word	0x00000f01
    11d4:	e000e400 	.word	0xe000e400
    11d8:	20000180 	.word	0x20000180
    11dc:	e000ed20 	.word	0xe000ed20
    11e0:	00001045 	.word	0x00001045
    11e4:	20000000 	.word	0x20000000
    11e8:	00000f65 	.word	0x00000f65
    11ec:	e000ef34 	.word	0xe000ef34
    11f0:	00000ed5 	.word	0x00000ed5
    11f4:	0000261d 	.word	0x0000261d
    11f8:	00000e6d 	.word	0x00000e6d

000011fc <vPortValidateInterruptPriority>:
    {
        uint32_t ulCurrentInterrupt;
        uint8_t ucCurrentPriority;

        /* Obtain the number of the currently executing interrupt. */
        __asm volatile ( "mrs %0, ipsr" : "=r" ( ulCurrentInterrupt )::"memory" );
    11fc:	f3ef 8305 	mrs	r3, IPSR

        /* Is the interrupt number a user defined interrupt? */
        if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
    1200:	2b0f      	cmp	r3, #15
    1202:	d90f      	bls.n	1224 <vPortValidateInterruptPriority+0x28>
        {
            /* Look up the interrupt's priority. */
            ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
    1204:	4a10      	ldr	r2, [pc, #64]	; (1248 <vPortValidateInterruptPriority+0x4c>)
    1206:	5c9b      	ldrb	r3, [r3, r2]
    1208:	b2db      	uxtb	r3, r3
             * interrupt entry is as fast and simple as possible.
             *
             * The following links provide detailed information:
             * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html
             * https://www.FreeRTOS.org/FAQHelp.html */
            configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
    120a:	4a10      	ldr	r2, [pc, #64]	; (124c <vPortValidateInterruptPriority+0x50>)
    120c:	7812      	ldrb	r2, [r2, #0]
    120e:	4293      	cmp	r3, r2
    1210:	d208      	bcs.n	1224 <vPortValidateInterruptPriority+0x28>
    1212:	f04f 0380 	mov.w	r3, #128	; 0x80
    1216:	f383 8811 	msr	BASEPRI, r3
    121a:	f3bf 8f6f 	isb	sy
    121e:	f3bf 8f4f 	dsb	sy
    1222:	e7fe      	b.n	1222 <vPortValidateInterruptPriority+0x26>
         * configuration then the correct setting can be achieved on all Cortex-M
         * devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
         * scheduler.  Note however that some vendor specific peripheral libraries
         * assume a non-zero priority group setting, in which cases using a value
         * of zero will result in unpredictable behaviour. */
        configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
    1224:	4b0a      	ldr	r3, [pc, #40]	; (1250 <vPortValidateInterruptPriority+0x54>)
    1226:	681b      	ldr	r3, [r3, #0]
    1228:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    122c:	4a07      	ldr	r2, [pc, #28]	; (124c <vPortValidateInterruptPriority+0x50>)
    122e:	6852      	ldr	r2, [r2, #4]
    1230:	4293      	cmp	r3, r2
    1232:	d908      	bls.n	1246 <vPortValidateInterruptPriority+0x4a>
    1234:	f04f 0380 	mov.w	r3, #128	; 0x80
    1238:	f383 8811 	msr	BASEPRI, r3
    123c:	f3bf 8f6f 	isb	sy
    1240:	f3bf 8f4f 	dsb	sy
    1244:	e7fe      	b.n	1244 <vPortValidateInterruptPriority+0x48>
    1246:	4770      	bx	lr
    1248:	e000e3f0 	.word	0xe000e3f0
    124c:	20000180 	.word	0x20000180
    1250:	e000ed0c 	.word	0xe000ed0c

00001254 <prvHeapInit>:
{
    BlockLink_t * pxFirstFreeBlock;
    uint8_t * pucAlignedHeap;

    /* Ensure the heap starts on a correctly aligned boundary. */
    pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1254:	4b09      	ldr	r3, [pc, #36]	; (127c <prvHeapInit+0x28>)
    1256:	1dda      	adds	r2, r3, #7
    1258:	f022 0207 	bic.w	r2, r2, #7

    /* xStart is used to hold a pointer to the first item in the list of free
     * blocks.  The void cast is used to prevent compiler warnings. */
    xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    125c:	f8c3 2960 	str.w	r2, [r3, #2400]	; 0x960
    xStart.xBlockSize = ( size_t ) 0;
    1260:	2000      	movs	r0, #0
    1262:	f8c3 0964 	str.w	r0, [r3, #2404]	; 0x964

    /* xEnd is used to mark the end of the list of free blocks. */
    xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
    1266:	f640 1158 	movw	r1, #2392	; 0x958
    126a:	f8c3 196c 	str.w	r1, [r3, #2412]	; 0x96c
    xEnd.pxNextFreeBlock = NULL;
    126e:	f8c3 0968 	str.w	r0, [r3, #2408]	; 0x968

    /* To start with there is a single free block that is sized to take up the
     * entire heap space. */
    pxFirstFreeBlock = ( BlockLink_t * ) pucAlignedHeap;
    pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
    1272:	6051      	str	r1, [r2, #4]
    pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
    1274:	f603 1368 	addw	r3, r3, #2408	; 0x968
    1278:	6013      	str	r3, [r2, #0]
    127a:	4770      	bx	lr
    127c:	20000188 	.word	0x20000188

00001280 <pvPortMalloc>:
{
    1280:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if( xWantedSize > 0 )
    1282:	4604      	mov	r4, r0
    1284:	b170      	cbz	r0, 12a4 <pvPortMalloc+0x24>
        if( heapADD_WILL_OVERFLOW( xWantedSize, xHeapStructSize ) == 0 )
    1286:	f110 0f09 	cmn.w	r0, #9
    128a:	d80a      	bhi.n	12a2 <pvPortMalloc+0x22>
            xWantedSize += xHeapStructSize;
    128c:	3408      	adds	r4, #8
            if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
    128e:	f014 0307 	ands.w	r3, r4, #7
    1292:	d007      	beq.n	12a4 <pvPortMalloc+0x24>
                xAdditionalRequiredSize = portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK );
    1294:	f1c3 0308 	rsb	r3, r3, #8
                if( heapADD_WILL_OVERFLOW( xWantedSize, xAdditionalRequiredSize ) == 0 )
    1298:	43da      	mvns	r2, r3
    129a:	4294      	cmp	r4, r2
    129c:	d816      	bhi.n	12cc <pvPortMalloc+0x4c>
                    xWantedSize += xAdditionalRequiredSize;
    129e:	441c      	add	r4, r3
    12a0:	e000      	b.n	12a4 <pvPortMalloc+0x24>
            xWantedSize = 0;
    12a2:	2400      	movs	r4, #0
    vTaskSuspendAll();
    12a4:	4b28      	ldr	r3, [pc, #160]	; (1348 <pvPortMalloc+0xc8>)
    12a6:	4798      	blx	r3
        if( xHeapHasBeenInitialised == pdFALSE )
    12a8:	4b28      	ldr	r3, [pc, #160]	; (134c <pvPortMalloc+0xcc>)
    12aa:	f8d3 3970 	ldr.w	r3, [r3, #2416]	; 0x970
    12ae:	b17b      	cbz	r3, 12d0 <pvPortMalloc+0x50>
        if( heapBLOCK_SIZE_IS_VALID( xWantedSize ) != 0 )
    12b0:	2c00      	cmp	r4, #0
    12b2:	db41      	blt.n	1338 <pvPortMalloc+0xb8>
            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    12b4:	2c00      	cmp	r4, #0
    12b6:	d041      	beq.n	133c <pvPortMalloc+0xbc>
    12b8:	4b25      	ldr	r3, [pc, #148]	; (1350 <pvPortMalloc+0xd0>)
    12ba:	681e      	ldr	r6, [r3, #0]
    12bc:	42b4      	cmp	r4, r6
    12be:	d83f      	bhi.n	1340 <pvPortMalloc+0xc0>
                pxBlock = xStart.pxNextFreeBlock;
    12c0:	4922      	ldr	r1, [pc, #136]	; (134c <pvPortMalloc+0xcc>)
    12c2:	f8d1 3960 	ldr.w	r3, [r1, #2400]	; 0x960
                pxPreviousBlock = &xStart;
    12c6:	f501 6116 	add.w	r1, r1, #2400	; 0x960
                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    12ca:	e00a      	b.n	12e2 <pvPortMalloc+0x62>
                    xWantedSize = 0;
    12cc:	2400      	movs	r4, #0
    12ce:	e7e9      	b.n	12a4 <pvPortMalloc+0x24>
            prvHeapInit();
    12d0:	4b20      	ldr	r3, [pc, #128]	; (1354 <pvPortMalloc+0xd4>)
    12d2:	4798      	blx	r3
            xHeapHasBeenInitialised = pdTRUE;
    12d4:	2201      	movs	r2, #1
    12d6:	4b1d      	ldr	r3, [pc, #116]	; (134c <pvPortMalloc+0xcc>)
    12d8:	f8c3 2970 	str.w	r2, [r3, #2416]	; 0x970
    12dc:	e7e8      	b.n	12b0 <pvPortMalloc+0x30>
                    pxPreviousBlock = pxBlock;
    12de:	4619      	mov	r1, r3
                    pxBlock = pxBlock->pxNextFreeBlock;
    12e0:	4613      	mov	r3, r2
                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    12e2:	685a      	ldr	r2, [r3, #4]
    12e4:	4294      	cmp	r4, r2
    12e6:	d902      	bls.n	12ee <pvPortMalloc+0x6e>
    12e8:	681a      	ldr	r2, [r3, #0]
    12ea:	2a00      	cmp	r2, #0
    12ec:	d1f7      	bne.n	12de <pvPortMalloc+0x5e>
                if( pxBlock != &xEnd )
    12ee:	4a1a      	ldr	r2, [pc, #104]	; (1358 <pvPortMalloc+0xd8>)
    12f0:	4293      	cmp	r3, r2
    12f2:	d027      	beq.n	1344 <pvPortMalloc+0xc4>
                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    12f4:	680d      	ldr	r5, [r1, #0]
    12f6:	3508      	adds	r5, #8
                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    12f8:	681a      	ldr	r2, [r3, #0]
    12fa:	600a      	str	r2, [r1, #0]
                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    12fc:	685a      	ldr	r2, [r3, #4]
    12fe:	1b12      	subs	r2, r2, r4
    1300:	2a10      	cmp	r2, #16
    1302:	d90c      	bls.n	131e <pvPortMalloc+0x9e>
                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    1304:	191f      	adds	r7, r3, r4
                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1306:	607a      	str	r2, [r7, #4]
                        pxBlock->xBlockSize = xWantedSize;
    1308:	605c      	str	r4, [r3, #4]
                        prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    130a:	687c      	ldr	r4, [r7, #4]
    130c:	4913      	ldr	r1, [pc, #76]	; (135c <pvPortMalloc+0xdc>)
    130e:	e000      	b.n	1312 <pvPortMalloc+0x92>
    1310:	4611      	mov	r1, r2
    1312:	680a      	ldr	r2, [r1, #0]
    1314:	6850      	ldr	r0, [r2, #4]
    1316:	4284      	cmp	r4, r0
    1318:	d8fa      	bhi.n	1310 <pvPortMalloc+0x90>
    131a:	603a      	str	r2, [r7, #0]
    131c:	600f      	str	r7, [r1, #0]
                    xFreeBytesRemaining -= pxBlock->xBlockSize;
    131e:	685a      	ldr	r2, [r3, #4]
    1320:	1ab6      	subs	r6, r6, r2
    1322:	490b      	ldr	r1, [pc, #44]	; (1350 <pvPortMalloc+0xd0>)
    1324:	600e      	str	r6, [r1, #0]
                    heapALLOCATE_BLOCK( pxBlock );
    1326:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    132a:	605a      	str	r2, [r3, #4]
                    pxBlock->pxNextFreeBlock = NULL;
    132c:	2200      	movs	r2, #0
    132e:	601a      	str	r2, [r3, #0]
    ( void ) xTaskResumeAll();
    1330:	4b0b      	ldr	r3, [pc, #44]	; (1360 <pvPortMalloc+0xe0>)
    1332:	4798      	blx	r3
}
    1334:	4628      	mov	r0, r5
    1336:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    void * pvReturn = NULL;
    1338:	2500      	movs	r5, #0
    133a:	e7f9      	b.n	1330 <pvPortMalloc+0xb0>
    133c:	2500      	movs	r5, #0
    133e:	e7f7      	b.n	1330 <pvPortMalloc+0xb0>
    1340:	2500      	movs	r5, #0
    1342:	e7f5      	b.n	1330 <pvPortMalloc+0xb0>
    1344:	2500      	movs	r5, #0
    1346:	e7f3      	b.n	1330 <pvPortMalloc+0xb0>
    1348:	00002295 	.word	0x00002295
    134c:	20000188 	.word	0x20000188
    1350:	20000004 	.word	0x20000004
    1354:	00001255 	.word	0x00001255
    1358:	20000af0 	.word	0x20000af0
    135c:	20000ae8 	.word	0x20000ae8
    1360:	00002445 	.word	0x00002445

00001364 <vPortFree>:
    if( pv != NULL )
    1364:	2800      	cmp	r0, #0
    1366:	d037      	beq.n	13d8 <vPortFree+0x74>
{
    1368:	b538      	push	{r3, r4, r5, lr}
    136a:	4604      	mov	r4, r0
        puc -= xHeapStructSize;
    136c:	f1a0 0508 	sub.w	r5, r0, #8
        configASSERT( heapBLOCK_IS_ALLOCATED( pxLink ) != 0 );
    1370:	f850 3c04 	ldr.w	r3, [r0, #-4]
    1374:	2b00      	cmp	r3, #0
    1376:	db08      	blt.n	138a <vPortFree+0x26>
    1378:	f04f 0380 	mov.w	r3, #128	; 0x80
    137c:	f383 8811 	msr	BASEPRI, r3
    1380:	f3bf 8f6f 	isb	sy
    1384:	f3bf 8f4f 	dsb	sy
    1388:	e7fe      	b.n	1388 <vPortFree+0x24>
        configASSERT( pxLink->pxNextFreeBlock == NULL );
    138a:	f850 2c08 	ldr.w	r2, [r0, #-8]
    138e:	b142      	cbz	r2, 13a2 <vPortFree+0x3e>
    1390:	f04f 0380 	mov.w	r3, #128	; 0x80
    1394:	f383 8811 	msr	BASEPRI, r3
    1398:	f3bf 8f6f 	isb	sy
    139c:	f3bf 8f4f 	dsb	sy
    13a0:	e7fe      	b.n	13a0 <vPortFree+0x3c>
                heapFREE_BLOCK( pxLink );
    13a2:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    13a6:	f840 3c04 	str.w	r3, [r0, #-4]
                vTaskSuspendAll();
    13aa:	4b0c      	ldr	r3, [pc, #48]	; (13dc <vPortFree+0x78>)
    13ac:	4798      	blx	r3
                    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    13ae:	f854 1c04 	ldr.w	r1, [r4, #-4]
    13b2:	4b0b      	ldr	r3, [pc, #44]	; (13e0 <vPortFree+0x7c>)
    13b4:	681a      	ldr	r2, [r3, #0]
    13b6:	6850      	ldr	r0, [r2, #4]
    13b8:	4281      	cmp	r1, r0
    13ba:	d80b      	bhi.n	13d4 <vPortFree+0x70>
    13bc:	f844 2c08 	str.w	r2, [r4, #-8]
    13c0:	601d      	str	r5, [r3, #0]
                    xFreeBytesRemaining += pxLink->xBlockSize;
    13c2:	f854 1c04 	ldr.w	r1, [r4, #-4]
    13c6:	4a07      	ldr	r2, [pc, #28]	; (13e4 <vPortFree+0x80>)
    13c8:	6813      	ldr	r3, [r2, #0]
    13ca:	440b      	add	r3, r1
    13cc:	6013      	str	r3, [r2, #0]
                ( void ) xTaskResumeAll();
    13ce:	4b06      	ldr	r3, [pc, #24]	; (13e8 <vPortFree+0x84>)
    13d0:	4798      	blx	r3
    13d2:	bd38      	pop	{r3, r4, r5, pc}
                    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    13d4:	4613      	mov	r3, r2
    13d6:	e7ed      	b.n	13b4 <vPortFree+0x50>
    13d8:	4770      	bx	lr
    13da:	bf00      	nop
    13dc:	00002295 	.word	0x00002295
    13e0:	20000ae8 	.word	0x20000ae8
    13e4:	20000004 	.word	0x20000004
    13e8:	00002445 	.word	0x00002445

000013ec <prvGetDisinheritPriorityAfterTimeout>:
         * priority, but the waiting task times out, then the holder should
         * disinherit the priority - but only down to the highest priority of any
         * other tasks that are waiting for the same mutex.  For this purpose,
         * return the priority of the highest priority task that is waiting for the
         * mutex. */
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
    13ec:	6a43      	ldr	r3, [r0, #36]	; 0x24
    13ee:	b123      	cbz	r3, 13fa <prvGetDisinheritPriorityAfterTimeout+0xe>
        {
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) ( ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) ) );
    13f0:	6b03      	ldr	r3, [r0, #48]	; 0x30
    13f2:	6818      	ldr	r0, [r3, #0]
    13f4:	f1c0 0005 	rsb	r0, r0, #5
    13f8:	4770      	bx	lr
        }
        else
        {
            uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    13fa:	2000      	movs	r0, #0
        }

        return uxHighestPriorityOfWaitingTasks;
    }
    13fc:	4770      	bx	lr
	...

00001400 <prvIsQueueFull>:
    return xReturn;
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    1400:	b510      	push	{r4, lr}
    1402:	4604      	mov	r4, r0
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    1404:	4b06      	ldr	r3, [pc, #24]	; (1420 <prvIsQueueFull+0x20>)
    1406:	4798      	blx	r3
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1408:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    140a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    140c:	429a      	cmp	r2, r3
    140e:	d004      	beq.n	141a <prvIsQueueFull+0x1a>
        {
            xReturn = pdTRUE;
        }
        else
        {
            xReturn = pdFALSE;
    1410:	2400      	movs	r4, #0
        }
    }
    taskEXIT_CRITICAL();
    1412:	4b04      	ldr	r3, [pc, #16]	; (1424 <prvIsQueueFull+0x24>)
    1414:	4798      	blx	r3

    return xReturn;
}
    1416:	4620      	mov	r0, r4
    1418:	bd10      	pop	{r4, pc}
            xReturn = pdTRUE;
    141a:	2401      	movs	r4, #1
    141c:	e7f9      	b.n	1412 <prvIsQueueFull+0x12>
    141e:	bf00      	nop
    1420:	00000fa5 	.word	0x00000fa5
    1424:	00000fe9 	.word	0x00000fe9

00001428 <prvIsQueueEmpty>:
{
    1428:	b510      	push	{r4, lr}
    142a:	4604      	mov	r4, r0
    taskENTER_CRITICAL();
    142c:	4b05      	ldr	r3, [pc, #20]	; (1444 <prvIsQueueEmpty+0x1c>)
    142e:	4798      	blx	r3
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1430:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    1432:	b123      	cbz	r3, 143e <prvIsQueueEmpty+0x16>
            xReturn = pdFALSE;
    1434:	2400      	movs	r4, #0
    taskEXIT_CRITICAL();
    1436:	4b04      	ldr	r3, [pc, #16]	; (1448 <prvIsQueueEmpty+0x20>)
    1438:	4798      	blx	r3
}
    143a:	4620      	mov	r0, r4
    143c:	bd10      	pop	{r4, pc}
            xReturn = pdTRUE;
    143e:	2401      	movs	r4, #1
    1440:	e7f9      	b.n	1436 <prvIsQueueEmpty+0xe>
    1442:	bf00      	nop
    1444:	00000fa5 	.word	0x00000fa5
    1448:	00000fe9 	.word	0x00000fe9

0000144c <prvCopyDataToQueue>:
{
    144c:	b570      	push	{r4, r5, r6, lr}
    144e:	4604      	mov	r4, r0
    1450:	4616      	mov	r6, r2
    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1452:	6b85      	ldr	r5, [r0, #56]	; 0x38
    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1454:	6c02      	ldr	r2, [r0, #64]	; 0x40
    1456:	b952      	cbnz	r2, 146e <prvCopyDataToQueue+0x22>
            if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1458:	6803      	ldr	r3, [r0, #0]
    145a:	2b00      	cmp	r3, #0
    145c:	d12a      	bne.n	14b4 <prvCopyDataToQueue+0x68>
                xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
    145e:	6880      	ldr	r0, [r0, #8]
    1460:	4b18      	ldr	r3, [pc, #96]	; (14c4 <prvCopyDataToQueue+0x78>)
    1462:	4798      	blx	r3
                pxQueue->u.xSemaphore.xMutexHolder = NULL;
    1464:	2300      	movs	r3, #0
    1466:	60a3      	str	r3, [r4, #8]
    pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting + ( UBaseType_t ) 1 );
    1468:	3501      	adds	r5, #1
    146a:	63a5      	str	r5, [r4, #56]	; 0x38
}
    146c:	bd70      	pop	{r4, r5, r6, pc}
    else if( xPosition == queueSEND_TO_BACK )
    146e:	b96e      	cbnz	r6, 148c <prvCopyDataToQueue+0x40>
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize );
    1470:	6840      	ldr	r0, [r0, #4]
    1472:	4b15      	ldr	r3, [pc, #84]	; (14c8 <prvCopyDataToQueue+0x7c>)
    1474:	4798      	blx	r3
        pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1476:	6c22      	ldr	r2, [r4, #64]	; 0x40
    1478:	6863      	ldr	r3, [r4, #4]
    147a:	4413      	add	r3, r2
    147c:	6063      	str	r3, [r4, #4]
        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )
    147e:	68a2      	ldr	r2, [r4, #8]
    1480:	4293      	cmp	r3, r2
    1482:	d319      	bcc.n	14b8 <prvCopyDataToQueue+0x6c>
            pxQueue->pcWriteTo = pxQueue->pcHead;
    1484:	6823      	ldr	r3, [r4, #0]
    1486:	6063      	str	r3, [r4, #4]
    BaseType_t xReturn = pdFALSE;
    1488:	2000      	movs	r0, #0
    148a:	e7ed      	b.n	1468 <prvCopyDataToQueue+0x1c>
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize );
    148c:	68c0      	ldr	r0, [r0, #12]
    148e:	4b0e      	ldr	r3, [pc, #56]	; (14c8 <prvCopyDataToQueue+0x7c>)
    1490:	4798      	blx	r3
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    1492:	6c23      	ldr	r3, [r4, #64]	; 0x40
    1494:	425b      	negs	r3, r3
    1496:	68e2      	ldr	r2, [r4, #12]
    1498:	441a      	add	r2, r3
    149a:	60e2      	str	r2, [r4, #12]
        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead )
    149c:	6821      	ldr	r1, [r4, #0]
    149e:	428a      	cmp	r2, r1
    14a0:	d202      	bcs.n	14a8 <prvCopyDataToQueue+0x5c>
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    14a2:	68a2      	ldr	r2, [r4, #8]
    14a4:	4413      	add	r3, r2
    14a6:	60e3      	str	r3, [r4, #12]
        if( xPosition == queueOVERWRITE )
    14a8:	2e02      	cmp	r6, #2
    14aa:	d107      	bne.n	14bc <prvCopyDataToQueue+0x70>
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    14ac:	b145      	cbz	r5, 14c0 <prvCopyDataToQueue+0x74>
                --uxMessagesWaiting;
    14ae:	3d01      	subs	r5, #1
    BaseType_t xReturn = pdFALSE;
    14b0:	2000      	movs	r0, #0
    14b2:	e7d9      	b.n	1468 <prvCopyDataToQueue+0x1c>
    14b4:	2000      	movs	r0, #0
    14b6:	e7d7      	b.n	1468 <prvCopyDataToQueue+0x1c>
    14b8:	2000      	movs	r0, #0
    14ba:	e7d5      	b.n	1468 <prvCopyDataToQueue+0x1c>
    14bc:	2000      	movs	r0, #0
    14be:	e7d3      	b.n	1468 <prvCopyDataToQueue+0x1c>
    14c0:	2000      	movs	r0, #0
    14c2:	e7d1      	b.n	1468 <prvCopyDataToQueue+0x1c>
    14c4:	000029e9 	.word	0x000029e9
    14c8:	000030b5 	.word	0x000030b5

000014cc <prvCopyDataFromQueue>:
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    14cc:	6c02      	ldr	r2, [r0, #64]	; 0x40
    14ce:	b172      	cbz	r2, 14ee <prvCopyDataFromQueue+0x22>
{
    14d0:	b510      	push	{r4, lr}
    14d2:	4603      	mov	r3, r0
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    14d4:	68c4      	ldr	r4, [r0, #12]
    14d6:	4414      	add	r4, r2
    14d8:	60c4      	str	r4, [r0, #12]
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    14da:	6880      	ldr	r0, [r0, #8]
    14dc:	4284      	cmp	r4, r0
    14de:	d301      	bcc.n	14e4 <prvCopyDataFromQueue+0x18>
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    14e0:	6818      	ldr	r0, [r3, #0]
    14e2:	60d8      	str	r0, [r3, #12]
    14e4:	4608      	mov	r0, r1
        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize );
    14e6:	68d9      	ldr	r1, [r3, #12]
    14e8:	4b01      	ldr	r3, [pc, #4]	; (14f0 <prvCopyDataFromQueue+0x24>)
    14ea:	4798      	blx	r3
    14ec:	bd10      	pop	{r4, pc}
    14ee:	4770      	bx	lr
    14f0:	000030b5 	.word	0x000030b5

000014f4 <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

    static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue )
    {
    14f4:	b570      	push	{r4, r5, r6, lr}
    14f6:	b082      	sub	sp, #8
    14f8:	9001      	str	r0, [sp, #4]
        Queue_t * pxQueueSetContainer = pxQueue->pxQueueSetContainer;
    14fa:	6c85      	ldr	r5, [r0, #72]	; 0x48
        /* This function must be called form a critical section. */

        /* The following line is not reachable in unit tests because every call
         * to prvNotifyQueueSetContainer is preceded by a check that
         * pxQueueSetContainer != NULL */
        configASSERT( pxQueueSetContainer ); /* LCOV_EXCL_BR_LINE */
    14fc:	b165      	cbz	r5, 1518 <prvNotifyQueueSetContainer+0x24>
        configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
    14fe:	6baa      	ldr	r2, [r5, #56]	; 0x38
    1500:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    1502:	429a      	cmp	r2, r3
    1504:	d311      	bcc.n	152a <prvNotifyQueueSetContainer+0x36>
    1506:	f04f 0380 	mov.w	r3, #128	; 0x80
    150a:	f383 8811 	msr	BASEPRI, r3
    150e:	f3bf 8f6f 	isb	sy
    1512:	f3bf 8f4f 	dsb	sy
    1516:	e7fe      	b.n	1516 <prvNotifyQueueSetContainer+0x22>
    1518:	f04f 0380 	mov.w	r3, #128	; 0x80
    151c:	f383 8811 	msr	BASEPRI, r3
    1520:	f3bf 8f6f 	isb	sy
    1524:	f3bf 8f4f 	dsb	sy
    1528:	e7fe      	b.n	1528 <prvNotifyQueueSetContainer+0x34>

        if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
    152a:	6baa      	ldr	r2, [r5, #56]	; 0x38
    152c:	4293      	cmp	r3, r2
    152e:	d803      	bhi.n	1538 <prvNotifyQueueSetContainer+0x44>
        BaseType_t xReturn = pdFALSE;
    1530:	2600      	movs	r6, #0
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    1532:	4630      	mov	r0, r6
    1534:	b002      	add	sp, #8
    1536:	bd70      	pop	{r4, r5, r6, pc}
            const int8_t cTxLock = pxQueueSetContainer->cTxLock;
    1538:	f895 4045 	ldrb.w	r4, [r5, #69]	; 0x45
    153c:	b264      	sxtb	r4, r4
            xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, queueSEND_TO_BACK );
    153e:	2200      	movs	r2, #0
    1540:	a901      	add	r1, sp, #4
    1542:	4628      	mov	r0, r5
    1544:	4b12      	ldr	r3, [pc, #72]	; (1590 <prvNotifyQueueSetContainer+0x9c>)
    1546:	4798      	blx	r3
    1548:	4606      	mov	r6, r0
            if( cTxLock == queueUNLOCKED )
    154a:	f1b4 3fff 	cmp.w	r4, #4294967295
    154e:	d10a      	bne.n	1566 <prvNotifyQueueSetContainer+0x72>
                if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
    1550:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    1552:	2b00      	cmp	r3, #0
    1554:	d0ed      	beq.n	1532 <prvNotifyQueueSetContainer+0x3e>
                    if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
    1556:	f105 0024 	add.w	r0, r5, #36	; 0x24
    155a:	4b0e      	ldr	r3, [pc, #56]	; (1594 <prvNotifyQueueSetContainer+0xa0>)
    155c:	4798      	blx	r3
    155e:	2800      	cmp	r0, #0
    1560:	d0e7      	beq.n	1532 <prvNotifyQueueSetContainer+0x3e>
                        xReturn = pdTRUE;
    1562:	2601      	movs	r6, #1
        return xReturn;
    1564:	e7e5      	b.n	1532 <prvNotifyQueueSetContainer+0x3e>
                prvIncrementQueueTxLock( pxQueueSetContainer, cTxLock );
    1566:	4b0c      	ldr	r3, [pc, #48]	; (1598 <prvNotifyQueueSetContainer+0xa4>)
    1568:	4798      	blx	r3
    156a:	42a0      	cmp	r0, r4
    156c:	d9e1      	bls.n	1532 <prvNotifyQueueSetContainer+0x3e>
    156e:	2c7f      	cmp	r4, #127	; 0x7f
    1570:	d108      	bne.n	1584 <prvNotifyQueueSetContainer+0x90>
    1572:	f04f 0380 	mov.w	r3, #128	; 0x80
    1576:	f383 8811 	msr	BASEPRI, r3
    157a:	f3bf 8f6f 	isb	sy
    157e:	f3bf 8f4f 	dsb	sy
    1582:	e7fe      	b.n	1582 <prvNotifyQueueSetContainer+0x8e>
    1584:	1c63      	adds	r3, r4, #1
    1586:	b25b      	sxtb	r3, r3
    1588:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
    158c:	e7d1      	b.n	1532 <prvNotifyQueueSetContainer+0x3e>
    158e:	bf00      	nop
    1590:	0000144d 	.word	0x0000144d
    1594:	00002751 	.word	0x00002751
    1598:	000022b5 	.word	0x000022b5

0000159c <prvUnlockQueue>:
{
    159c:	b538      	push	{r3, r4, r5, lr}
    159e:	4605      	mov	r5, r0
    taskENTER_CRITICAL();
    15a0:	4b1f      	ldr	r3, [pc, #124]	; (1620 <prvUnlockQueue+0x84>)
    15a2:	4798      	blx	r3
        int8_t cTxLock = pxQueue->cTxLock;
    15a4:	f895 4045 	ldrb.w	r4, [r5, #69]	; 0x45
    15a8:	b264      	sxtb	r4, r4
        while( cTxLock > queueLOCKED_UNMODIFIED )
    15aa:	e008      	b.n	15be <prvUnlockQueue+0x22>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    15ac:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    15ae:	b1b3      	cbz	r3, 15de <prvUnlockQueue+0x42>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    15b0:	f105 0024 	add.w	r0, r5, #36	; 0x24
    15b4:	4b1b      	ldr	r3, [pc, #108]	; (1624 <prvUnlockQueue+0x88>)
    15b6:	4798      	blx	r3
    15b8:	b970      	cbnz	r0, 15d8 <prvUnlockQueue+0x3c>
            --cTxLock;
    15ba:	3c01      	subs	r4, #1
    15bc:	b264      	sxtb	r4, r4
        while( cTxLock > queueLOCKED_UNMODIFIED )
    15be:	2c00      	cmp	r4, #0
    15c0:	dd0d      	ble.n	15de <prvUnlockQueue+0x42>
                if( pxQueue->pxQueueSetContainer != NULL )
    15c2:	6cab      	ldr	r3, [r5, #72]	; 0x48
    15c4:	2b00      	cmp	r3, #0
    15c6:	d0f1      	beq.n	15ac <prvUnlockQueue+0x10>
                    if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
    15c8:	4628      	mov	r0, r5
    15ca:	4b17      	ldr	r3, [pc, #92]	; (1628 <prvUnlockQueue+0x8c>)
    15cc:	4798      	blx	r3
    15ce:	2800      	cmp	r0, #0
    15d0:	d0f3      	beq.n	15ba <prvUnlockQueue+0x1e>
                        vTaskMissedYield();
    15d2:	4b16      	ldr	r3, [pc, #88]	; (162c <prvUnlockQueue+0x90>)
    15d4:	4798      	blx	r3
    15d6:	e7f0      	b.n	15ba <prvUnlockQueue+0x1e>
                            vTaskMissedYield();
    15d8:	4b14      	ldr	r3, [pc, #80]	; (162c <prvUnlockQueue+0x90>)
    15da:	4798      	blx	r3
    15dc:	e7ed      	b.n	15ba <prvUnlockQueue+0x1e>
        pxQueue->cTxLock = queueUNLOCKED;
    15de:	23ff      	movs	r3, #255	; 0xff
    15e0:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
    taskEXIT_CRITICAL();
    15e4:	4b12      	ldr	r3, [pc, #72]	; (1630 <prvUnlockQueue+0x94>)
    15e6:	4798      	blx	r3
    taskENTER_CRITICAL();
    15e8:	4b0d      	ldr	r3, [pc, #52]	; (1620 <prvUnlockQueue+0x84>)
    15ea:	4798      	blx	r3
        int8_t cRxLock = pxQueue->cRxLock;
    15ec:	f895 4044 	ldrb.w	r4, [r5, #68]	; 0x44
    15f0:	b264      	sxtb	r4, r4
        while( cRxLock > queueLOCKED_UNMODIFIED )
    15f2:	e001      	b.n	15f8 <prvUnlockQueue+0x5c>
                --cRxLock;
    15f4:	3c01      	subs	r4, #1
    15f6:	b264      	sxtb	r4, r4
        while( cRxLock > queueLOCKED_UNMODIFIED )
    15f8:	2c00      	cmp	r4, #0
    15fa:	dd0a      	ble.n	1612 <prvUnlockQueue+0x76>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    15fc:	692b      	ldr	r3, [r5, #16]
    15fe:	b143      	cbz	r3, 1612 <prvUnlockQueue+0x76>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1600:	f105 0010 	add.w	r0, r5, #16
    1604:	4b07      	ldr	r3, [pc, #28]	; (1624 <prvUnlockQueue+0x88>)
    1606:	4798      	blx	r3
    1608:	2800      	cmp	r0, #0
    160a:	d0f3      	beq.n	15f4 <prvUnlockQueue+0x58>
                    vTaskMissedYield();
    160c:	4b07      	ldr	r3, [pc, #28]	; (162c <prvUnlockQueue+0x90>)
    160e:	4798      	blx	r3
    1610:	e7f0      	b.n	15f4 <prvUnlockQueue+0x58>
        pxQueue->cRxLock = queueUNLOCKED;
    1612:	23ff      	movs	r3, #255	; 0xff
    1614:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
    taskEXIT_CRITICAL();
    1618:	4b05      	ldr	r3, [pc, #20]	; (1630 <prvUnlockQueue+0x94>)
    161a:	4798      	blx	r3
    161c:	bd38      	pop	{r3, r4, r5, pc}
    161e:	bf00      	nop
    1620:	00000fa5 	.word	0x00000fa5
    1624:	00002751 	.word	0x00002751
    1628:	000014f5 	.word	0x000014f5
    162c:	000028f1 	.word	0x000028f1
    1630:	00000fe9 	.word	0x00000fe9

00001634 <xQueueGenericReset>:
{
    1634:	b538      	push	{r3, r4, r5, lr}
    configASSERT( pxQueue );
    1636:	b160      	cbz	r0, 1652 <xQueueGenericReset+0x1e>
    1638:	4604      	mov	r4, r0
        ( pxQueue->uxLength >= 1U ) &&
    163a:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
    if( ( pxQueue != NULL ) &&
    163c:	2a00      	cmp	r2, #0
    163e:	d042      	beq.n	16c6 <xQueueGenericReset+0x92>
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    1640:	f04f 33ff 	mov.w	r3, #4294967295
    1644:	fbb3 f3f2 	udiv	r3, r3, r2
    1648:	6c02      	ldr	r2, [r0, #64]	; 0x40
        ( pxQueue->uxLength >= 1U ) &&
    164a:	4293      	cmp	r3, r2
    164c:	d20a      	bcs.n	1664 <xQueueGenericReset+0x30>
        xReturn = pdFAIL;
    164e:	2000      	movs	r0, #0
    1650:	e03a      	b.n	16c8 <xQueueGenericReset+0x94>
    1652:	f04f 0380 	mov.w	r3, #128	; 0x80
    1656:	f383 8811 	msr	BASEPRI, r3
    165a:	f3bf 8f6f 	isb	sy
    165e:	f3bf 8f4f 	dsb	sy
    1662:	e7fe      	b.n	1662 <xQueueGenericReset+0x2e>
    1664:	460d      	mov	r5, r1
        taskENTER_CRITICAL();
    1666:	4b1e      	ldr	r3, [pc, #120]	; (16e0 <xQueueGenericReset+0xac>)
    1668:	4798      	blx	r3
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    166a:	6821      	ldr	r1, [r4, #0]
    166c:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    166e:	6c23      	ldr	r3, [r4, #64]	; 0x40
    1670:	fb03 1002 	mla	r0, r3, r2, r1
    1674:	60a0      	str	r0, [r4, #8]
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1676:	2000      	movs	r0, #0
    1678:	63a0      	str	r0, [r4, #56]	; 0x38
            pxQueue->pcWriteTo = pxQueue->pcHead;
    167a:	6061      	str	r1, [r4, #4]
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize );
    167c:	3a01      	subs	r2, #1
    167e:	fb02 1303 	mla	r3, r2, r3, r1
    1682:	60e3      	str	r3, [r4, #12]
            pxQueue->cRxLock = queueUNLOCKED;
    1684:	23ff      	movs	r3, #255	; 0xff
    1686:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
            pxQueue->cTxLock = queueUNLOCKED;
    168a:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
            if( xNewQueue == pdFALSE )
    168e:	b995      	cbnz	r5, 16b6 <xQueueGenericReset+0x82>
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1690:	6923      	ldr	r3, [r4, #16]
    1692:	b163      	cbz	r3, 16ae <xQueueGenericReset+0x7a>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1694:	f104 0010 	add.w	r0, r4, #16
    1698:	4b12      	ldr	r3, [pc, #72]	; (16e4 <xQueueGenericReset+0xb0>)
    169a:	4798      	blx	r3
    169c:	b138      	cbz	r0, 16ae <xQueueGenericReset+0x7a>
                        queueYIELD_IF_USING_PREEMPTION();
    169e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    16a2:	4b11      	ldr	r3, [pc, #68]	; (16e8 <xQueueGenericReset+0xb4>)
    16a4:	601a      	str	r2, [r3, #0]
    16a6:	f3bf 8f4f 	dsb	sy
    16aa:	f3bf 8f6f 	isb	sy
        taskEXIT_CRITICAL();
    16ae:	4b0f      	ldr	r3, [pc, #60]	; (16ec <xQueueGenericReset+0xb8>)
    16b0:	4798      	blx	r3
    BaseType_t xReturn = pdPASS;
    16b2:	2001      	movs	r0, #1
        taskEXIT_CRITICAL();
    16b4:	e008      	b.n	16c8 <xQueueGenericReset+0x94>
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    16b6:	f104 0010 	add.w	r0, r4, #16
    16ba:	4d0d      	ldr	r5, [pc, #52]	; (16f0 <xQueueGenericReset+0xbc>)
    16bc:	47a8      	blx	r5
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    16be:	f104 0024 	add.w	r0, r4, #36	; 0x24
    16c2:	47a8      	blx	r5
    16c4:	e7f3      	b.n	16ae <xQueueGenericReset+0x7a>
        xReturn = pdFAIL;
    16c6:	2000      	movs	r0, #0
    configASSERT( xReturn != pdFAIL );
    16c8:	b940      	cbnz	r0, 16dc <xQueueGenericReset+0xa8>
    16ca:	f04f 0380 	mov.w	r3, #128	; 0x80
    16ce:	f383 8811 	msr	BASEPRI, r3
    16d2:	f3bf 8f6f 	isb	sy
    16d6:	f3bf 8f4f 	dsb	sy
    16da:	e7fe      	b.n	16da <xQueueGenericReset+0xa6>
}
    16dc:	bd38      	pop	{r3, r4, r5, pc}
    16de:	bf00      	nop
    16e0:	00000fa5 	.word	0x00000fa5
    16e4:	00002751 	.word	0x00002751
    16e8:	e000ed04 	.word	0xe000ed04
    16ec:	00000fe9 	.word	0x00000fe9
    16f0:	00000df5 	.word	0x00000df5

000016f4 <prvInitialiseNewQueue>:
{
    16f4:	b538      	push	{r3, r4, r5, lr}
    16f6:	461d      	mov	r5, r3
    16f8:	9c04      	ldr	r4, [sp, #16]
    if( uxItemSize == ( UBaseType_t ) 0 )
    16fa:	460b      	mov	r3, r1
    16fc:	b959      	cbnz	r1, 1716 <prvInitialiseNewQueue+0x22>
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    16fe:	6024      	str	r4, [r4, #0]
    pxNewQueue->uxLength = uxQueueLength;
    1700:	63e0      	str	r0, [r4, #60]	; 0x3c
    pxNewQueue->uxItemSize = uxItemSize;
    1702:	6423      	str	r3, [r4, #64]	; 0x40
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1704:	2101      	movs	r1, #1
    1706:	4620      	mov	r0, r4
    1708:	4b04      	ldr	r3, [pc, #16]	; (171c <prvInitialiseNewQueue+0x28>)
    170a:	4798      	blx	r3
        pxNewQueue->ucQueueType = ucQueueType;
    170c:	f884 5050 	strb.w	r5, [r4, #80]	; 0x50
        pxNewQueue->pxQueueSetContainer = NULL;
    1710:	2300      	movs	r3, #0
    1712:	64a3      	str	r3, [r4, #72]	; 0x48
    1714:	bd38      	pop	{r3, r4, r5, pc}
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1716:	6022      	str	r2, [r4, #0]
    1718:	e7f2      	b.n	1700 <prvInitialiseNewQueue+0xc>
    171a:	bf00      	nop
    171c:	00001635 	.word	0x00001635

00001720 <xQueueGenericCreateStatic>:
        configASSERT( pxStaticQueue );
    1720:	b1ab      	cbz	r3, 174e <xQueueGenericCreateStatic+0x2e>
    {
    1722:	b530      	push	{r4, r5, lr}
    1724:	b085      	sub	sp, #20
    1726:	461c      	mov	r4, r3
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    1728:	b1d0      	cbz	r0, 1760 <xQueueGenericCreateStatic+0x40>
            ( pxStaticQueue != NULL ) &&
    172a:	b102      	cbz	r2, 172e <xQueueGenericCreateStatic+0xe>
            ( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0U ) ) ) &&
    172c:	b1c1      	cbz	r1, 1760 <xQueueGenericCreateStatic+0x40>
    172e:	b902      	cbnz	r2, 1732 <xQueueGenericCreateStatic+0x12>
            ( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0U ) ) ) )
    1730:	b9b1      	cbnz	r1, 1760 <xQueueGenericCreateStatic+0x40>
                volatile size_t xSize = sizeof( StaticQueue_t );
    1732:	2354      	movs	r3, #84	; 0x54
    1734:	9303      	str	r3, [sp, #12]
                configASSERT( xSize == sizeof( Queue_t ) ); /* LCOV_EXCL_BR_LINE */
    1736:	9b03      	ldr	r3, [sp, #12]
    1738:	2b54      	cmp	r3, #84	; 0x54
    173a:	d01a      	beq.n	1772 <xQueueGenericCreateStatic+0x52>
    173c:	f04f 0380 	mov.w	r3, #128	; 0x80
    1740:	f383 8811 	msr	BASEPRI, r3
    1744:	f3bf 8f6f 	isb	sy
    1748:	f3bf 8f4f 	dsb	sy
    174c:	e7fe      	b.n	174c <xQueueGenericCreateStatic+0x2c>
    174e:	f04f 0380 	mov.w	r3, #128	; 0x80
    1752:	f383 8811 	msr	BASEPRI, r3
    1756:	f3bf 8f6f 	isb	sy
    175a:	f3bf 8f4f 	dsb	sy
    175e:	e7fe      	b.n	175e <xQueueGenericCreateStatic+0x3e>
    1760:	f04f 0380 	mov.w	r3, #128	; 0x80
    1764:	f383 8811 	msr	BASEPRI, r3
    1768:	f3bf 8f6f 	isb	sy
    176c:	f3bf 8f4f 	dsb	sy
    1770:	e7fe      	b.n	1770 <xQueueGenericCreateStatic+0x50>
                ( void ) xSize;                             /* Prevent unused variable warning when configASSERT() is not defined. */
    1772:	9b03      	ldr	r3, [sp, #12]
                pxNewQueue->ucStaticallyAllocated = pdTRUE;
    1774:	2301      	movs	r3, #1
    1776:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    177a:	9400      	str	r4, [sp, #0]
    177c:	f89d 3020 	ldrb.w	r3, [sp, #32]
    1780:	4d02      	ldr	r5, [pc, #8]	; (178c <xQueueGenericCreateStatic+0x6c>)
    1782:	47a8      	blx	r5
    }
    1784:	4620      	mov	r0, r4
    1786:	b005      	add	sp, #20
    1788:	bd30      	pop	{r4, r5, pc}
    178a:	bf00      	nop
    178c:	000016f5 	.word	0x000016f5

00001790 <xQueueGenericCreate>:
    {
    1790:	b5f0      	push	{r4, r5, r6, r7, lr}
    1792:	b083      	sub	sp, #12
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    1794:	b300      	cbz	r0, 17d8 <xQueueGenericCreate+0x48>
    1796:	4607      	mov	r7, r0
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
    1798:	f04f 30ff 	mov.w	r0, #4294967295
    179c:	fbb0 f0f7 	udiv	r0, r0, r7
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    17a0:	4288      	cmp	r0, r1
    17a2:	d319      	bcc.n	17d8 <xQueueGenericCreate+0x48>
            ( ( UBaseType_t ) ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
    17a4:	fb01 f007 	mul.w	r0, r1, r7
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
    17a8:	f110 0f55 	cmn.w	r0, #85	; 0x55
    17ac:	d814      	bhi.n	17d8 <xQueueGenericCreate+0x48>
    17ae:	4616      	mov	r6, r2
    17b0:	460c      	mov	r4, r1
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    17b2:	3054      	adds	r0, #84	; 0x54
    17b4:	4b0d      	ldr	r3, [pc, #52]	; (17ec <xQueueGenericCreate+0x5c>)
    17b6:	4798      	blx	r3
            if( pxNewQueue != NULL )
    17b8:	4605      	mov	r5, r0
    17ba:	b150      	cbz	r0, 17d2 <xQueueGenericCreate+0x42>
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
    17bc:	2300      	movs	r3, #0
    17be:	f880 3046 	strb.w	r3, [r0, #70]	; 0x46
                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    17c2:	9000      	str	r0, [sp, #0]
    17c4:	4633      	mov	r3, r6
    17c6:	f100 0254 	add.w	r2, r0, #84	; 0x54
    17ca:	4621      	mov	r1, r4
    17cc:	4638      	mov	r0, r7
    17ce:	4c08      	ldr	r4, [pc, #32]	; (17f0 <xQueueGenericCreate+0x60>)
    17d0:	47a0      	blx	r4
    }
    17d2:	4628      	mov	r0, r5
    17d4:	b003      	add	sp, #12
    17d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    17d8:	f04f 0380 	mov.w	r3, #128	; 0x80
    17dc:	f383 8811 	msr	BASEPRI, r3
    17e0:	f3bf 8f6f 	isb	sy
    17e4:	f3bf 8f4f 	dsb	sy
    17e8:	e7fe      	b.n	17e8 <xQueueGenericCreate+0x58>
    17ea:	bf00      	nop
    17ec:	00001281 	.word	0x00001281
    17f0:	000016f5 	.word	0x000016f5

000017f4 <xQueueCreateCountingSemaphore>:
        if( ( uxMaxCount != 0U ) &&
    17f4:	b108      	cbz	r0, 17fa <xQueueCreateCountingSemaphore+0x6>
    17f6:	4288      	cmp	r0, r1
    17f8:	d208      	bcs.n	180c <xQueueCreateCountingSemaphore+0x18>
    17fa:	f04f 0380 	mov.w	r3, #128	; 0x80
    17fe:	f383 8811 	msr	BASEPRI, r3
    1802:	f3bf 8f6f 	isb	sy
    1806:	f3bf 8f4f 	dsb	sy
    180a:	e7fe      	b.n	180a <xQueueCreateCountingSemaphore+0x16>
    {
    180c:	b510      	push	{r4, lr}
    180e:	460c      	mov	r4, r1
            xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    1810:	2202      	movs	r2, #2
    1812:	2100      	movs	r1, #0
    1814:	4b03      	ldr	r3, [pc, #12]	; (1824 <xQueueCreateCountingSemaphore+0x30>)
    1816:	4798      	blx	r3
            if( xHandle != NULL )
    1818:	4603      	mov	r3, r0
    181a:	b100      	cbz	r0, 181e <xQueueCreateCountingSemaphore+0x2a>
                ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    181c:	6384      	str	r4, [r0, #56]	; 0x38
    }
    181e:	4618      	mov	r0, r3
    1820:	bd10      	pop	{r4, pc}
    1822:	bf00      	nop
    1824:	00001791 	.word	0x00001791

00001828 <xQueueGenericSend>:
{
    1828:	b5f0      	push	{r4, r5, r6, r7, lr}
    182a:	b085      	sub	sp, #20
    182c:	9201      	str	r2, [sp, #4]
    configASSERT( pxQueue );
    182e:	b160      	cbz	r0, 184a <xQueueGenericSend+0x22>
    1830:	4604      	mov	r4, r0
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    1832:	b199      	cbz	r1, 185c <xQueueGenericSend+0x34>
    1834:	2501      	movs	r5, #1
    1836:	b9bd      	cbnz	r5, 1868 <xQueueGenericSend+0x40>
    1838:	f04f 0380 	mov.w	r3, #128	; 0x80
    183c:	f383 8811 	msr	BASEPRI, r3
    1840:	f3bf 8f6f 	isb	sy
    1844:	f3bf 8f4f 	dsb	sy
    1848:	e7fe      	b.n	1848 <xQueueGenericSend+0x20>
    184a:	f04f 0380 	mov.w	r3, #128	; 0x80
    184e:	f383 8811 	msr	BASEPRI, r3
    1852:	f3bf 8f6f 	isb	sy
    1856:	f3bf 8f4f 	dsb	sy
    185a:	e7fe      	b.n	185a <xQueueGenericSend+0x32>
    185c:	6c02      	ldr	r2, [r0, #64]	; 0x40
    185e:	b90a      	cbnz	r2, 1864 <xQueueGenericSend+0x3c>
    1860:	2501      	movs	r5, #1
    1862:	e7e8      	b.n	1836 <xQueueGenericSend+0xe>
    1864:	2500      	movs	r5, #0
    1866:	e7e6      	b.n	1836 <xQueueGenericSend+0xe>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    1868:	2b02      	cmp	r3, #2
    186a:	d009      	beq.n	1880 <xQueueGenericSend+0x58>
    186c:	b96d      	cbnz	r5, 188a <xQueueGenericSend+0x62>
    186e:	f04f 0380 	mov.w	r3, #128	; 0x80
    1872:	f383 8811 	msr	BASEPRI, r3
    1876:	f3bf 8f6f 	isb	sy
    187a:	f3bf 8f4f 	dsb	sy
    187e:	e7fe      	b.n	187e <xQueueGenericSend+0x56>
    1880:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    1882:	2a01      	cmp	r2, #1
    1884:	d0f2      	beq.n	186c <xQueueGenericSend+0x44>
    1886:	2500      	movs	r5, #0
    1888:	e7f0      	b.n	186c <xQueueGenericSend+0x44>
    188a:	461e      	mov	r6, r3
    188c:	460f      	mov	r7, r1
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    188e:	4b51      	ldr	r3, [pc, #324]	; (19d4 <xQueueGenericSend+0x1ac>)
    1890:	4798      	blx	r3
    1892:	b910      	cbnz	r0, 189a <xQueueGenericSend+0x72>
    1894:	9b01      	ldr	r3, [sp, #4]
    1896:	b103      	cbz	r3, 189a <xQueueGenericSend+0x72>
    1898:	2500      	movs	r5, #0
    189a:	b945      	cbnz	r5, 18ae <xQueueGenericSend+0x86>
    189c:	f04f 0380 	mov.w	r3, #128	; 0x80
    18a0:	f383 8811 	msr	BASEPRI, r3
    18a4:	f3bf 8f6f 	isb	sy
    18a8:	f3bf 8f4f 	dsb	sy
    18ac:	e7fe      	b.n	18ac <xQueueGenericSend+0x84>
    18ae:	2500      	movs	r5, #0
    18b0:	e040      	b.n	1934 <xQueueGenericSend+0x10c>
                    const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    18b2:	6ba5      	ldr	r5, [r4, #56]	; 0x38
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    18b4:	4632      	mov	r2, r6
    18b6:	4639      	mov	r1, r7
    18b8:	4620      	mov	r0, r4
    18ba:	4b47      	ldr	r3, [pc, #284]	; (19d8 <xQueueGenericSend+0x1b0>)
    18bc:	4798      	blx	r3
                    if( pxQueue->pxQueueSetContainer != NULL )
    18be:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    18c0:	b19b      	cbz	r3, 18ea <xQueueGenericSend+0xc2>
                        if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
    18c2:	2e02      	cmp	r6, #2
    18c4:	d100      	bne.n	18c8 <xQueueGenericSend+0xa0>
    18c6:	b95d      	cbnz	r5, 18e0 <xQueueGenericSend+0xb8>
                        else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
    18c8:	4620      	mov	r0, r4
    18ca:	4b44      	ldr	r3, [pc, #272]	; (19dc <xQueueGenericSend+0x1b4>)
    18cc:	4798      	blx	r3
    18ce:	b138      	cbz	r0, 18e0 <xQueueGenericSend+0xb8>
                            queueYIELD_IF_USING_PREEMPTION();
    18d0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    18d4:	4b42      	ldr	r3, [pc, #264]	; (19e0 <xQueueGenericSend+0x1b8>)
    18d6:	601a      	str	r2, [r3, #0]
    18d8:	f3bf 8f4f 	dsb	sy
    18dc:	f3bf 8f6f 	isb	sy
                taskEXIT_CRITICAL();
    18e0:	4b40      	ldr	r3, [pc, #256]	; (19e4 <xQueueGenericSend+0x1bc>)
    18e2:	4798      	blx	r3
                return pdPASS;
    18e4:	2001      	movs	r0, #1
}
    18e6:	b005      	add	sp, #20
    18e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    18ea:	6a63      	ldr	r3, [r4, #36]	; 0x24
    18ec:	b173      	cbz	r3, 190c <xQueueGenericSend+0xe4>
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    18ee:	f104 0024 	add.w	r0, r4, #36	; 0x24
    18f2:	4b3d      	ldr	r3, [pc, #244]	; (19e8 <xQueueGenericSend+0x1c0>)
    18f4:	4798      	blx	r3
    18f6:	2800      	cmp	r0, #0
    18f8:	d0f2      	beq.n	18e0 <xQueueGenericSend+0xb8>
                                queueYIELD_IF_USING_PREEMPTION();
    18fa:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    18fe:	4b38      	ldr	r3, [pc, #224]	; (19e0 <xQueueGenericSend+0x1b8>)
    1900:	601a      	str	r2, [r3, #0]
    1902:	f3bf 8f4f 	dsb	sy
    1906:	f3bf 8f6f 	isb	sy
    190a:	e7e9      	b.n	18e0 <xQueueGenericSend+0xb8>
                        else if( xYieldRequired != pdFALSE )
    190c:	2800      	cmp	r0, #0
    190e:	d0e7      	beq.n	18e0 <xQueueGenericSend+0xb8>
                            queueYIELD_IF_USING_PREEMPTION();
    1910:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    1914:	4b32      	ldr	r3, [pc, #200]	; (19e0 <xQueueGenericSend+0x1b8>)
    1916:	601a      	str	r2, [r3, #0]
    1918:	f3bf 8f4f 	dsb	sy
    191c:	f3bf 8f6f 	isb	sy
    1920:	e7de      	b.n	18e0 <xQueueGenericSend+0xb8>
                    taskEXIT_CRITICAL();
    1922:	4b30      	ldr	r3, [pc, #192]	; (19e4 <xQueueGenericSend+0x1bc>)
    1924:	4798      	blx	r3
                    return errQUEUE_FULL;
    1926:	2000      	movs	r0, #0
    1928:	e7dd      	b.n	18e6 <xQueueGenericSend+0xbe>
                prvUnlockQueue( pxQueue );
    192a:	4620      	mov	r0, r4
    192c:	4b2f      	ldr	r3, [pc, #188]	; (19ec <xQueueGenericSend+0x1c4>)
    192e:	4798      	blx	r3
                ( void ) xTaskResumeAll();
    1930:	4b2f      	ldr	r3, [pc, #188]	; (19f0 <xQueueGenericSend+0x1c8>)
    1932:	4798      	blx	r3
        taskENTER_CRITICAL();
    1934:	4b2f      	ldr	r3, [pc, #188]	; (19f4 <xQueueGenericSend+0x1cc>)
    1936:	4798      	blx	r3
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1938:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    193a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    193c:	429a      	cmp	r2, r3
    193e:	d3b8      	bcc.n	18b2 <xQueueGenericSend+0x8a>
    1940:	2e02      	cmp	r6, #2
    1942:	d0b6      	beq.n	18b2 <xQueueGenericSend+0x8a>
                if( xTicksToWait == ( TickType_t ) 0 )
    1944:	9b01      	ldr	r3, [sp, #4]
    1946:	2b00      	cmp	r3, #0
    1948:	d0eb      	beq.n	1922 <xQueueGenericSend+0xfa>
                else if( xEntryTimeSet == pdFALSE )
    194a:	b91d      	cbnz	r5, 1954 <xQueueGenericSend+0x12c>
                    vTaskInternalSetTimeOutState( &xTimeOut );
    194c:	a802      	add	r0, sp, #8
    194e:	4b2a      	ldr	r3, [pc, #168]	; (19f8 <xQueueGenericSend+0x1d0>)
    1950:	4798      	blx	r3
                    xEntryTimeSet = pdTRUE;
    1952:	2501      	movs	r5, #1
        taskEXIT_CRITICAL();
    1954:	4b23      	ldr	r3, [pc, #140]	; (19e4 <xQueueGenericSend+0x1bc>)
    1956:	4798      	blx	r3
        vTaskSuspendAll();
    1958:	4b28      	ldr	r3, [pc, #160]	; (19fc <xQueueGenericSend+0x1d4>)
    195a:	4798      	blx	r3
        prvLockQueue( pxQueue );
    195c:	4b25      	ldr	r3, [pc, #148]	; (19f4 <xQueueGenericSend+0x1cc>)
    195e:	4798      	blx	r3
    1960:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    1964:	b25b      	sxtb	r3, r3
    1966:	f1b3 3fff 	cmp.w	r3, #4294967295
    196a:	d102      	bne.n	1972 <xQueueGenericSend+0x14a>
    196c:	2300      	movs	r3, #0
    196e:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
    1972:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    1976:	b25b      	sxtb	r3, r3
    1978:	f1b3 3fff 	cmp.w	r3, #4294967295
    197c:	d102      	bne.n	1984 <xQueueGenericSend+0x15c>
    197e:	2300      	movs	r3, #0
    1980:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
    1984:	4b17      	ldr	r3, [pc, #92]	; (19e4 <xQueueGenericSend+0x1bc>)
    1986:	4798      	blx	r3
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1988:	a901      	add	r1, sp, #4
    198a:	a802      	add	r0, sp, #8
    198c:	4b1c      	ldr	r3, [pc, #112]	; (1a00 <xQueueGenericSend+0x1d8>)
    198e:	4798      	blx	r3
    1990:	b9c8      	cbnz	r0, 19c6 <xQueueGenericSend+0x19e>
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1992:	4620      	mov	r0, r4
    1994:	4b1b      	ldr	r3, [pc, #108]	; (1a04 <xQueueGenericSend+0x1dc>)
    1996:	4798      	blx	r3
    1998:	2800      	cmp	r0, #0
    199a:	d0c6      	beq.n	192a <xQueueGenericSend+0x102>
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    199c:	9901      	ldr	r1, [sp, #4]
    199e:	f104 0010 	add.w	r0, r4, #16
    19a2:	4b19      	ldr	r3, [pc, #100]	; (1a08 <xQueueGenericSend+0x1e0>)
    19a4:	4798      	blx	r3
                prvUnlockQueue( pxQueue );
    19a6:	4620      	mov	r0, r4
    19a8:	4b10      	ldr	r3, [pc, #64]	; (19ec <xQueueGenericSend+0x1c4>)
    19aa:	4798      	blx	r3
                if( xTaskResumeAll() == pdFALSE )
    19ac:	4b10      	ldr	r3, [pc, #64]	; (19f0 <xQueueGenericSend+0x1c8>)
    19ae:	4798      	blx	r3
    19b0:	2800      	cmp	r0, #0
    19b2:	d1bf      	bne.n	1934 <xQueueGenericSend+0x10c>
                    taskYIELD_WITHIN_API();
    19b4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    19b8:	4b09      	ldr	r3, [pc, #36]	; (19e0 <xQueueGenericSend+0x1b8>)
    19ba:	601a      	str	r2, [r3, #0]
    19bc:	f3bf 8f4f 	dsb	sy
    19c0:	f3bf 8f6f 	isb	sy
    19c4:	e7b6      	b.n	1934 <xQueueGenericSend+0x10c>
            prvUnlockQueue( pxQueue );
    19c6:	4620      	mov	r0, r4
    19c8:	4b08      	ldr	r3, [pc, #32]	; (19ec <xQueueGenericSend+0x1c4>)
    19ca:	4798      	blx	r3
            ( void ) xTaskResumeAll();
    19cc:	4b08      	ldr	r3, [pc, #32]	; (19f0 <xQueueGenericSend+0x1c8>)
    19ce:	4798      	blx	r3
            return errQUEUE_FULL;
    19d0:	2000      	movs	r0, #0
    19d2:	e788      	b.n	18e6 <xQueueGenericSend+0xbe>
    19d4:	00002901 	.word	0x00002901
    19d8:	0000144d 	.word	0x0000144d
    19dc:	000014f5 	.word	0x000014f5
    19e0:	e000ed04 	.word	0xe000ed04
    19e4:	00000fe9 	.word	0x00000fe9
    19e8:	00002751 	.word	0x00002751
    19ec:	0000159d 	.word	0x0000159d
    19f0:	00002445 	.word	0x00002445
    19f4:	00000fa5 	.word	0x00000fa5
    19f8:	0000284d 	.word	0x0000284d
    19fc:	00002295 	.word	0x00002295
    1a00:	00002861 	.word	0x00002861
    1a04:	00001401 	.word	0x00001401
    1a08:	000026b1 	.word	0x000026b1

00001a0c <xQueueGiveFromISR>:
{
    1a0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    configASSERT( pxQueue );
    1a0e:	b158      	cbz	r0, 1a28 <xQueueGiveFromISR+0x1c>
    1a10:	4604      	mov	r4, r0
    configASSERT( pxQueue->uxItemSize == 0 );
    1a12:	6c03      	ldr	r3, [r0, #64]	; 0x40
    1a14:	b18b      	cbz	r3, 1a3a <xQueueGiveFromISR+0x2e>
    1a16:	f04f 0380 	mov.w	r3, #128	; 0x80
    1a1a:	f383 8811 	msr	BASEPRI, r3
    1a1e:	f3bf 8f6f 	isb	sy
    1a22:	f3bf 8f4f 	dsb	sy
    1a26:	e7fe      	b.n	1a26 <xQueueGiveFromISR+0x1a>
    1a28:	f04f 0380 	mov.w	r3, #128	; 0x80
    1a2c:	f383 8811 	msr	BASEPRI, r3
    1a30:	f3bf 8f6f 	isb	sy
    1a34:	f3bf 8f4f 	dsb	sy
    1a38:	e7fe      	b.n	1a38 <xQueueGiveFromISR+0x2c>
    configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
    1a3a:	6803      	ldr	r3, [r0, #0]
    1a3c:	b153      	cbz	r3, 1a54 <xQueueGiveFromISR+0x48>
    1a3e:	2301      	movs	r3, #1
    1a40:	b973      	cbnz	r3, 1a60 <xQueueGiveFromISR+0x54>
    1a42:	f04f 0380 	mov.w	r3, #128	; 0x80
    1a46:	f383 8811 	msr	BASEPRI, r3
    1a4a:	f3bf 8f6f 	isb	sy
    1a4e:	f3bf 8f4f 	dsb	sy
    1a52:	e7fe      	b.n	1a52 <xQueueGiveFromISR+0x46>
    1a54:	6883      	ldr	r3, [r0, #8]
    1a56:	b90b      	cbnz	r3, 1a5c <xQueueGiveFromISR+0x50>
    1a58:	2301      	movs	r3, #1
    1a5a:	e7f1      	b.n	1a40 <xQueueGiveFromISR+0x34>
    1a5c:	2300      	movs	r3, #0
    1a5e:	e7ef      	b.n	1a40 <xQueueGiveFromISR+0x34>
    1a60:	460f      	mov	r7, r1
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    1a62:	4b29      	ldr	r3, [pc, #164]	; (1b08 <xQueueGiveFromISR+0xfc>)
    1a64:	4798      	blx	r3
    __asm volatile
    1a66:	f3ef 8611 	mrs	r6, BASEPRI
    1a6a:	f04f 0380 	mov.w	r3, #128	; 0x80
    1a6e:	f383 8811 	msr	BASEPRI, r3
    1a72:	f3bf 8f6f 	isb	sy
    1a76:	f3bf 8f4f 	dsb	sy
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1a7a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
        if( uxMessagesWaiting < pxQueue->uxLength )
    1a7c:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    1a7e:	4293      	cmp	r3, r2
    1a80:	d233      	bcs.n	1aea <xQueueGiveFromISR+0xde>
            const int8_t cTxLock = pxQueue->cTxLock;
    1a82:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
    1a86:	b26d      	sxtb	r5, r5
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting + ( UBaseType_t ) 1 );
    1a88:	3301      	adds	r3, #1
    1a8a:	63a3      	str	r3, [r4, #56]	; 0x38
            if( cTxLock == queueUNLOCKED )
    1a8c:	f1b5 3fff 	cmp.w	r5, #4294967295
    1a90:	d116      	bne.n	1ac0 <xQueueGiveFromISR+0xb4>
                    if( pxQueue->pxQueueSetContainer != NULL )
    1a92:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    1a94:	b14b      	cbz	r3, 1aaa <xQueueGiveFromISR+0x9e>
                        if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
    1a96:	4620      	mov	r0, r4
    1a98:	4b1c      	ldr	r3, [pc, #112]	; (1b0c <xQueueGiveFromISR+0x100>)
    1a9a:	4798      	blx	r3
    1a9c:	b338      	cbz	r0, 1aee <xQueueGiveFromISR+0xe2>
                            if( pxHigherPriorityTaskWoken != NULL )
    1a9e:	b347      	cbz	r7, 1af2 <xQueueGiveFromISR+0xe6>
                                *pxHigherPriorityTaskWoken = pdTRUE;
    1aa0:	2001      	movs	r0, #1
    1aa2:	6038      	str	r0, [r7, #0]
    __asm volatile
    1aa4:	f386 8811 	msr	BASEPRI, r6
}
    1aa8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1aaa:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1aac:	b31b      	cbz	r3, 1af6 <xQueueGiveFromISR+0xea>
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1aae:	f104 0024 	add.w	r0, r4, #36	; 0x24
    1ab2:	4b17      	ldr	r3, [pc, #92]	; (1b10 <xQueueGiveFromISR+0x104>)
    1ab4:	4798      	blx	r3
    1ab6:	b300      	cbz	r0, 1afa <xQueueGiveFromISR+0xee>
                                if( pxHigherPriorityTaskWoken != NULL )
    1ab8:	b30f      	cbz	r7, 1afe <xQueueGiveFromISR+0xf2>
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    1aba:	2001      	movs	r0, #1
    1abc:	6038      	str	r0, [r7, #0]
    1abe:	e7f1      	b.n	1aa4 <xQueueGiveFromISR+0x98>
                prvIncrementQueueTxLock( pxQueue, cTxLock );
    1ac0:	4b14      	ldr	r3, [pc, #80]	; (1b14 <xQueueGiveFromISR+0x108>)
    1ac2:	4798      	blx	r3
    1ac4:	42a8      	cmp	r0, r5
    1ac6:	d91c      	bls.n	1b02 <xQueueGiveFromISR+0xf6>
    1ac8:	2d7f      	cmp	r5, #127	; 0x7f
    1aca:	d108      	bne.n	1ade <xQueueGiveFromISR+0xd2>
    __asm volatile
    1acc:	f04f 0380 	mov.w	r3, #128	; 0x80
    1ad0:	f383 8811 	msr	BASEPRI, r3
    1ad4:	f3bf 8f6f 	isb	sy
    1ad8:	f3bf 8f4f 	dsb	sy
    1adc:	e7fe      	b.n	1adc <xQueueGiveFromISR+0xd0>
    1ade:	1c6b      	adds	r3, r5, #1
    1ae0:	b25b      	sxtb	r3, r3
    1ae2:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
            xReturn = pdPASS;
    1ae6:	2001      	movs	r0, #1
    1ae8:	e7dc      	b.n	1aa4 <xQueueGiveFromISR+0x98>
            xReturn = errQUEUE_FULL;
    1aea:	2000      	movs	r0, #0
    1aec:	e7da      	b.n	1aa4 <xQueueGiveFromISR+0x98>
            xReturn = pdPASS;
    1aee:	2001      	movs	r0, #1
    1af0:	e7d8      	b.n	1aa4 <xQueueGiveFromISR+0x98>
    1af2:	2001      	movs	r0, #1
    1af4:	e7d6      	b.n	1aa4 <xQueueGiveFromISR+0x98>
    1af6:	2001      	movs	r0, #1
    1af8:	e7d4      	b.n	1aa4 <xQueueGiveFromISR+0x98>
    1afa:	2001      	movs	r0, #1
    1afc:	e7d2      	b.n	1aa4 <xQueueGiveFromISR+0x98>
    1afe:	2001      	movs	r0, #1
    1b00:	e7d0      	b.n	1aa4 <xQueueGiveFromISR+0x98>
    1b02:	2001      	movs	r0, #1
    1b04:	e7ce      	b.n	1aa4 <xQueueGiveFromISR+0x98>
    1b06:	bf00      	nop
    1b08:	000011fd 	.word	0x000011fd
    1b0c:	000014f5 	.word	0x000014f5
    1b10:	00002751 	.word	0x00002751
    1b14:	000022b5 	.word	0x000022b5

00001b18 <xQueueReceive>:
{
    1b18:	b5f0      	push	{r4, r5, r6, r7, lr}
    1b1a:	b085      	sub	sp, #20
    1b1c:	9201      	str	r2, [sp, #4]
    configASSERT( ( pxQueue ) );
    1b1e:	b160      	cbz	r0, 1b3a <xQueueReceive+0x22>
    1b20:	4604      	mov	r4, r0
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
    1b22:	b199      	cbz	r1, 1b4c <xQueueReceive+0x34>
    1b24:	2501      	movs	r5, #1
    1b26:	b9bd      	cbnz	r5, 1b58 <xQueueReceive+0x40>
    1b28:	f04f 0380 	mov.w	r3, #128	; 0x80
    1b2c:	f383 8811 	msr	BASEPRI, r3
    1b30:	f3bf 8f6f 	isb	sy
    1b34:	f3bf 8f4f 	dsb	sy
    1b38:	e7fe      	b.n	1b38 <xQueueReceive+0x20>
    1b3a:	f04f 0380 	mov.w	r3, #128	; 0x80
    1b3e:	f383 8811 	msr	BASEPRI, r3
    1b42:	f3bf 8f6f 	isb	sy
    1b46:	f3bf 8f4f 	dsb	sy
    1b4a:	e7fe      	b.n	1b4a <xQueueReceive+0x32>
    1b4c:	6c03      	ldr	r3, [r0, #64]	; 0x40
    1b4e:	b90b      	cbnz	r3, 1b54 <xQueueReceive+0x3c>
    1b50:	2501      	movs	r5, #1
    1b52:	e7e8      	b.n	1b26 <xQueueReceive+0xe>
    1b54:	2500      	movs	r5, #0
    1b56:	e7e6      	b.n	1b26 <xQueueReceive+0xe>
    1b58:	460e      	mov	r6, r1
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    1b5a:	4b45      	ldr	r3, [pc, #276]	; (1c70 <xQueueReceive+0x158>)
    1b5c:	4798      	blx	r3
    1b5e:	b910      	cbnz	r0, 1b66 <xQueueReceive+0x4e>
    1b60:	9b01      	ldr	r3, [sp, #4]
    1b62:	b103      	cbz	r3, 1b66 <xQueueReceive+0x4e>
    1b64:	2500      	movs	r5, #0
    1b66:	b945      	cbnz	r5, 1b7a <xQueueReceive+0x62>
    1b68:	f04f 0380 	mov.w	r3, #128	; 0x80
    1b6c:	f383 8811 	msr	BASEPRI, r3
    1b70:	f3bf 8f6f 	isb	sy
    1b74:	f3bf 8f4f 	dsb	sy
    1b78:	e7fe      	b.n	1b78 <xQueueReceive+0x60>
    1b7a:	2700      	movs	r7, #0
    1b7c:	e02f      	b.n	1bde <xQueueReceive+0xc6>
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    1b7e:	4631      	mov	r1, r6
    1b80:	4620      	mov	r0, r4
    1b82:	4b3c      	ldr	r3, [pc, #240]	; (1c74 <xQueueReceive+0x15c>)
    1b84:	4798      	blx	r3
                pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting - ( UBaseType_t ) 1 );
    1b86:	3d01      	subs	r5, #1
    1b88:	63a5      	str	r5, [r4, #56]	; 0x38
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b8a:	6923      	ldr	r3, [r4, #16]
    1b8c:	b163      	cbz	r3, 1ba8 <xQueueReceive+0x90>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1b8e:	f104 0010 	add.w	r0, r4, #16
    1b92:	4b39      	ldr	r3, [pc, #228]	; (1c78 <xQueueReceive+0x160>)
    1b94:	4798      	blx	r3
    1b96:	b138      	cbz	r0, 1ba8 <xQueueReceive+0x90>
                        queueYIELD_IF_USING_PREEMPTION();
    1b98:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    1b9c:	4b37      	ldr	r3, [pc, #220]	; (1c7c <xQueueReceive+0x164>)
    1b9e:	601a      	str	r2, [r3, #0]
    1ba0:	f3bf 8f4f 	dsb	sy
    1ba4:	f3bf 8f6f 	isb	sy
                taskEXIT_CRITICAL();
    1ba8:	4b35      	ldr	r3, [pc, #212]	; (1c80 <xQueueReceive+0x168>)
    1baa:	4798      	blx	r3
                return pdPASS;
    1bac:	2001      	movs	r0, #1
}
    1bae:	b005      	add	sp, #20
    1bb0:	bdf0      	pop	{r4, r5, r6, r7, pc}
                    taskEXIT_CRITICAL();
    1bb2:	4b33      	ldr	r3, [pc, #204]	; (1c80 <xQueueReceive+0x168>)
    1bb4:	4798      	blx	r3
                    return errQUEUE_EMPTY;
    1bb6:	2000      	movs	r0, #0
    1bb8:	e7f9      	b.n	1bae <xQueueReceive+0x96>
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1bba:	a802      	add	r0, sp, #8
    1bbc:	4b31      	ldr	r3, [pc, #196]	; (1c84 <xQueueReceive+0x16c>)
    1bbe:	4798      	blx	r3
                    xEntryTimeSet = pdTRUE;
    1bc0:	2701      	movs	r7, #1
    1bc2:	e016      	b.n	1bf2 <xQueueReceive+0xda>
        prvLockQueue( pxQueue );
    1bc4:	2300      	movs	r3, #0
    1bc6:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
    1bca:	e01e      	b.n	1c0a <xQueueReceive+0xf2>
    1bcc:	2300      	movs	r3, #0
    1bce:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
    1bd2:	e020      	b.n	1c16 <xQueueReceive+0xfe>
                prvUnlockQueue( pxQueue );
    1bd4:	4620      	mov	r0, r4
    1bd6:	4b2c      	ldr	r3, [pc, #176]	; (1c88 <xQueueReceive+0x170>)
    1bd8:	4798      	blx	r3
                ( void ) xTaskResumeAll();
    1bda:	4b2c      	ldr	r3, [pc, #176]	; (1c8c <xQueueReceive+0x174>)
    1bdc:	4798      	blx	r3
        taskENTER_CRITICAL();
    1bde:	4b2c      	ldr	r3, [pc, #176]	; (1c90 <xQueueReceive+0x178>)
    1be0:	4798      	blx	r3
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1be2:	6ba5      	ldr	r5, [r4, #56]	; 0x38
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1be4:	2d00      	cmp	r5, #0
    1be6:	d1ca      	bne.n	1b7e <xQueueReceive+0x66>
                if( xTicksToWait == ( TickType_t ) 0 )
    1be8:	9b01      	ldr	r3, [sp, #4]
    1bea:	2b00      	cmp	r3, #0
    1bec:	d0e1      	beq.n	1bb2 <xQueueReceive+0x9a>
                else if( xEntryTimeSet == pdFALSE )
    1bee:	2f00      	cmp	r7, #0
    1bf0:	d0e3      	beq.n	1bba <xQueueReceive+0xa2>
        taskEXIT_CRITICAL();
    1bf2:	4b23      	ldr	r3, [pc, #140]	; (1c80 <xQueueReceive+0x168>)
    1bf4:	4798      	blx	r3
        vTaskSuspendAll();
    1bf6:	4b27      	ldr	r3, [pc, #156]	; (1c94 <xQueueReceive+0x17c>)
    1bf8:	4798      	blx	r3
        prvLockQueue( pxQueue );
    1bfa:	4b25      	ldr	r3, [pc, #148]	; (1c90 <xQueueReceive+0x178>)
    1bfc:	4798      	blx	r3
    1bfe:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    1c02:	b25b      	sxtb	r3, r3
    1c04:	f1b3 3fff 	cmp.w	r3, #4294967295
    1c08:	d0dc      	beq.n	1bc4 <xQueueReceive+0xac>
    1c0a:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    1c0e:	b25b      	sxtb	r3, r3
    1c10:	f1b3 3fff 	cmp.w	r3, #4294967295
    1c14:	d0da      	beq.n	1bcc <xQueueReceive+0xb4>
    1c16:	4b1a      	ldr	r3, [pc, #104]	; (1c80 <xQueueReceive+0x168>)
    1c18:	4798      	blx	r3
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1c1a:	a901      	add	r1, sp, #4
    1c1c:	a802      	add	r0, sp, #8
    1c1e:	4b1e      	ldr	r3, [pc, #120]	; (1c98 <xQueueReceive+0x180>)
    1c20:	4798      	blx	r3
    1c22:	b9c8      	cbnz	r0, 1c58 <xQueueReceive+0x140>
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1c24:	4620      	mov	r0, r4
    1c26:	4b1d      	ldr	r3, [pc, #116]	; (1c9c <xQueueReceive+0x184>)
    1c28:	4798      	blx	r3
    1c2a:	2800      	cmp	r0, #0
    1c2c:	d0d2      	beq.n	1bd4 <xQueueReceive+0xbc>
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1c2e:	9901      	ldr	r1, [sp, #4]
    1c30:	f104 0024 	add.w	r0, r4, #36	; 0x24
    1c34:	4b1a      	ldr	r3, [pc, #104]	; (1ca0 <xQueueReceive+0x188>)
    1c36:	4798      	blx	r3
                prvUnlockQueue( pxQueue );
    1c38:	4620      	mov	r0, r4
    1c3a:	4b13      	ldr	r3, [pc, #76]	; (1c88 <xQueueReceive+0x170>)
    1c3c:	4798      	blx	r3
                if( xTaskResumeAll() == pdFALSE )
    1c3e:	4b13      	ldr	r3, [pc, #76]	; (1c8c <xQueueReceive+0x174>)
    1c40:	4798      	blx	r3
    1c42:	2800      	cmp	r0, #0
    1c44:	d1cb      	bne.n	1bde <xQueueReceive+0xc6>
                    taskYIELD_WITHIN_API();
    1c46:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    1c4a:	4b0c      	ldr	r3, [pc, #48]	; (1c7c <xQueueReceive+0x164>)
    1c4c:	601a      	str	r2, [r3, #0]
    1c4e:	f3bf 8f4f 	dsb	sy
    1c52:	f3bf 8f6f 	isb	sy
    1c56:	e7c2      	b.n	1bde <xQueueReceive+0xc6>
            prvUnlockQueue( pxQueue );
    1c58:	4620      	mov	r0, r4
    1c5a:	4b0b      	ldr	r3, [pc, #44]	; (1c88 <xQueueReceive+0x170>)
    1c5c:	4798      	blx	r3
            ( void ) xTaskResumeAll();
    1c5e:	4b0b      	ldr	r3, [pc, #44]	; (1c8c <xQueueReceive+0x174>)
    1c60:	4798      	blx	r3
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1c62:	4620      	mov	r0, r4
    1c64:	4b0d      	ldr	r3, [pc, #52]	; (1c9c <xQueueReceive+0x184>)
    1c66:	4798      	blx	r3
    1c68:	2800      	cmp	r0, #0
    1c6a:	d0b8      	beq.n	1bde <xQueueReceive+0xc6>
                return errQUEUE_EMPTY;
    1c6c:	2000      	movs	r0, #0
    1c6e:	e79e      	b.n	1bae <xQueueReceive+0x96>
    1c70:	00002901 	.word	0x00002901
    1c74:	000014cd 	.word	0x000014cd
    1c78:	00002751 	.word	0x00002751
    1c7c:	e000ed04 	.word	0xe000ed04
    1c80:	00000fe9 	.word	0x00000fe9
    1c84:	0000284d 	.word	0x0000284d
    1c88:	0000159d 	.word	0x0000159d
    1c8c:	00002445 	.word	0x00002445
    1c90:	00000fa5 	.word	0x00000fa5
    1c94:	00002295 	.word	0x00002295
    1c98:	00002861 	.word	0x00002861
    1c9c:	00001429 	.word	0x00001429
    1ca0:	000026b1 	.word	0x000026b1

00001ca4 <xQueueSemaphoreTake>:
{
    1ca4:	b570      	push	{r4, r5, r6, lr}
    1ca6:	b084      	sub	sp, #16
    1ca8:	9101      	str	r1, [sp, #4]
    configASSERT( ( pxQueue ) );
    1caa:	b158      	cbz	r0, 1cc4 <xQueueSemaphoreTake+0x20>
    1cac:	4604      	mov	r4, r0
    configASSERT( pxQueue->uxItemSize == 0 );
    1cae:	6c03      	ldr	r3, [r0, #64]	; 0x40
    1cb0:	b18b      	cbz	r3, 1cd6 <xQueueSemaphoreTake+0x32>
    1cb2:	f04f 0380 	mov.w	r3, #128	; 0x80
    1cb6:	f383 8811 	msr	BASEPRI, r3
    1cba:	f3bf 8f6f 	isb	sy
    1cbe:	f3bf 8f4f 	dsb	sy
    1cc2:	e7fe      	b.n	1cc2 <xQueueSemaphoreTake+0x1e>
    1cc4:	f04f 0380 	mov.w	r3, #128	; 0x80
    1cc8:	f383 8811 	msr	BASEPRI, r3
    1ccc:	f3bf 8f6f 	isb	sy
    1cd0:	f3bf 8f4f 	dsb	sy
    1cd4:	e7fe      	b.n	1cd4 <xQueueSemaphoreTake+0x30>
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    1cd6:	4b56      	ldr	r3, [pc, #344]	; (1e30 <xQueueSemaphoreTake+0x18c>)
    1cd8:	4798      	blx	r3
    1cda:	b960      	cbnz	r0, 1cf6 <xQueueSemaphoreTake+0x52>
    1cdc:	9b01      	ldr	r3, [sp, #4]
    1cde:	b963      	cbnz	r3, 1cfa <xQueueSemaphoreTake+0x56>
    1ce0:	2301      	movs	r3, #1
    1ce2:	b963      	cbnz	r3, 1cfe <xQueueSemaphoreTake+0x5a>
    1ce4:	f04f 0380 	mov.w	r3, #128	; 0x80
    1ce8:	f383 8811 	msr	BASEPRI, r3
    1cec:	f3bf 8f6f 	isb	sy
    1cf0:	f3bf 8f4f 	dsb	sy
    1cf4:	e7fe      	b.n	1cf4 <xQueueSemaphoreTake+0x50>
    1cf6:	2301      	movs	r3, #1
    1cf8:	e7f3      	b.n	1ce2 <xQueueSemaphoreTake+0x3e>
    1cfa:	2300      	movs	r3, #0
    1cfc:	e7f1      	b.n	1ce2 <xQueueSemaphoreTake+0x3e>
    1cfe:	2500      	movs	r5, #0
    1d00:	462e      	mov	r6, r5
    1d02:	e045      	b.n	1d90 <xQueueSemaphoreTake+0xec>
                pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxSemaphoreCount - ( UBaseType_t ) 1 );
    1d04:	3b01      	subs	r3, #1
    1d06:	63a3      	str	r3, [r4, #56]	; 0x38
                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1d08:	6823      	ldr	r3, [r4, #0]
    1d0a:	b913      	cbnz	r3, 1d12 <xQueueSemaphoreTake+0x6e>
                        pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
    1d0c:	4b49      	ldr	r3, [pc, #292]	; (1e34 <xQueueSemaphoreTake+0x190>)
    1d0e:	4798      	blx	r3
    1d10:	60a0      	str	r0, [r4, #8]
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1d12:	6923      	ldr	r3, [r4, #16]
    1d14:	b163      	cbz	r3, 1d30 <xQueueSemaphoreTake+0x8c>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1d16:	f104 0010 	add.w	r0, r4, #16
    1d1a:	4b47      	ldr	r3, [pc, #284]	; (1e38 <xQueueSemaphoreTake+0x194>)
    1d1c:	4798      	blx	r3
    1d1e:	b138      	cbz	r0, 1d30 <xQueueSemaphoreTake+0x8c>
                        queueYIELD_IF_USING_PREEMPTION();
    1d20:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    1d24:	4b45      	ldr	r3, [pc, #276]	; (1e3c <xQueueSemaphoreTake+0x198>)
    1d26:	601a      	str	r2, [r3, #0]
    1d28:	f3bf 8f4f 	dsb	sy
    1d2c:	f3bf 8f6f 	isb	sy
                taskEXIT_CRITICAL();
    1d30:	4b43      	ldr	r3, [pc, #268]	; (1e40 <xQueueSemaphoreTake+0x19c>)
    1d32:	4798      	blx	r3
                return pdPASS;
    1d34:	2501      	movs	r5, #1
}
    1d36:	4628      	mov	r0, r5
    1d38:	b004      	add	sp, #16
    1d3a:	bd70      	pop	{r4, r5, r6, pc}
                    taskEXIT_CRITICAL();
    1d3c:	4b40      	ldr	r3, [pc, #256]	; (1e40 <xQueueSemaphoreTake+0x19c>)
    1d3e:	4798      	blx	r3
                    return errQUEUE_EMPTY;
    1d40:	2500      	movs	r5, #0
    1d42:	e7f8      	b.n	1d36 <xQueueSemaphoreTake+0x92>
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1d44:	a802      	add	r0, sp, #8
    1d46:	4b3f      	ldr	r3, [pc, #252]	; (1e44 <xQueueSemaphoreTake+0x1a0>)
    1d48:	4798      	blx	r3
                    xEntryTimeSet = pdTRUE;
    1d4a:	2601      	movs	r6, #1
    1d4c:	e02a      	b.n	1da4 <xQueueSemaphoreTake+0x100>
        prvLockQueue( pxQueue );
    1d4e:	2300      	movs	r3, #0
    1d50:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
    1d54:	e032      	b.n	1dbc <xQueueSemaphoreTake+0x118>
    1d56:	2300      	movs	r3, #0
    1d58:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
    1d5c:	e034      	b.n	1dc8 <xQueueSemaphoreTake+0x124>
                        taskENTER_CRITICAL();
    1d5e:	4b3a      	ldr	r3, [pc, #232]	; (1e48 <xQueueSemaphoreTake+0x1a4>)
    1d60:	4798      	blx	r3
                            xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
    1d62:	68a0      	ldr	r0, [r4, #8]
    1d64:	4b39      	ldr	r3, [pc, #228]	; (1e4c <xQueueSemaphoreTake+0x1a8>)
    1d66:	4798      	blx	r3
    1d68:	4605      	mov	r5, r0
                        taskEXIT_CRITICAL();
    1d6a:	4b35      	ldr	r3, [pc, #212]	; (1e40 <xQueueSemaphoreTake+0x19c>)
    1d6c:	4798      	blx	r3
    1d6e:	e03b      	b.n	1de8 <xQueueSemaphoreTake+0x144>
                prvUnlockQueue( pxQueue );
    1d70:	4620      	mov	r0, r4
    1d72:	4b37      	ldr	r3, [pc, #220]	; (1e50 <xQueueSemaphoreTake+0x1ac>)
    1d74:	4798      	blx	r3
                ( void ) xTaskResumeAll();
    1d76:	4b37      	ldr	r3, [pc, #220]	; (1e54 <xQueueSemaphoreTake+0x1b0>)
    1d78:	4798      	blx	r3
    1d7a:	e009      	b.n	1d90 <xQueueSemaphoreTake+0xec>
            prvUnlockQueue( pxQueue );
    1d7c:	4620      	mov	r0, r4
    1d7e:	4b34      	ldr	r3, [pc, #208]	; (1e50 <xQueueSemaphoreTake+0x1ac>)
    1d80:	4798      	blx	r3
            ( void ) xTaskResumeAll();
    1d82:	4b34      	ldr	r3, [pc, #208]	; (1e54 <xQueueSemaphoreTake+0x1b0>)
    1d84:	4798      	blx	r3
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1d86:	4620      	mov	r0, r4
    1d88:	4b33      	ldr	r3, [pc, #204]	; (1e58 <xQueueSemaphoreTake+0x1b4>)
    1d8a:	4798      	blx	r3
    1d8c:	2800      	cmp	r0, #0
    1d8e:	d140      	bne.n	1e12 <xQueueSemaphoreTake+0x16e>
        taskENTER_CRITICAL();
    1d90:	4b2d      	ldr	r3, [pc, #180]	; (1e48 <xQueueSemaphoreTake+0x1a4>)
    1d92:	4798      	blx	r3
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1d94:	6ba3      	ldr	r3, [r4, #56]	; 0x38
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    1d96:	2b00      	cmp	r3, #0
    1d98:	d1b4      	bne.n	1d04 <xQueueSemaphoreTake+0x60>
                if( xTicksToWait == ( TickType_t ) 0 )
    1d9a:	9b01      	ldr	r3, [sp, #4]
    1d9c:	2b00      	cmp	r3, #0
    1d9e:	d0cd      	beq.n	1d3c <xQueueSemaphoreTake+0x98>
                else if( xEntryTimeSet == pdFALSE )
    1da0:	2e00      	cmp	r6, #0
    1da2:	d0cf      	beq.n	1d44 <xQueueSemaphoreTake+0xa0>
        taskEXIT_CRITICAL();
    1da4:	4b26      	ldr	r3, [pc, #152]	; (1e40 <xQueueSemaphoreTake+0x19c>)
    1da6:	4798      	blx	r3
        vTaskSuspendAll();
    1da8:	4b2c      	ldr	r3, [pc, #176]	; (1e5c <xQueueSemaphoreTake+0x1b8>)
    1daa:	4798      	blx	r3
        prvLockQueue( pxQueue );
    1dac:	4b26      	ldr	r3, [pc, #152]	; (1e48 <xQueueSemaphoreTake+0x1a4>)
    1dae:	4798      	blx	r3
    1db0:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    1db4:	b25b      	sxtb	r3, r3
    1db6:	f1b3 3fff 	cmp.w	r3, #4294967295
    1dba:	d0c8      	beq.n	1d4e <xQueueSemaphoreTake+0xaa>
    1dbc:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    1dc0:	b25b      	sxtb	r3, r3
    1dc2:	f1b3 3fff 	cmp.w	r3, #4294967295
    1dc6:	d0c6      	beq.n	1d56 <xQueueSemaphoreTake+0xb2>
    1dc8:	4b1d      	ldr	r3, [pc, #116]	; (1e40 <xQueueSemaphoreTake+0x19c>)
    1dca:	4798      	blx	r3
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1dcc:	a901      	add	r1, sp, #4
    1dce:	a802      	add	r0, sp, #8
    1dd0:	4b23      	ldr	r3, [pc, #140]	; (1e60 <xQueueSemaphoreTake+0x1bc>)
    1dd2:	4798      	blx	r3
    1dd4:	2800      	cmp	r0, #0
    1dd6:	d1d1      	bne.n	1d7c <xQueueSemaphoreTake+0xd8>
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1dd8:	4620      	mov	r0, r4
    1dda:	4b1f      	ldr	r3, [pc, #124]	; (1e58 <xQueueSemaphoreTake+0x1b4>)
    1ddc:	4798      	blx	r3
    1dde:	2800      	cmp	r0, #0
    1de0:	d0c6      	beq.n	1d70 <xQueueSemaphoreTake+0xcc>
                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1de2:	6823      	ldr	r3, [r4, #0]
    1de4:	2b00      	cmp	r3, #0
    1de6:	d0ba      	beq.n	1d5e <xQueueSemaphoreTake+0xba>
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1de8:	9901      	ldr	r1, [sp, #4]
    1dea:	f104 0024 	add.w	r0, r4, #36	; 0x24
    1dee:	4b1d      	ldr	r3, [pc, #116]	; (1e64 <xQueueSemaphoreTake+0x1c0>)
    1df0:	4798      	blx	r3
                prvUnlockQueue( pxQueue );
    1df2:	4620      	mov	r0, r4
    1df4:	4b16      	ldr	r3, [pc, #88]	; (1e50 <xQueueSemaphoreTake+0x1ac>)
    1df6:	4798      	blx	r3
                if( xTaskResumeAll() == pdFALSE )
    1df8:	4b16      	ldr	r3, [pc, #88]	; (1e54 <xQueueSemaphoreTake+0x1b0>)
    1dfa:	4798      	blx	r3
    1dfc:	2800      	cmp	r0, #0
    1dfe:	d1c7      	bne.n	1d90 <xQueueSemaphoreTake+0xec>
                    taskYIELD_WITHIN_API();
    1e00:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    1e04:	4b0d      	ldr	r3, [pc, #52]	; (1e3c <xQueueSemaphoreTake+0x198>)
    1e06:	601a      	str	r2, [r3, #0]
    1e08:	f3bf 8f4f 	dsb	sy
    1e0c:	f3bf 8f6f 	isb	sy
    1e10:	e7be      	b.n	1d90 <xQueueSemaphoreTake+0xec>
                    if( xInheritanceOccurred != pdFALSE )
    1e12:	2d00      	cmp	r5, #0
    1e14:	d08f      	beq.n	1d36 <xQueueSemaphoreTake+0x92>
                        taskENTER_CRITICAL();
    1e16:	4b0c      	ldr	r3, [pc, #48]	; (1e48 <xQueueSemaphoreTake+0x1a4>)
    1e18:	4798      	blx	r3
                            uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
    1e1a:	4620      	mov	r0, r4
    1e1c:	4b12      	ldr	r3, [pc, #72]	; (1e68 <xQueueSemaphoreTake+0x1c4>)
    1e1e:	4798      	blx	r3
                            vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
    1e20:	4601      	mov	r1, r0
    1e22:	68a0      	ldr	r0, [r4, #8]
    1e24:	4b11      	ldr	r3, [pc, #68]	; (1e6c <xQueueSemaphoreTake+0x1c8>)
    1e26:	4798      	blx	r3
                        taskEXIT_CRITICAL();
    1e28:	4b05      	ldr	r3, [pc, #20]	; (1e40 <xQueueSemaphoreTake+0x19c>)
    1e2a:	4798      	blx	r3
                return errQUEUE_EMPTY;
    1e2c:	2500      	movs	r5, #0
    1e2e:	e782      	b.n	1d36 <xQueueSemaphoreTake+0x92>
    1e30:	00002901 	.word	0x00002901
    1e34:	00002b6d 	.word	0x00002b6d
    1e38:	00002751 	.word	0x00002751
    1e3c:	e000ed04 	.word	0xe000ed04
    1e40:	00000fe9 	.word	0x00000fe9
    1e44:	0000284d 	.word	0x0000284d
    1e48:	00000fa5 	.word	0x00000fa5
    1e4c:	00002921 	.word	0x00002921
    1e50:	0000159d 	.word	0x0000159d
    1e54:	00002445 	.word	0x00002445
    1e58:	00001429 	.word	0x00001429
    1e5c:	00002295 	.word	0x00002295
    1e60:	00002861 	.word	0x00002861
    1e64:	000026b1 	.word	0x000026b1
    1e68:	000013ed 	.word	0x000013ed
    1e6c:	00002aa1 	.word	0x00002aa1

00001e70 <vQueueDelete>:
{
    1e70:	b508      	push	{r3, lr}
    configASSERT( pxQueue );
    1e72:	b118      	cbz	r0, 1e7c <vQueueDelete+0xc>
        if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
    1e74:	f890 2046 	ldrb.w	r2, [r0, #70]	; 0x46
    1e78:	b14a      	cbz	r2, 1e8e <vQueueDelete+0x1e>
    1e7a:	bd08      	pop	{r3, pc}
    1e7c:	f04f 0380 	mov.w	r3, #128	; 0x80
    1e80:	f383 8811 	msr	BASEPRI, r3
    1e84:	f3bf 8f6f 	isb	sy
    1e88:	f3bf 8f4f 	dsb	sy
    1e8c:	e7fe      	b.n	1e8c <vQueueDelete+0x1c>
            vPortFree( pxQueue );
    1e8e:	4b01      	ldr	r3, [pc, #4]	; (1e94 <vQueueDelete+0x24>)
    1e90:	4798      	blx	r3
}
    1e92:	e7f2      	b.n	1e7a <vQueueDelete+0xa>
    1e94:	00001365 	.word	0x00001365

00001e98 <vQueueWaitForMessageRestricted>:
    {
    1e98:	b570      	push	{r4, r5, r6, lr}
    1e9a:	4604      	mov	r4, r0
    1e9c:	460d      	mov	r5, r1
    1e9e:	4616      	mov	r6, r2
        prvLockQueue( pxQueue );
    1ea0:	4b12      	ldr	r3, [pc, #72]	; (1eec <vQueueWaitForMessageRestricted+0x54>)
    1ea2:	4798      	blx	r3
    1ea4:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    1ea8:	b25b      	sxtb	r3, r3
    1eaa:	f1b3 3fff 	cmp.w	r3, #4294967295
    1eae:	d00d      	beq.n	1ecc <vQueueWaitForMessageRestricted+0x34>
    1eb0:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    1eb4:	b25b      	sxtb	r3, r3
    1eb6:	f1b3 3fff 	cmp.w	r3, #4294967295
    1eba:	d00b      	beq.n	1ed4 <vQueueWaitForMessageRestricted+0x3c>
    1ebc:	4b0c      	ldr	r3, [pc, #48]	; (1ef0 <vQueueWaitForMessageRestricted+0x58>)
    1ebe:	4798      	blx	r3
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1ec0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    1ec2:	b15b      	cbz	r3, 1edc <vQueueWaitForMessageRestricted+0x44>
        prvUnlockQueue( pxQueue );
    1ec4:	4620      	mov	r0, r4
    1ec6:	4b0b      	ldr	r3, [pc, #44]	; (1ef4 <vQueueWaitForMessageRestricted+0x5c>)
    1ec8:	4798      	blx	r3
    1eca:	bd70      	pop	{r4, r5, r6, pc}
        prvLockQueue( pxQueue );
    1ecc:	2300      	movs	r3, #0
    1ece:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
    1ed2:	e7ed      	b.n	1eb0 <vQueueWaitForMessageRestricted+0x18>
    1ed4:	2300      	movs	r3, #0
    1ed6:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
    1eda:	e7ef      	b.n	1ebc <vQueueWaitForMessageRestricted+0x24>
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    1edc:	4632      	mov	r2, r6
    1ede:	4629      	mov	r1, r5
    1ee0:	f104 0024 	add.w	r0, r4, #36	; 0x24
    1ee4:	4b04      	ldr	r3, [pc, #16]	; (1ef8 <vQueueWaitForMessageRestricted+0x60>)
    1ee6:	4798      	blx	r3
    1ee8:	e7ec      	b.n	1ec4 <vQueueWaitForMessageRestricted+0x2c>
    1eea:	bf00      	nop
    1eec:	00000fa5 	.word	0x00000fa5
    1ef0:	00000fe9 	.word	0x00000fe9
    1ef4:	0000159d 	.word	0x0000159d
    1ef8:	000026ed 	.word	0x000026ed

00001efc <prvIdleTask>:
             * A critical region is not required here as we are just reading from
             * the list, and an occasional incorrect value will not matter.  If
             * the ready list at the idle priority contains one more task than the
             * number of idle tasks, which is equal to the configured numbers of cores
             * then a task other than the idle task is ready to execute. */
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) configNUMBER_OF_CORES )
    1efc:	4b06      	ldr	r3, [pc, #24]	; (1f18 <prvIdleTask+0x1c>)
    1efe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1f00:	2b01      	cmp	r3, #1
    1f02:	d9fb      	bls.n	1efc <prvIdleTask>
            {
                taskYIELD();
    1f04:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    1f08:	4b04      	ldr	r3, [pc, #16]	; (1f1c <prvIdleTask+0x20>)
    1f0a:	601a      	str	r2, [r3, #0]
    1f0c:	f3bf 8f4f 	dsb	sy
    1f10:	f3bf 8f6f 	isb	sy
    1f14:	e7f2      	b.n	1efc <prvIdleTask>
    1f16:	bf00      	nop
    1f18:	20000afc 	.word	0x20000afc
    1f1c:	e000ed04 	.word	0xe000ed04

00001f20 <prvResetNextTaskUnblockTime>:
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1f20:	4b09      	ldr	r3, [pc, #36]	; (1f48 <prvResetNextTaskUnblockTime+0x28>)
    1f22:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
    1f26:	681b      	ldr	r3, [r3, #0]
    1f28:	b13b      	cbz	r3, 1f3a <prvResetNextTaskUnblockTime+0x1a>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    1f2a:	4b07      	ldr	r3, [pc, #28]	; (1f48 <prvResetNextTaskUnblockTime+0x28>)
    1f2c:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
    1f30:	68d2      	ldr	r2, [r2, #12]
    1f32:	6812      	ldr	r2, [r2, #0]
    1f34:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    1f38:	4770      	bx	lr
        xNextTaskUnblockTime = portMAX_DELAY;
    1f3a:	f04f 32ff 	mov.w	r2, #4294967295
    1f3e:	4b02      	ldr	r3, [pc, #8]	; (1f48 <prvResetNextTaskUnblockTime+0x28>)
    1f40:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    1f44:	4770      	bx	lr
    1f46:	bf00      	nop
    1f48:	20000afc 	.word	0x20000afc

00001f4c <prvInitialiseNewTask>:
{
    1f4c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    1f50:	4680      	mov	r8, r0
    1f52:	468a      	mov	sl, r1
    1f54:	4616      	mov	r6, r2
    1f56:	4699      	mov	r9, r3
    1f58:	9d08      	ldr	r5, [sp, #32]
    1f5a:	9f09      	ldr	r7, [sp, #36]	; 0x24
    1f5c:	9c0a      	ldr	r4, [sp, #40]	; 0x28
        ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) uxStackDepth * sizeof( StackType_t ) );
    1f5e:	0092      	lsls	r2, r2, #2
    1f60:	21a5      	movs	r1, #165	; 0xa5
    1f62:	6b20      	ldr	r0, [r4, #48]	; 0x30
    1f64:	4b1f      	ldr	r3, [pc, #124]	; (1fe4 <prvInitialiseNewTask+0x98>)
    1f66:	4798      	blx	r3
        pxTopOfStack = &( pxNewTCB->pxStack[ uxStackDepth - ( configSTACK_DEPTH_TYPE ) 1 ] );
    1f68:	6b22      	ldr	r2, [r4, #48]	; 0x30
    1f6a:	f106 4380 	add.w	r3, r6, #1073741824	; 0x40000000
    1f6e:	3b01      	subs	r3, #1
    1f70:	eb02 0383 	add.w	r3, r2, r3, lsl #2
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1f74:	f023 0607 	bic.w	r6, r3, #7
    if( pcName != NULL )
    1f78:	f1ba 0f00 	cmp.w	sl, #0
    1f7c:	d00f      	beq.n	1f9e <prvInitialiseNewTask+0x52>
    1f7e:	2300      	movs	r3, #0
    1f80:	e008      	b.n	1f94 <prvInitialiseNewTask+0x48>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    1f82:	f81a 1003 	ldrb.w	r1, [sl, r3]
    1f86:	18e2      	adds	r2, r4, r3
    1f88:	f882 1034 	strb.w	r1, [r2, #52]	; 0x34
            if( pcName[ x ] == ( char ) 0x00 )
    1f8c:	f81a 2003 	ldrb.w	r2, [sl, r3]
    1f90:	b112      	cbz	r2, 1f98 <prvInitialiseNewTask+0x4c>
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1f92:	3301      	adds	r3, #1
    1f94:	2b07      	cmp	r3, #7
    1f96:	d9f4      	bls.n	1f82 <prvInitialiseNewTask+0x36>
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1U ] = '\0';
    1f98:	2300      	movs	r3, #0
    1f9a:	f884 303b 	strb.w	r3, [r4, #59]	; 0x3b
    configASSERT( uxPriority < configMAX_PRIORITIES );
    1f9e:	2d04      	cmp	r5, #4
    1fa0:	d908      	bls.n	1fb4 <prvInitialiseNewTask+0x68>
    1fa2:	f04f 0380 	mov.w	r3, #128	; 0x80
    1fa6:	f383 8811 	msr	BASEPRI, r3
    1faa:	f3bf 8f6f 	isb	sy
    1fae:	f3bf 8f4f 	dsb	sy
    1fb2:	e7fe      	b.n	1fb2 <prvInitialiseNewTask+0x66>
    pxNewTCB->uxPriority = uxPriority;
    1fb4:	62e5      	str	r5, [r4, #44]	; 0x2c
        pxNewTCB->uxBasePriority = uxPriority;
    1fb6:	6465      	str	r5, [r4, #68]	; 0x44
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    1fb8:	1d20      	adds	r0, r4, #4
    1fba:	f8df a030 	ldr.w	sl, [pc, #48]	; 1fec <prvInitialiseNewTask+0xa0>
    1fbe:	47d0      	blx	sl
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    1fc0:	f104 0018 	add.w	r0, r4, #24
    1fc4:	47d0      	blx	sl
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    1fc6:	6124      	str	r4, [r4, #16]
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority );
    1fc8:	f1c5 0505 	rsb	r5, r5, #5
    1fcc:	61a5      	str	r5, [r4, #24]
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    1fce:	6264      	str	r4, [r4, #36]	; 0x24
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1fd0:	464a      	mov	r2, r9
    1fd2:	4641      	mov	r1, r8
    1fd4:	4630      	mov	r0, r6
    1fd6:	4b04      	ldr	r3, [pc, #16]	; (1fe8 <prvInitialiseNewTask+0x9c>)
    1fd8:	4798      	blx	r3
    1fda:	6020      	str	r0, [r4, #0]
    if( pxCreatedTask != NULL )
    1fdc:	b107      	cbz	r7, 1fe0 <prvInitialiseNewTask+0x94>
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1fde:	603c      	str	r4, [r7, #0]
    1fe0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1fe4:	000030cb 	.word	0x000030cb
    1fe8:	00000f79 	.word	0x00000f79
    1fec:	00000e0b 	.word	0x00000e0b

00001ff0 <prvCreateStaticTask>:
    {
    1ff0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    1ff4:	b087      	sub	sp, #28
    1ff6:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
    1ff8:	9c10      	ldr	r4, [sp, #64]	; 0x40
        configASSERT( puxStackBuffer != NULL );
    1ffa:	b176      	cbz	r6, 201a <prvCreateStaticTask+0x2a>
        configASSERT( pxTaskBuffer != NULL );
    1ffc:	b1b4      	cbz	r4, 202c <prvCreateStaticTask+0x3c>
            volatile size_t xSize = sizeof( StaticTask_t );
    1ffe:	2554      	movs	r5, #84	; 0x54
    2000:	9505      	str	r5, [sp, #20]
            configASSERT( xSize == sizeof( TCB_t ) );
    2002:	9d05      	ldr	r5, [sp, #20]
    2004:	2d54      	cmp	r5, #84	; 0x54
    2006:	d01a      	beq.n	203e <prvCreateStaticTask+0x4e>
    2008:	f04f 0380 	mov.w	r3, #128	; 0x80
    200c:	f383 8811 	msr	BASEPRI, r3
    2010:	f3bf 8f6f 	isb	sy
    2014:	f3bf 8f4f 	dsb	sy
    2018:	e7fe      	b.n	2018 <prvCreateStaticTask+0x28>
    201a:	f04f 0380 	mov.w	r3, #128	; 0x80
    201e:	f383 8811 	msr	BASEPRI, r3
    2022:	f3bf 8f6f 	isb	sy
    2026:	f3bf 8f4f 	dsb	sy
    202a:	e7fe      	b.n	202a <prvCreateStaticTask+0x3a>
    202c:	f04f 0380 	mov.w	r3, #128	; 0x80
    2030:	f383 8811 	msr	BASEPRI, r3
    2034:	f3bf 8f6f 	isb	sy
    2038:	f3bf 8f4f 	dsb	sy
    203c:	e7fe      	b.n	203c <prvCreateStaticTask+0x4c>
    203e:	4698      	mov	r8, r3
    2040:	4617      	mov	r7, r2
    2042:	4689      	mov	r9, r1
    2044:	4605      	mov	r5, r0
            ( void ) xSize; /* Prevent unused variable warning when configASSERT() is not used. */
    2046:	9b05      	ldr	r3, [sp, #20]
            ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
    2048:	2254      	movs	r2, #84	; 0x54
    204a:	2100      	movs	r1, #0
    204c:	4620      	mov	r0, r4
    204e:	4b0b      	ldr	r3, [pc, #44]	; (207c <prvCreateStaticTask+0x8c>)
    2050:	4798      	blx	r3
            pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
    2052:	6326      	str	r6, [r4, #48]	; 0x30
                pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
    2054:	2302      	movs	r3, #2
    2056:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
            prvInitialiseNewTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    205a:	2300      	movs	r3, #0
    205c:	9303      	str	r3, [sp, #12]
    205e:	9402      	str	r4, [sp, #8]
    2060:	9b11      	ldr	r3, [sp, #68]	; 0x44
    2062:	9301      	str	r3, [sp, #4]
    2064:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    2066:	9300      	str	r3, [sp, #0]
    2068:	4643      	mov	r3, r8
    206a:	463a      	mov	r2, r7
    206c:	4649      	mov	r1, r9
    206e:	4628      	mov	r0, r5
    2070:	4d03      	ldr	r5, [pc, #12]	; (2080 <prvCreateStaticTask+0x90>)
    2072:	47a8      	blx	r5
    }
    2074:	4620      	mov	r0, r4
    2076:	b007      	add	sp, #28
    2078:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    207c:	000030cb 	.word	0x000030cb
    2080:	00001f4d 	.word	0x00001f4d

00002084 <prvInitialiseTaskLists>:
{
    2084:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    2086:	2400      	movs	r4, #0
    2088:	e007      	b.n	209a <prvInitialiseTaskLists+0x16>
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    208a:	eb04 0284 	add.w	r2, r4, r4, lsl #2
    208e:	0093      	lsls	r3, r2, #2
    2090:	480d      	ldr	r0, [pc, #52]	; (20c8 <prvInitialiseTaskLists+0x44>)
    2092:	4418      	add	r0, r3
    2094:	4b0d      	ldr	r3, [pc, #52]	; (20cc <prvInitialiseTaskLists+0x48>)
    2096:	4798      	blx	r3
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    2098:	3401      	adds	r4, #1
    209a:	2c04      	cmp	r4, #4
    209c:	d9f5      	bls.n	208a <prvInitialiseTaskLists+0x6>
    vListInitialise( &xDelayedTaskList1 );
    209e:	4c0c      	ldr	r4, [pc, #48]	; (20d0 <prvInitialiseTaskLists+0x4c>)
    20a0:	f104 0794 	add.w	r7, r4, #148	; 0x94
    20a4:	4638      	mov	r0, r7
    20a6:	4d09      	ldr	r5, [pc, #36]	; (20cc <prvInitialiseTaskLists+0x48>)
    20a8:	47a8      	blx	r5
    vListInitialise( &xDelayedTaskList2 );
    20aa:	f104 06a8 	add.w	r6, r4, #168	; 0xa8
    20ae:	4630      	mov	r0, r6
    20b0:	47a8      	blx	r5
    vListInitialise( &xPendingReadyList );
    20b2:	f104 0014 	add.w	r0, r4, #20
    20b6:	47a8      	blx	r5
        vListInitialise( &xSuspendedTaskList );
    20b8:	4620      	mov	r0, r4
    20ba:	47a8      	blx	r5
    pxDelayedTaskList = &xDelayedTaskList1;
    20bc:	f8c4 708c 	str.w	r7, [r4, #140]	; 0x8c
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    20c0:	f8c4 60bc 	str.w	r6, [r4, #188]	; 0xbc
    20c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    20c6:	bf00      	nop
    20c8:	20000b24 	.word	0x20000b24
    20cc:	00000df5 	.word	0x00000df5
    20d0:	20000afc 	.word	0x20000afc

000020d4 <prvAddNewTaskToReadyList>:
    {
    20d4:	b570      	push	{r4, r5, r6, lr}
    20d6:	4604      	mov	r4, r0
        taskENTER_CRITICAL();
    20d8:	4b31      	ldr	r3, [pc, #196]	; (21a0 <prvAddNewTaskToReadyList+0xcc>)
    20da:	4798      	blx	r3
            uxCurrentNumberOfTasks = ( UBaseType_t ) ( uxCurrentNumberOfTasks + 1U );
    20dc:	4b31      	ldr	r3, [pc, #196]	; (21a4 <prvAddNewTaskToReadyList+0xd0>)
    20de:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
    20e2:	3201      	adds	r2, #1
    20e4:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
            if( pxCurrentTCB == NULL )
    20e8:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
    20ec:	2b00      	cmp	r3, #0
    20ee:	d04d      	beq.n	218c <prvAddNewTaskToReadyList+0xb8>
                if( xSchedulerRunning == pdFALSE )
    20f0:	4b2c      	ldr	r3, [pc, #176]	; (21a4 <prvAddNewTaskToReadyList+0xd0>)
    20f2:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
    20f6:	b94b      	cbnz	r3, 210c <prvAddNewTaskToReadyList+0x38>
                    if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    20f8:	4b2a      	ldr	r3, [pc, #168]	; (21a4 <prvAddNewTaskToReadyList+0xd0>)
    20fa:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
    20fe:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2100:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    2102:	429a      	cmp	r2, r3
    2104:	d802      	bhi.n	210c <prvAddNewTaskToReadyList+0x38>
                        pxCurrentTCB = pxNewTCB;
    2106:	4b27      	ldr	r3, [pc, #156]	; (21a4 <prvAddNewTaskToReadyList+0xd0>)
    2108:	f8c3 40c4 	str.w	r4, [r3, #196]	; 0xc4
            uxTaskNumber++;
    210c:	4a25      	ldr	r2, [pc, #148]	; (21a4 <prvAddNewTaskToReadyList+0xd0>)
    210e:	f8d2 30cc 	ldr.w	r3, [r2, #204]	; 0xcc
    2112:	3301      	adds	r3, #1
    2114:	f8c2 30cc 	str.w	r3, [r2, #204]	; 0xcc
                pxNewTCB->uxTCBNumber = uxTaskNumber;
    2118:	63e3      	str	r3, [r4, #60]	; 0x3c
            prvAddTaskToReadyList( pxNewTCB );
    211a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    211c:	f8d2 20d0 	ldr.w	r2, [r2, #208]	; 0xd0
    2120:	4293      	cmp	r3, r2
    2122:	d902      	bls.n	212a <prvAddNewTaskToReadyList+0x56>
    2124:	4a1f      	ldr	r2, [pc, #124]	; (21a4 <prvAddNewTaskToReadyList+0xd0>)
    2126:	f8c2 30d0 	str.w	r3, [r2, #208]	; 0xd0
    212a:	4d1e      	ldr	r5, [pc, #120]	; (21a4 <prvAddNewTaskToReadyList+0xd0>)
    212c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    2130:	009a      	lsls	r2, r3, #2
    2132:	442a      	add	r2, r5
    2134:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    2136:	60a3      	str	r3, [r4, #8]
    2138:	689a      	ldr	r2, [r3, #8]
    213a:	60e2      	str	r2, [r4, #12]
    213c:	6899      	ldr	r1, [r3, #8]
    213e:	1d22      	adds	r2, r4, #4
    2140:	604a      	str	r2, [r1, #4]
    2142:	609a      	str	r2, [r3, #8]
    2144:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    2146:	f105 0128 	add.w	r1, r5, #40	; 0x28
    214a:	0093      	lsls	r3, r2, #2
    214c:	189e      	adds	r6, r3, r2
    214e:	00b0      	lsls	r0, r6, #2
    2150:	4606      	mov	r6, r0
    2152:	4401      	add	r1, r0
    2154:	6161      	str	r1, [r4, #20]
    2156:	4631      	mov	r1, r6
    2158:	4429      	add	r1, r5
    215a:	6a89      	ldr	r1, [r1, #40]	; 0x28
    215c:	3101      	adds	r1, #1
    215e:	4632      	mov	r2, r6
    2160:	442a      	add	r2, r5
    2162:	6291      	str	r1, [r2, #40]	; 0x28
        taskEXIT_CRITICAL();
    2164:	4b10      	ldr	r3, [pc, #64]	; (21a8 <prvAddNewTaskToReadyList+0xd4>)
    2166:	4798      	blx	r3
        if( xSchedulerRunning != pdFALSE )
    2168:	f8d5 30c8 	ldr.w	r3, [r5, #200]	; 0xc8
    216c:	b16b      	cbz	r3, 218a <prvAddNewTaskToReadyList+0xb6>
            taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxNewTCB );
    216e:	f8d5 30c4 	ldr.w	r3, [r5, #196]	; 0xc4
    2172:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2174:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    2176:	429a      	cmp	r2, r3
    2178:	d207      	bcs.n	218a <prvAddNewTaskToReadyList+0xb6>
    217a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    217e:	4b0b      	ldr	r3, [pc, #44]	; (21ac <prvAddNewTaskToReadyList+0xd8>)
    2180:	601a      	str	r2, [r3, #0]
    2182:	f3bf 8f4f 	dsb	sy
    2186:	f3bf 8f6f 	isb	sy
    218a:	bd70      	pop	{r4, r5, r6, pc}
                pxCurrentTCB = pxNewTCB;
    218c:	4b05      	ldr	r3, [pc, #20]	; (21a4 <prvAddNewTaskToReadyList+0xd0>)
    218e:	f8c3 40c4 	str.w	r4, [r3, #196]	; 0xc4
                if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    2192:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
    2196:	2b01      	cmp	r3, #1
    2198:	d1b8      	bne.n	210c <prvAddNewTaskToReadyList+0x38>
                    prvInitialiseTaskLists();
    219a:	4b05      	ldr	r3, [pc, #20]	; (21b0 <prvAddNewTaskToReadyList+0xdc>)
    219c:	4798      	blx	r3
    219e:	e7b5      	b.n	210c <prvAddNewTaskToReadyList+0x38>
    21a0:	00000fa5 	.word	0x00000fa5
    21a4:	20000afc 	.word	0x20000afc
    21a8:	00000fe9 	.word	0x00000fe9
    21ac:	e000ed04 	.word	0xe000ed04
    21b0:	00002085 	.word	0x00002085

000021b4 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    21b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    21b8:	4604      	mov	r4, r0
    21ba:	4688      	mov	r8, r1
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    21bc:	4b25      	ldr	r3, [pc, #148]	; (2254 <prvAddCurrentTaskToDelayedList+0xa0>)
    21be:	f8d3 50d4 	ldr.w	r5, [r3, #212]	; 0xd4
    List_t * const pxDelayedList = pxDelayedTaskList;
    21c2:	f8d3 608c 	ldr.w	r6, [r3, #140]	; 0x8c
    List_t * const pxOverflowDelayedList = pxOverflowDelayedTaskList;
    21c6:	f8d3 70bc 	ldr.w	r7, [r3, #188]	; 0xbc
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    21ca:	f8d3 00c4 	ldr.w	r0, [r3, #196]	; 0xc4
    21ce:	3004      	adds	r0, #4
    21d0:	4b21      	ldr	r3, [pc, #132]	; (2258 <prvAddCurrentTaskToDelayedList+0xa4>)
    21d2:	4798      	blx	r3
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    21d4:	f1b4 3fff 	cmp.w	r4, #4294967295
    21d8:	d015      	beq.n	2206 <prvAddCurrentTaskToDelayedList+0x52>
        else
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the
             * kernel will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
    21da:	442c      	add	r4, r5

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    21dc:	4b1d      	ldr	r3, [pc, #116]	; (2254 <prvAddCurrentTaskToDelayedList+0xa0>)
    21de:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
    21e2:	605c      	str	r4, [r3, #4]

            if( xTimeToWake < xConstTickCount )
    21e4:	42a5      	cmp	r5, r4
    21e6:	d82b      	bhi.n	2240 <prvAddCurrentTaskToDelayedList+0x8c>
            else
            {
                /* The wake time has not overflowed, so the current block list
                 * is used. */
                traceMOVED_TASK_TO_DELAYED_LIST();
                vListInsert( pxDelayedList, &( pxCurrentTCB->xStateListItem ) );
    21e8:	4d1a      	ldr	r5, [pc, #104]	; (2254 <prvAddCurrentTaskToDelayedList+0xa0>)
    21ea:	f8d5 10c4 	ldr.w	r1, [r5, #196]	; 0xc4
    21ee:	3104      	adds	r1, #4
    21f0:	4630      	mov	r0, r6
    21f2:	4b1a      	ldr	r3, [pc, #104]	; (225c <prvAddCurrentTaskToDelayedList+0xa8>)
    21f4:	4798      	blx	r3

                /* If the task entering the blocked state was placed at the
                 * head of the list of blocked tasks then xNextTaskUnblockTime
                 * needs to be updated too. */
                if( xTimeToWake < xNextTaskUnblockTime )
    21f6:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
    21fa:	429c      	cmp	r4, r3
    21fc:	d201      	bcs.n	2202 <prvAddCurrentTaskToDelayedList+0x4e>
                {
                    xNextTaskUnblockTime = xTimeToWake;
    21fe:	f8c5 4090 	str.w	r4, [r5, #144]	; 0x90
    2202:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    2206:	f1b8 0f00 	cmp.w	r8, #0
    220a:	d0e6      	beq.n	21da <prvAddCurrentTaskToDelayedList+0x26>
            listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    220c:	4b11      	ldr	r3, [pc, #68]	; (2254 <prvAddCurrentTaskToDelayedList+0xa0>)
    220e:	685a      	ldr	r2, [r3, #4]
    2210:	f8d3 10c4 	ldr.w	r1, [r3, #196]	; 0xc4
    2214:	608a      	str	r2, [r1, #8]
    2216:	f8d3 10c4 	ldr.w	r1, [r3, #196]	; 0xc4
    221a:	6890      	ldr	r0, [r2, #8]
    221c:	60c8      	str	r0, [r1, #12]
    221e:	6890      	ldr	r0, [r2, #8]
    2220:	f8d3 10c4 	ldr.w	r1, [r3, #196]	; 0xc4
    2224:	3104      	adds	r1, #4
    2226:	6041      	str	r1, [r0, #4]
    2228:	f8d3 10c4 	ldr.w	r1, [r3, #196]	; 0xc4
    222c:	3104      	adds	r1, #4
    222e:	6091      	str	r1, [r2, #8]
    2230:	f8d3 20c4 	ldr.w	r2, [r3, #196]	; 0xc4
    2234:	6153      	str	r3, [r2, #20]
    2236:	681a      	ldr	r2, [r3, #0]
    2238:	3201      	adds	r2, #1
    223a:	601a      	str	r2, [r3, #0]
    223c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                vListInsert( pxOverflowDelayedList, &( pxCurrentTCB->xStateListItem ) );
    2240:	4b04      	ldr	r3, [pc, #16]	; (2254 <prvAddCurrentTaskToDelayedList+0xa0>)
    2242:	f8d3 10c4 	ldr.w	r1, [r3, #196]	; 0xc4
    2246:	3104      	adds	r1, #4
    2248:	4638      	mov	r0, r7
    224a:	4b04      	ldr	r3, [pc, #16]	; (225c <prvAddCurrentTaskToDelayedList+0xa8>)
    224c:	4798      	blx	r3
    224e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2252:	bf00      	nop
    2254:	20000afc 	.word	0x20000afc
    2258:	00000e45 	.word	0x00000e45
    225c:	00000e11 	.word	0x00000e11

00002260 <xTaskCreateStatic>:
    {
    2260:	b530      	push	{r4, r5, lr}
    2262:	b087      	sub	sp, #28
        TaskHandle_t xReturn = NULL;
    2264:	ac06      	add	r4, sp, #24
    2266:	2500      	movs	r5, #0
    2268:	f844 5d04 	str.w	r5, [r4, #-4]!
        pxNewTCB = prvCreateStaticTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, puxStackBuffer, pxTaskBuffer, &xReturn );
    226c:	9403      	str	r4, [sp, #12]
    226e:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    2270:	9402      	str	r4, [sp, #8]
    2272:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
    2274:	9401      	str	r4, [sp, #4]
    2276:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    2278:	9400      	str	r4, [sp, #0]
    227a:	4c04      	ldr	r4, [pc, #16]	; (228c <xTaskCreateStatic+0x2c>)
    227c:	47a0      	blx	r4
        if( pxNewTCB != NULL )
    227e:	b108      	cbz	r0, 2284 <xTaskCreateStatic+0x24>
            prvAddNewTaskToReadyList( pxNewTCB );
    2280:	4b03      	ldr	r3, [pc, #12]	; (2290 <xTaskCreateStatic+0x30>)
    2282:	4798      	blx	r3
    }
    2284:	9805      	ldr	r0, [sp, #20]
    2286:	b007      	add	sp, #28
    2288:	bd30      	pop	{r4, r5, pc}
    228a:	bf00      	nop
    228c:	00001ff1 	.word	0x00001ff1
    2290:	000020d5 	.word	0x000020d5

00002294 <vTaskSuspendAll>:
        uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended + 1U );
    2294:	4a03      	ldr	r2, [pc, #12]	; (22a4 <vTaskSuspendAll+0x10>)
    2296:	f8d2 30d8 	ldr.w	r3, [r2, #216]	; 0xd8
    229a:	3301      	adds	r3, #1
    229c:	f8c2 30d8 	str.w	r3, [r2, #216]	; 0xd8
        portMEMORY_BARRIER();
    22a0:	4770      	bx	lr
    22a2:	bf00      	nop
    22a4:	20000afc 	.word	0x20000afc

000022a8 <xTaskGetTickCount>:
        xTicks = xTickCount;
    22a8:	4b01      	ldr	r3, [pc, #4]	; (22b0 <xTaskGetTickCount+0x8>)
    22aa:	f8d3 00d4 	ldr.w	r0, [r3, #212]	; 0xd4
}
    22ae:	4770      	bx	lr
    22b0:	20000afc 	.word	0x20000afc

000022b4 <uxTaskGetNumberOfTasks>:
    return uxCurrentNumberOfTasks;
    22b4:	4b01      	ldr	r3, [pc, #4]	; (22bc <uxTaskGetNumberOfTasks+0x8>)
    22b6:	f8d3 00c0 	ldr.w	r0, [r3, #192]	; 0xc0
}
    22ba:	4770      	bx	lr
    22bc:	20000afc 	.word	0x20000afc

000022c0 <xTaskIncrementTick>:
{
    22c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
    22c2:	4b5e      	ldr	r3, [pc, #376]	; (243c <xTaskIncrementTick+0x17c>)
    22c4:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
    22c8:	2b00      	cmp	r3, #0
    22ca:	f040 80ad 	bne.w	2428 <xTaskIncrementTick+0x168>
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    22ce:	4b5b      	ldr	r3, [pc, #364]	; (243c <xTaskIncrementTick+0x17c>)
    22d0:	f8d3 40d4 	ldr.w	r4, [r3, #212]	; 0xd4
    22d4:	3401      	adds	r4, #1
        xTickCount = xConstTickCount;
    22d6:	f8c3 40d4 	str.w	r4, [r3, #212]	; 0xd4
        if( xConstTickCount == ( TickType_t ) 0U )
    22da:	b9e4      	cbnz	r4, 2316 <xTaskIncrementTick+0x56>
            taskSWITCH_DELAYED_LISTS();
    22dc:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
    22e0:	681b      	ldr	r3, [r3, #0]
    22e2:	b143      	cbz	r3, 22f6 <xTaskIncrementTick+0x36>
    22e4:	f04f 0380 	mov.w	r3, #128	; 0x80
    22e8:	f383 8811 	msr	BASEPRI, r3
    22ec:	f3bf 8f6f 	isb	sy
    22f0:	f3bf 8f4f 	dsb	sy
    22f4:	e7fe      	b.n	22f4 <xTaskIncrementTick+0x34>
    22f6:	4b51      	ldr	r3, [pc, #324]	; (243c <xTaskIncrementTick+0x17c>)
    22f8:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
    22fc:	f8d3 10bc 	ldr.w	r1, [r3, #188]	; 0xbc
    2300:	f8c3 108c 	str.w	r1, [r3, #140]	; 0x8c
    2304:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
    2308:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
    230c:	3201      	adds	r2, #1
    230e:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
    2312:	4b4b      	ldr	r3, [pc, #300]	; (2440 <xTaskIncrementTick+0x180>)
    2314:	4798      	blx	r3
        if( xConstTickCount >= xNextTaskUnblockTime )
    2316:	4b49      	ldr	r3, [pc, #292]	; (243c <xTaskIncrementTick+0x17c>)
    2318:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
    231c:	429c      	cmp	r4, r3
    231e:	d271      	bcs.n	2404 <xTaskIncrementTick+0x144>
    BaseType_t xSwitchRequired = pdFALSE;
    2320:	2000      	movs	r0, #0
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > 1U )
    2322:	4a46      	ldr	r2, [pc, #280]	; (243c <xTaskIncrementTick+0x17c>)
    2324:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
    2328:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    232a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    232e:	0099      	lsls	r1, r3, #2
    2330:	440a      	add	r2, r1
    2332:	6a93      	ldr	r3, [r2, #40]	; 0x28
    2334:	2b01      	cmp	r3, #1
    2336:	d900      	bls.n	233a <xTaskIncrementTick+0x7a>
                    xSwitchRequired = pdTRUE;
    2338:	2001      	movs	r0, #1
                if( xYieldPendings[ 0 ] != pdFALSE )
    233a:	4b40      	ldr	r3, [pc, #256]	; (243c <xTaskIncrementTick+0x17c>)
    233c:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
    2340:	2b00      	cmp	r3, #0
    2342:	d179      	bne.n	2438 <xTaskIncrementTick+0x178>
    2344:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                                xSwitchRequired = pdTRUE;
    2346:	2001      	movs	r0, #1
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2348:	4b3c      	ldr	r3, [pc, #240]	; (243c <xTaskIncrementTick+0x17c>)
    234a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
    234e:	681b      	ldr	r3, [r3, #0]
    2350:	2b00      	cmp	r3, #0
    2352:	d059      	beq.n	2408 <xTaskIncrementTick+0x148>
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2354:	4b39      	ldr	r3, [pc, #228]	; (243c <xTaskIncrementTick+0x17c>)
    2356:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
    235a:	68db      	ldr	r3, [r3, #12]
    235c:	68db      	ldr	r3, [r3, #12]
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    235e:	685a      	ldr	r2, [r3, #4]
                    if( xConstTickCount < xItemValue )
    2360:	4294      	cmp	r4, r2
    2362:	d357      	bcc.n	2414 <xTaskIncrementTick+0x154>
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    2364:	695a      	ldr	r2, [r3, #20]
    2366:	6899      	ldr	r1, [r3, #8]
    2368:	68dd      	ldr	r5, [r3, #12]
    236a:	608d      	str	r5, [r1, #8]
    236c:	68d9      	ldr	r1, [r3, #12]
    236e:	689d      	ldr	r5, [r3, #8]
    2370:	604d      	str	r5, [r1, #4]
    2372:	6851      	ldr	r1, [r2, #4]
    2374:	1d1e      	adds	r6, r3, #4
    2376:	42b1      	cmp	r1, r6
    2378:	d050      	beq.n	241c <xTaskIncrementTick+0x15c>
    237a:	2100      	movs	r1, #0
    237c:	6159      	str	r1, [r3, #20]
    237e:	6811      	ldr	r1, [r2, #0]
    2380:	3901      	subs	r1, #1
    2382:	6011      	str	r1, [r2, #0]
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2384:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    2386:	b17a      	cbz	r2, 23a8 <xTaskIncrementTick+0xe8>
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    2388:	69d9      	ldr	r1, [r3, #28]
    238a:	6a1d      	ldr	r5, [r3, #32]
    238c:	608d      	str	r5, [r1, #8]
    238e:	6a19      	ldr	r1, [r3, #32]
    2390:	69dd      	ldr	r5, [r3, #28]
    2392:	604d      	str	r5, [r1, #4]
    2394:	6855      	ldr	r5, [r2, #4]
    2396:	f103 0118 	add.w	r1, r3, #24
    239a:	428d      	cmp	r5, r1
    239c:	d041      	beq.n	2422 <xTaskIncrementTick+0x162>
    239e:	2100      	movs	r1, #0
    23a0:	6299      	str	r1, [r3, #40]	; 0x28
    23a2:	6811      	ldr	r1, [r2, #0]
    23a4:	3901      	subs	r1, #1
    23a6:	6011      	str	r1, [r2, #0]
                    prvAddTaskToReadyList( pxTCB );
    23a8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    23aa:	4924      	ldr	r1, [pc, #144]	; (243c <xTaskIncrementTick+0x17c>)
    23ac:	f8d1 10d0 	ldr.w	r1, [r1, #208]	; 0xd0
    23b0:	428a      	cmp	r2, r1
    23b2:	d902      	bls.n	23ba <xTaskIncrementTick+0xfa>
    23b4:	4921      	ldr	r1, [pc, #132]	; (243c <xTaskIncrementTick+0x17c>)
    23b6:	f8c1 20d0 	str.w	r2, [r1, #208]	; 0xd0
    23ba:	4920      	ldr	r1, [pc, #128]	; (243c <xTaskIncrementTick+0x17c>)
    23bc:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    23c0:	0095      	lsls	r5, r2, #2
    23c2:	440d      	add	r5, r1
    23c4:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    23c6:	609a      	str	r2, [r3, #8]
    23c8:	6895      	ldr	r5, [r2, #8]
    23ca:	60dd      	str	r5, [r3, #12]
    23cc:	6895      	ldr	r5, [r2, #8]
    23ce:	606e      	str	r6, [r5, #4]
    23d0:	6096      	str	r6, [r2, #8]
    23d2:	6add      	ldr	r5, [r3, #44]	; 0x2c
    23d4:	f101 0628 	add.w	r6, r1, #40	; 0x28
    23d8:	00aa      	lsls	r2, r5, #2
    23da:	eb02 0e05 	add.w	lr, r2, r5
    23de:	ea4f 078e 	mov.w	r7, lr, lsl #2
    23e2:	46be      	mov	lr, r7
    23e4:	443e      	add	r6, r7
    23e6:	615e      	str	r6, [r3, #20]
    23e8:	4676      	mov	r6, lr
    23ea:	440e      	add	r6, r1
    23ec:	6ab6      	ldr	r6, [r6, #40]	; 0x28
    23ee:	3601      	adds	r6, #1
    23f0:	4675      	mov	r5, lr
    23f2:	440d      	add	r5, r1
    23f4:	62ae      	str	r6, [r5, #40]	; 0x28
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    23f6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    23f8:	f8d1 30c4 	ldr.w	r3, [r1, #196]	; 0xc4
    23fc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    23fe:	429a      	cmp	r2, r3
    2400:	d8a1      	bhi.n	2346 <xTaskIncrementTick+0x86>
    2402:	e7a1      	b.n	2348 <xTaskIncrementTick+0x88>
    2404:	2000      	movs	r0, #0
    2406:	e79f      	b.n	2348 <xTaskIncrementTick+0x88>
                    xNextTaskUnblockTime = portMAX_DELAY;
    2408:	f04f 32ff 	mov.w	r2, #4294967295
    240c:	4b0b      	ldr	r3, [pc, #44]	; (243c <xTaskIncrementTick+0x17c>)
    240e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
                    break;
    2412:	e786      	b.n	2322 <xTaskIncrementTick+0x62>
                        xNextTaskUnblockTime = xItemValue;
    2414:	4b09      	ldr	r3, [pc, #36]	; (243c <xTaskIncrementTick+0x17c>)
    2416:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
                        break;
    241a:	e782      	b.n	2322 <xTaskIncrementTick+0x62>
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    241c:	68d9      	ldr	r1, [r3, #12]
    241e:	6051      	str	r1, [r2, #4]
    2420:	e7ab      	b.n	237a <xTaskIncrementTick+0xba>
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    2422:	6a19      	ldr	r1, [r3, #32]
    2424:	6051      	str	r1, [r2, #4]
    2426:	e7ba      	b.n	239e <xTaskIncrementTick+0xde>
        xPendedTicks += 1U;
    2428:	4a04      	ldr	r2, [pc, #16]	; (243c <xTaskIncrementTick+0x17c>)
    242a:	f8d2 30e4 	ldr.w	r3, [r2, #228]	; 0xe4
    242e:	3301      	adds	r3, #1
    2430:	f8c2 30e4 	str.w	r3, [r2, #228]	; 0xe4
    BaseType_t xSwitchRequired = pdFALSE;
    2434:	2000      	movs	r0, #0
    2436:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                    xSwitchRequired = pdTRUE;
    2438:	2001      	movs	r0, #1
}
    243a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    243c:	20000afc 	.word	0x20000afc
    2440:	00001f21 	.word	0x00001f21

00002444 <xTaskResumeAll>:
{
    2444:	b570      	push	{r4, r5, r6, lr}
        taskENTER_CRITICAL();
    2446:	4b57      	ldr	r3, [pc, #348]	; (25a4 <xTaskResumeAll+0x160>)
    2448:	4798      	blx	r3
            configASSERT( uxSchedulerSuspended != 0U );
    244a:	4b57      	ldr	r3, [pc, #348]	; (25a8 <xTaskResumeAll+0x164>)
    244c:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
    2450:	b943      	cbnz	r3, 2464 <xTaskResumeAll+0x20>
    2452:	f04f 0380 	mov.w	r3, #128	; 0x80
    2456:	f383 8811 	msr	BASEPRI, r3
    245a:	f3bf 8f6f 	isb	sy
    245e:	f3bf 8f4f 	dsb	sy
    2462:	e7fe      	b.n	2462 <xTaskResumeAll+0x1e>
            uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended - 1U );
    2464:	4b50      	ldr	r3, [pc, #320]	; (25a8 <xTaskResumeAll+0x164>)
    2466:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
    246a:	3a01      	subs	r2, #1
    246c:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
            if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
    2470:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
    2474:	2b00      	cmp	r3, #0
    2476:	f040 8091 	bne.w	259c <xTaskResumeAll+0x158>
                if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    247a:	4b4b      	ldr	r3, [pc, #300]	; (25a8 <xTaskResumeAll+0x164>)
    247c:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
    2480:	2b00      	cmp	r3, #0
    2482:	d058      	beq.n	2536 <xTaskResumeAll+0xf2>
    2484:	2300      	movs	r3, #0
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    2486:	4a48      	ldr	r2, [pc, #288]	; (25a8 <xTaskResumeAll+0x164>)
    2488:	6952      	ldr	r2, [r2, #20]
    248a:	2a00      	cmp	r2, #0
    248c:	d05e      	beq.n	254c <xTaskResumeAll+0x108>
                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    248e:	4b46      	ldr	r3, [pc, #280]	; (25a8 <xTaskResumeAll+0x164>)
    2490:	6a1b      	ldr	r3, [r3, #32]
    2492:	68db      	ldr	r3, [r3, #12]
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    2494:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    2496:	69d9      	ldr	r1, [r3, #28]
    2498:	6a18      	ldr	r0, [r3, #32]
    249a:	6088      	str	r0, [r1, #8]
    249c:	6a19      	ldr	r1, [r3, #32]
    249e:	69d8      	ldr	r0, [r3, #28]
    24a0:	6048      	str	r0, [r1, #4]
    24a2:	6850      	ldr	r0, [r2, #4]
    24a4:	f103 0118 	add.w	r1, r3, #24
    24a8:	4288      	cmp	r0, r1
    24aa:	d049      	beq.n	2540 <xTaskResumeAll+0xfc>
    24ac:	2100      	movs	r1, #0
    24ae:	6299      	str	r1, [r3, #40]	; 0x28
    24b0:	6811      	ldr	r1, [r2, #0]
    24b2:	3901      	subs	r1, #1
    24b4:	6011      	str	r1, [r2, #0]
                        listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    24b6:	695a      	ldr	r2, [r3, #20]
    24b8:	6899      	ldr	r1, [r3, #8]
    24ba:	68d8      	ldr	r0, [r3, #12]
    24bc:	6088      	str	r0, [r1, #8]
    24be:	68d9      	ldr	r1, [r3, #12]
    24c0:	6898      	ldr	r0, [r3, #8]
    24c2:	6048      	str	r0, [r1, #4]
    24c4:	6851      	ldr	r1, [r2, #4]
    24c6:	1d1c      	adds	r4, r3, #4
    24c8:	42a1      	cmp	r1, r4
    24ca:	d03c      	beq.n	2546 <xTaskResumeAll+0x102>
    24cc:	2100      	movs	r1, #0
    24ce:	6159      	str	r1, [r3, #20]
    24d0:	6811      	ldr	r1, [r2, #0]
    24d2:	3901      	subs	r1, #1
    24d4:	6011      	str	r1, [r2, #0]
                        prvAddTaskToReadyList( pxTCB );
    24d6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    24d8:	4933      	ldr	r1, [pc, #204]	; (25a8 <xTaskResumeAll+0x164>)
    24da:	f8d1 10d0 	ldr.w	r1, [r1, #208]	; 0xd0
    24de:	428a      	cmp	r2, r1
    24e0:	d902      	bls.n	24e8 <xTaskResumeAll+0xa4>
    24e2:	4931      	ldr	r1, [pc, #196]	; (25a8 <xTaskResumeAll+0x164>)
    24e4:	f8c1 20d0 	str.w	r2, [r1, #208]	; 0xd0
    24e8:	492f      	ldr	r1, [pc, #188]	; (25a8 <xTaskResumeAll+0x164>)
    24ea:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    24ee:	0090      	lsls	r0, r2, #2
    24f0:	4408      	add	r0, r1
    24f2:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
    24f4:	609a      	str	r2, [r3, #8]
    24f6:	6890      	ldr	r0, [r2, #8]
    24f8:	60d8      	str	r0, [r3, #12]
    24fa:	6890      	ldr	r0, [r2, #8]
    24fc:	6044      	str	r4, [r0, #4]
    24fe:	6094      	str	r4, [r2, #8]
    2500:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
    2502:	f101 0428 	add.w	r4, r1, #40	; 0x28
    2506:	0082      	lsls	r2, r0, #2
    2508:	1816      	adds	r6, r2, r0
    250a:	00b5      	lsls	r5, r6, #2
    250c:	462e      	mov	r6, r5
    250e:	442c      	add	r4, r5
    2510:	615c      	str	r4, [r3, #20]
    2512:	4634      	mov	r4, r6
    2514:	440c      	add	r4, r1
    2516:	6aa4      	ldr	r4, [r4, #40]	; 0x28
    2518:	3401      	adds	r4, #1
    251a:	4630      	mov	r0, r6
    251c:	4408      	add	r0, r1
    251e:	6284      	str	r4, [r0, #40]	; 0x28
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2520:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
    2522:	f8d1 20c4 	ldr.w	r2, [r1, #196]	; 0xc4
    2526:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    2528:	4290      	cmp	r0, r2
    252a:	d9ac      	bls.n	2486 <xTaskResumeAll+0x42>
                                xYieldPendings[ xCoreID ] = pdTRUE;
    252c:	2101      	movs	r1, #1
    252e:	4a1e      	ldr	r2, [pc, #120]	; (25a8 <xTaskResumeAll+0x164>)
    2530:	f8c2 10dc 	str.w	r1, [r2, #220]	; 0xdc
    2534:	e7a7      	b.n	2486 <xTaskResumeAll+0x42>
    BaseType_t xAlreadyYielded = pdFALSE;
    2536:	2400      	movs	r4, #0
        taskEXIT_CRITICAL();
    2538:	4b1c      	ldr	r3, [pc, #112]	; (25ac <xTaskResumeAll+0x168>)
    253a:	4798      	blx	r3
}
    253c:	4620      	mov	r0, r4
    253e:	bd70      	pop	{r4, r5, r6, pc}
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    2540:	6a19      	ldr	r1, [r3, #32]
    2542:	6051      	str	r1, [r2, #4]
    2544:	e7b2      	b.n	24ac <xTaskResumeAll+0x68>
                        listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    2546:	68d9      	ldr	r1, [r3, #12]
    2548:	6051      	str	r1, [r2, #4]
    254a:	e7bf      	b.n	24cc <xTaskResumeAll+0x88>
                    if( pxTCB != NULL )
    254c:	b10b      	cbz	r3, 2552 <xTaskResumeAll+0x10e>
                        prvResetNextTaskUnblockTime();
    254e:	4b18      	ldr	r3, [pc, #96]	; (25b0 <xTaskResumeAll+0x16c>)
    2550:	4798      	blx	r3
                        TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    2552:	4b15      	ldr	r3, [pc, #84]	; (25a8 <xTaskResumeAll+0x164>)
    2554:	f8d3 40e4 	ldr.w	r4, [r3, #228]	; 0xe4
                        if( xPendedCounts > ( TickType_t ) 0U )
    2558:	b994      	cbnz	r4, 2580 <xTaskResumeAll+0x13c>
                    if( xYieldPendings[ xCoreID ] != pdFALSE )
    255a:	4b13      	ldr	r3, [pc, #76]	; (25a8 <xTaskResumeAll+0x164>)
    255c:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
    2560:	b1f3      	cbz	r3, 25a0 <xTaskResumeAll+0x15c>
                            taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxCurrentTCB );
    2562:	4b11      	ldr	r3, [pc, #68]	; (25a8 <xTaskResumeAll+0x164>)
    2564:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
    2568:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    256c:	4b11      	ldr	r3, [pc, #68]	; (25b4 <xTaskResumeAll+0x170>)
    256e:	601a      	str	r2, [r3, #0]
    2570:	f3bf 8f4f 	dsb	sy
    2574:	f3bf 8f6f 	isb	sy
                            xAlreadyYielded = pdTRUE;
    2578:	2401      	movs	r4, #1
    257a:	e7dd      	b.n	2538 <xTaskResumeAll+0xf4>
                            } while( xPendedCounts > ( TickType_t ) 0U );
    257c:	3c01      	subs	r4, #1
    257e:	d008      	beq.n	2592 <xTaskResumeAll+0x14e>
                                if( xTaskIncrementTick() != pdFALSE )
    2580:	4b0d      	ldr	r3, [pc, #52]	; (25b8 <xTaskResumeAll+0x174>)
    2582:	4798      	blx	r3
    2584:	2800      	cmp	r0, #0
    2586:	d0f9      	beq.n	257c <xTaskResumeAll+0x138>
                                    xYieldPendings[ xCoreID ] = pdTRUE;
    2588:	2201      	movs	r2, #1
    258a:	4b07      	ldr	r3, [pc, #28]	; (25a8 <xTaskResumeAll+0x164>)
    258c:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
    2590:	e7f4      	b.n	257c <xTaskResumeAll+0x138>
                            xPendedTicks = 0;
    2592:	2200      	movs	r2, #0
    2594:	4b04      	ldr	r3, [pc, #16]	; (25a8 <xTaskResumeAll+0x164>)
    2596:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
    259a:	e7de      	b.n	255a <xTaskResumeAll+0x116>
    BaseType_t xAlreadyYielded = pdFALSE;
    259c:	2400      	movs	r4, #0
    259e:	e7cb      	b.n	2538 <xTaskResumeAll+0xf4>
    25a0:	2400      	movs	r4, #0
    25a2:	e7c9      	b.n	2538 <xTaskResumeAll+0xf4>
    25a4:	00000fa5 	.word	0x00000fa5
    25a8:	20000afc 	.word	0x20000afc
    25ac:	00000fe9 	.word	0x00000fe9
    25b0:	00001f21 	.word	0x00001f21
    25b4:	e000ed04 	.word	0xe000ed04
    25b8:	000022c1 	.word	0x000022c1

000025bc <vTaskDelay>:
    {
    25bc:	b510      	push	{r4, lr}
        if( xTicksToDelay > ( TickType_t ) 0U )
    25be:	b950      	cbnz	r0, 25d6 <vTaskDelay+0x1a>
        BaseType_t xAlreadyYielded = pdFALSE;
    25c0:	2000      	movs	r0, #0
        if( xAlreadyYielded == pdFALSE )
    25c2:	b938      	cbnz	r0, 25d4 <vTaskDelay+0x18>
            taskYIELD_WITHIN_API();
    25c4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    25c8:	4b0f      	ldr	r3, [pc, #60]	; (2608 <vTaskDelay+0x4c>)
    25ca:	601a      	str	r2, [r3, #0]
    25cc:	f3bf 8f4f 	dsb	sy
    25d0:	f3bf 8f6f 	isb	sy
    25d4:	bd10      	pop	{r4, pc}
    25d6:	4604      	mov	r4, r0
            vTaskSuspendAll();
    25d8:	4b0c      	ldr	r3, [pc, #48]	; (260c <vTaskDelay+0x50>)
    25da:	4798      	blx	r3
                configASSERT( uxSchedulerSuspended == 1U );
    25dc:	4b0c      	ldr	r3, [pc, #48]	; (2610 <vTaskDelay+0x54>)
    25de:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
    25e2:	2b01      	cmp	r3, #1
    25e4:	d008      	beq.n	25f8 <vTaskDelay+0x3c>
    25e6:	f04f 0380 	mov.w	r3, #128	; 0x80
    25ea:	f383 8811 	msr	BASEPRI, r3
    25ee:	f3bf 8f6f 	isb	sy
    25f2:	f3bf 8f4f 	dsb	sy
    25f6:	e7fe      	b.n	25f6 <vTaskDelay+0x3a>
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    25f8:	2100      	movs	r1, #0
    25fa:	4620      	mov	r0, r4
    25fc:	4b05      	ldr	r3, [pc, #20]	; (2614 <vTaskDelay+0x58>)
    25fe:	4798      	blx	r3
            xAlreadyYielded = xTaskResumeAll();
    2600:	4b05      	ldr	r3, [pc, #20]	; (2618 <vTaskDelay+0x5c>)
    2602:	4798      	blx	r3
    2604:	e7dd      	b.n	25c2 <vTaskDelay+0x6>
    2606:	bf00      	nop
    2608:	e000ed04 	.word	0xe000ed04
    260c:	00002295 	.word	0x00002295
    2610:	20000afc 	.word	0x20000afc
    2614:	000021b5 	.word	0x000021b5
    2618:	00002445 	.word	0x00002445

0000261c <vTaskSwitchContext>:
        if( uxSchedulerSuspended != ( UBaseType_t ) 0U )
    261c:	4b23      	ldr	r3, [pc, #140]	; (26ac <vTaskSwitchContext+0x90>)
    261e:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
    2622:	b97b      	cbnz	r3, 2644 <vTaskSwitchContext+0x28>
            xYieldPendings[ 0 ] = pdFALSE;
    2624:	4b21      	ldr	r3, [pc, #132]	; (26ac <vTaskSwitchContext+0x90>)
    2626:	2200      	movs	r2, #0
    2628:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
            taskSELECT_HIGHEST_PRIORITY_TASK();
    262c:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
    2630:	eb03 0283 	add.w	r2, r3, r3, lsl #2
    2634:	0091      	lsls	r1, r2, #2
    2636:	4a1d      	ldr	r2, [pc, #116]	; (26ac <vTaskSwitchContext+0x90>)
    2638:	440a      	add	r2, r1
    263a:	6a92      	ldr	r2, [r2, #40]	; 0x28
    263c:	b982      	cbnz	r2, 2660 <vTaskSwitchContext+0x44>
    263e:	b133      	cbz	r3, 264e <vTaskSwitchContext+0x32>
    2640:	3b01      	subs	r3, #1
    2642:	e7f5      	b.n	2630 <vTaskSwitchContext+0x14>
            xYieldPendings[ 0 ] = pdTRUE;
    2644:	2201      	movs	r2, #1
    2646:	4b19      	ldr	r3, [pc, #100]	; (26ac <vTaskSwitchContext+0x90>)
    2648:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
    264c:	4770      	bx	lr
    264e:	f04f 0380 	mov.w	r3, #128	; 0x80
    2652:	f383 8811 	msr	BASEPRI, r3
    2656:	f3bf 8f6f 	isb	sy
    265a:	f3bf 8f4f 	dsb	sy
    265e:	e7fe      	b.n	265e <vTaskSwitchContext+0x42>
    {
    2660:	b410      	push	{r4}
            taskSELECT_HIGHEST_PRIORITY_TASK();
    2662:	4a12      	ldr	r2, [pc, #72]	; (26ac <vTaskSwitchContext+0x90>)
    2664:	0099      	lsls	r1, r3, #2
    2666:	18cc      	adds	r4, r1, r3
    2668:	00a0      	lsls	r0, r4, #2
    266a:	4410      	add	r0, r2
    266c:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
    266e:	6864      	ldr	r4, [r4, #4]
    2670:	62c4      	str	r4, [r0, #44]	; 0x2c
    2672:	3228      	adds	r2, #40	; 0x28
    2674:	4419      	add	r1, r3
    2676:	0088      	lsls	r0, r1, #2
    2678:	4601      	mov	r1, r0
    267a:	3008      	adds	r0, #8
    267c:	4402      	add	r2, r0
    267e:	4294      	cmp	r4, r2
    2680:	d00f      	beq.n	26a2 <vTaskSwitchContext+0x86>
    2682:	4a0a      	ldr	r2, [pc, #40]	; (26ac <vTaskSwitchContext+0x90>)
    2684:	eb03 0083 	add.w	r0, r3, r3, lsl #2
    2688:	0081      	lsls	r1, r0, #2
    268a:	4411      	add	r1, r2
    268c:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
    268e:	68c9      	ldr	r1, [r1, #12]
    2690:	f8c2 10c4 	str.w	r1, [r2, #196]	; 0xc4
    2694:	f8c2 30d0 	str.w	r3, [r2, #208]	; 0xd0
            portTASK_SWITCH_HOOK( pxCurrentTCB );
    2698:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
    }
    269c:	f85d 4b04 	ldr.w	r4, [sp], #4
    26a0:	4770      	bx	lr
            taskSELECT_HIGHEST_PRIORITY_TASK();
    26a2:	4a02      	ldr	r2, [pc, #8]	; (26ac <vTaskSwitchContext+0x90>)
    26a4:	440a      	add	r2, r1
    26a6:	6b51      	ldr	r1, [r2, #52]	; 0x34
    26a8:	62d1      	str	r1, [r2, #44]	; 0x2c
    26aa:	e7ea      	b.n	2682 <vTaskSwitchContext+0x66>
    26ac:	20000afc 	.word	0x20000afc

000026b0 <vTaskPlaceOnEventList>:
    configASSERT( pxEventList );
    26b0:	b940      	cbnz	r0, 26c4 <vTaskPlaceOnEventList+0x14>
    26b2:	f04f 0380 	mov.w	r3, #128	; 0x80
    26b6:	f383 8811 	msr	BASEPRI, r3
    26ba:	f3bf 8f6f 	isb	sy
    26be:	f3bf 8f4f 	dsb	sy
    26c2:	e7fe      	b.n	26c2 <vTaskPlaceOnEventList+0x12>
{
    26c4:	b510      	push	{r4, lr}
    26c6:	460c      	mov	r4, r1
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    26c8:	4b05      	ldr	r3, [pc, #20]	; (26e0 <vTaskPlaceOnEventList+0x30>)
    26ca:	f8d3 10c4 	ldr.w	r1, [r3, #196]	; 0xc4
    26ce:	3118      	adds	r1, #24
    26d0:	4b04      	ldr	r3, [pc, #16]	; (26e4 <vTaskPlaceOnEventList+0x34>)
    26d2:	4798      	blx	r3
    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    26d4:	2101      	movs	r1, #1
    26d6:	4620      	mov	r0, r4
    26d8:	4b03      	ldr	r3, [pc, #12]	; (26e8 <vTaskPlaceOnEventList+0x38>)
    26da:	4798      	blx	r3
    26dc:	bd10      	pop	{r4, pc}
    26de:	bf00      	nop
    26e0:	20000afc 	.word	0x20000afc
    26e4:	00000e11 	.word	0x00000e11
    26e8:	000021b5 	.word	0x000021b5

000026ec <vTaskPlaceOnEventListRestricted>:
        configASSERT( pxEventList );
    26ec:	b310      	cbz	r0, 2734 <vTaskPlaceOnEventListRestricted+0x48>
    {
    26ee:	b570      	push	{r4, r5, r6, lr}
    26f0:	460e      	mov	r6, r1
    26f2:	4604      	mov	r4, r0
        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    26f4:	6840      	ldr	r0, [r0, #4]
    26f6:	4b14      	ldr	r3, [pc, #80]	; (2748 <vTaskPlaceOnEventListRestricted+0x5c>)
    26f8:	f8d3 10c4 	ldr.w	r1, [r3, #196]	; 0xc4
    26fc:	61c8      	str	r0, [r1, #28]
    26fe:	f8d3 10c4 	ldr.w	r1, [r3, #196]	; 0xc4
    2702:	6885      	ldr	r5, [r0, #8]
    2704:	620d      	str	r5, [r1, #32]
    2706:	6881      	ldr	r1, [r0, #8]
    2708:	f8d3 50c4 	ldr.w	r5, [r3, #196]	; 0xc4
    270c:	3518      	adds	r5, #24
    270e:	604d      	str	r5, [r1, #4]
    2710:	f8d3 50c4 	ldr.w	r5, [r3, #196]	; 0xc4
    2714:	3518      	adds	r5, #24
    2716:	6085      	str	r5, [r0, #8]
    2718:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
    271c:	629c      	str	r4, [r3, #40]	; 0x28
    271e:	6823      	ldr	r3, [r4, #0]
    2720:	3301      	adds	r3, #1
    2722:	6023      	str	r3, [r4, #0]
        if( xWaitIndefinitely != pdFALSE )
    2724:	b10a      	cbz	r2, 272a <vTaskPlaceOnEventListRestricted+0x3e>
            xTicksToWait = portMAX_DELAY;
    2726:	f04f 36ff 	mov.w	r6, #4294967295
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    272a:	4611      	mov	r1, r2
    272c:	4630      	mov	r0, r6
    272e:	4b07      	ldr	r3, [pc, #28]	; (274c <vTaskPlaceOnEventListRestricted+0x60>)
    2730:	4798      	blx	r3
    2732:	bd70      	pop	{r4, r5, r6, pc}
    2734:	f04f 0380 	mov.w	r3, #128	; 0x80
    2738:	f383 8811 	msr	BASEPRI, r3
    273c:	f3bf 8f6f 	isb	sy
    2740:	f3bf 8f4f 	dsb	sy
    2744:	e7fe      	b.n	2744 <vTaskPlaceOnEventListRestricted+0x58>
    2746:	bf00      	nop
    2748:	20000afc 	.word	0x20000afc
    274c:	000021b5 	.word	0x000021b5

00002750 <xTaskRemoveFromEventList>:
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2750:	68c3      	ldr	r3, [r0, #12]
    2752:	68db      	ldr	r3, [r3, #12]
    configASSERT( pxUnblockedTCB );
    2754:	2b00      	cmp	r3, #0
    2756:	d057      	beq.n	2808 <xTaskRemoveFromEventList+0xb8>
{
    2758:	b470      	push	{r4, r5, r6}
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    275a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    275c:	69d9      	ldr	r1, [r3, #28]
    275e:	6a18      	ldr	r0, [r3, #32]
    2760:	6088      	str	r0, [r1, #8]
    2762:	6a19      	ldr	r1, [r3, #32]
    2764:	69d8      	ldr	r0, [r3, #28]
    2766:	6048      	str	r0, [r1, #4]
    2768:	6851      	ldr	r1, [r2, #4]
    276a:	f103 0018 	add.w	r0, r3, #24
    276e:	4281      	cmp	r1, r0
    2770:	d053      	beq.n	281a <xTaskRemoveFromEventList+0xca>
    2772:	2100      	movs	r1, #0
    2774:	6299      	str	r1, [r3, #40]	; 0x28
    2776:	6811      	ldr	r1, [r2, #0]
    2778:	3901      	subs	r1, #1
    277a:	6011      	str	r1, [r2, #0]
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
    277c:	4a32      	ldr	r2, [pc, #200]	; (2848 <xTaskRemoveFromEventList+0xf8>)
    277e:	f8d2 20d8 	ldr.w	r2, [r2, #216]	; 0xd8
    2782:	2a00      	cmp	r2, #0
    2784:	d14f      	bne.n	2826 <xTaskRemoveFromEventList+0xd6>
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    2786:	695a      	ldr	r2, [r3, #20]
    2788:	6899      	ldr	r1, [r3, #8]
    278a:	68d8      	ldr	r0, [r3, #12]
    278c:	6088      	str	r0, [r1, #8]
    278e:	68d9      	ldr	r1, [r3, #12]
    2790:	6898      	ldr	r0, [r3, #8]
    2792:	6048      	str	r0, [r1, #4]
    2794:	6851      	ldr	r1, [r2, #4]
    2796:	1d1c      	adds	r4, r3, #4
    2798:	42a1      	cmp	r1, r4
    279a:	d041      	beq.n	2820 <xTaskRemoveFromEventList+0xd0>
    279c:	2100      	movs	r1, #0
    279e:	6159      	str	r1, [r3, #20]
    27a0:	6811      	ldr	r1, [r2, #0]
    27a2:	3901      	subs	r1, #1
    27a4:	6011      	str	r1, [r2, #0]
        prvAddTaskToReadyList( pxUnblockedTCB );
    27a6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    27a8:	4927      	ldr	r1, [pc, #156]	; (2848 <xTaskRemoveFromEventList+0xf8>)
    27aa:	f8d1 10d0 	ldr.w	r1, [r1, #208]	; 0xd0
    27ae:	428a      	cmp	r2, r1
    27b0:	d902      	bls.n	27b8 <xTaskRemoveFromEventList+0x68>
    27b2:	4925      	ldr	r1, [pc, #148]	; (2848 <xTaskRemoveFromEventList+0xf8>)
    27b4:	f8c1 20d0 	str.w	r2, [r1, #208]	; 0xd0
    27b8:	4923      	ldr	r1, [pc, #140]	; (2848 <xTaskRemoveFromEventList+0xf8>)
    27ba:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    27be:	0090      	lsls	r0, r2, #2
    27c0:	4408      	add	r0, r1
    27c2:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
    27c4:	609a      	str	r2, [r3, #8]
    27c6:	6890      	ldr	r0, [r2, #8]
    27c8:	60d8      	str	r0, [r3, #12]
    27ca:	6890      	ldr	r0, [r2, #8]
    27cc:	6044      	str	r4, [r0, #4]
    27ce:	6094      	str	r4, [r2, #8]
    27d0:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
    27d2:	f101 0428 	add.w	r4, r1, #40	; 0x28
    27d6:	0082      	lsls	r2, r0, #2
    27d8:	1816      	adds	r6, r2, r0
    27da:	00b5      	lsls	r5, r6, #2
    27dc:	462e      	mov	r6, r5
    27de:	442c      	add	r4, r5
    27e0:	615c      	str	r4, [r3, #20]
    27e2:	4634      	mov	r4, r6
    27e4:	440c      	add	r4, r1
    27e6:	6aa4      	ldr	r4, [r4, #40]	; 0x28
    27e8:	3401      	adds	r4, #1
    27ea:	4431      	add	r1, r6
    27ec:	628c      	str	r4, [r1, #40]	; 0x28
        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    27ee:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    27f0:	4b15      	ldr	r3, [pc, #84]	; (2848 <xTaskRemoveFromEventList+0xf8>)
    27f2:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
    27f6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    27f8:	429a      	cmp	r2, r3
    27fa:	d923      	bls.n	2844 <xTaskRemoveFromEventList+0xf4>
            xYieldPendings[ 0 ] = pdTRUE;
    27fc:	2001      	movs	r0, #1
    27fe:	4b12      	ldr	r3, [pc, #72]	; (2848 <xTaskRemoveFromEventList+0xf8>)
    2800:	f8c3 00dc 	str.w	r0, [r3, #220]	; 0xdc
}
    2804:	bc70      	pop	{r4, r5, r6}
    2806:	4770      	bx	lr
    2808:	f04f 0380 	mov.w	r3, #128	; 0x80
    280c:	f383 8811 	msr	BASEPRI, r3
    2810:	f3bf 8f6f 	isb	sy
    2814:	f3bf 8f4f 	dsb	sy
    2818:	e7fe      	b.n	2818 <xTaskRemoveFromEventList+0xc8>
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    281a:	6a19      	ldr	r1, [r3, #32]
    281c:	6051      	str	r1, [r2, #4]
    281e:	e7a8      	b.n	2772 <xTaskRemoveFromEventList+0x22>
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    2820:	68d9      	ldr	r1, [r3, #12]
    2822:	6051      	str	r1, [r2, #4]
    2824:	e7ba      	b.n	279c <xTaskRemoveFromEventList+0x4c>
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2826:	4a08      	ldr	r2, [pc, #32]	; (2848 <xTaskRemoveFromEventList+0xf8>)
    2828:	6991      	ldr	r1, [r2, #24]
    282a:	61d9      	str	r1, [r3, #28]
    282c:	688c      	ldr	r4, [r1, #8]
    282e:	621c      	str	r4, [r3, #32]
    2830:	688c      	ldr	r4, [r1, #8]
    2832:	6060      	str	r0, [r4, #4]
    2834:	6088      	str	r0, [r1, #8]
    2836:	f102 0114 	add.w	r1, r2, #20
    283a:	6299      	str	r1, [r3, #40]	; 0x28
    283c:	6951      	ldr	r1, [r2, #20]
    283e:	3101      	adds	r1, #1
    2840:	6151      	str	r1, [r2, #20]
    2842:	e7d4      	b.n	27ee <xTaskRemoveFromEventList+0x9e>
            xReturn = pdFALSE;
    2844:	2000      	movs	r0, #0
    return xReturn;
    2846:	e7dd      	b.n	2804 <xTaskRemoveFromEventList+0xb4>
    2848:	20000afc 	.word	0x20000afc

0000284c <vTaskInternalSetTimeOutState>:
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    284c:	4b03      	ldr	r3, [pc, #12]	; (285c <vTaskInternalSetTimeOutState+0x10>)
    284e:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
    2852:	6002      	str	r2, [r0, #0]
    pxTimeOut->xTimeOnEntering = xTickCount;
    2854:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
    2858:	6043      	str	r3, [r0, #4]
    285a:	4770      	bx	lr
    285c:	20000afc 	.word	0x20000afc

00002860 <xTaskCheckForTimeOut>:
{
    2860:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    configASSERT( pxTimeOut );
    2862:	b1d8      	cbz	r0, 289c <xTaskCheckForTimeOut+0x3c>
    2864:	4605      	mov	r5, r0
    configASSERT( pxTicksToWait );
    2866:	b311      	cbz	r1, 28ae <xTaskCheckForTimeOut+0x4e>
    2868:	460c      	mov	r4, r1
    taskENTER_CRITICAL();
    286a:	4b1d      	ldr	r3, [pc, #116]	; (28e0 <xTaskCheckForTimeOut+0x80>)
    286c:	4798      	blx	r3
        const TickType_t xConstTickCount = xTickCount;
    286e:	4b1d      	ldr	r3, [pc, #116]	; (28e4 <xTaskCheckForTimeOut+0x84>)
    2870:	f8d3 00d4 	ldr.w	r0, [r3, #212]	; 0xd4
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    2874:	6869      	ldr	r1, [r5, #4]
    2876:	1a42      	subs	r2, r0, r1
            if( *pxTicksToWait == portMAX_DELAY )
    2878:	6823      	ldr	r3, [r4, #0]
    287a:	f1b3 3fff 	cmp.w	r3, #4294967295
    287e:	d02d      	beq.n	28dc <xTaskCheckForTimeOut+0x7c>
        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) )
    2880:	682f      	ldr	r7, [r5, #0]
    2882:	4e18      	ldr	r6, [pc, #96]	; (28e4 <xTaskCheckForTimeOut+0x84>)
    2884:	f8d6 60e0 	ldr.w	r6, [r6, #224]	; 0xe0
    2888:	42b7      	cmp	r7, r6
    288a:	d001      	beq.n	2890 <xTaskCheckForTimeOut+0x30>
    288c:	4288      	cmp	r0, r1
    288e:	d217      	bcs.n	28c0 <xTaskCheckForTimeOut+0x60>
        else if( xElapsedTime < *pxTicksToWait )
    2890:	429a      	cmp	r2, r3
    2892:	d31c      	bcc.n	28ce <xTaskCheckForTimeOut+0x6e>
            *pxTicksToWait = ( TickType_t ) 0;
    2894:	2300      	movs	r3, #0
    2896:	6023      	str	r3, [r4, #0]
            xReturn = pdTRUE;
    2898:	2401      	movs	r4, #1
    289a:	e014      	b.n	28c6 <xTaskCheckForTimeOut+0x66>
    289c:	f04f 0380 	mov.w	r3, #128	; 0x80
    28a0:	f383 8811 	msr	BASEPRI, r3
    28a4:	f3bf 8f6f 	isb	sy
    28a8:	f3bf 8f4f 	dsb	sy
    28ac:	e7fe      	b.n	28ac <xTaskCheckForTimeOut+0x4c>
    28ae:	f04f 0380 	mov.w	r3, #128	; 0x80
    28b2:	f383 8811 	msr	BASEPRI, r3
    28b6:	f3bf 8f6f 	isb	sy
    28ba:	f3bf 8f4f 	dsb	sy
    28be:	e7fe      	b.n	28be <xTaskCheckForTimeOut+0x5e>
            *pxTicksToWait = ( TickType_t ) 0;
    28c0:	2300      	movs	r3, #0
    28c2:	6023      	str	r3, [r4, #0]
            xReturn = pdTRUE;
    28c4:	2401      	movs	r4, #1
    taskEXIT_CRITICAL();
    28c6:	4b08      	ldr	r3, [pc, #32]	; (28e8 <xTaskCheckForTimeOut+0x88>)
    28c8:	4798      	blx	r3
}
    28ca:	4620      	mov	r0, r4
    28cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            *pxTicksToWait -= xElapsedTime;
    28ce:	1a9b      	subs	r3, r3, r2
    28d0:	6023      	str	r3, [r4, #0]
            vTaskInternalSetTimeOutState( pxTimeOut );
    28d2:	4628      	mov	r0, r5
    28d4:	4b05      	ldr	r3, [pc, #20]	; (28ec <xTaskCheckForTimeOut+0x8c>)
    28d6:	4798      	blx	r3
            xReturn = pdFALSE;
    28d8:	2400      	movs	r4, #0
    28da:	e7f4      	b.n	28c6 <xTaskCheckForTimeOut+0x66>
                xReturn = pdFALSE;
    28dc:	2400      	movs	r4, #0
    28de:	e7f2      	b.n	28c6 <xTaskCheckForTimeOut+0x66>
    28e0:	00000fa5 	.word	0x00000fa5
    28e4:	20000afc 	.word	0x20000afc
    28e8:	00000fe9 	.word	0x00000fe9
    28ec:	0000284d 	.word	0x0000284d

000028f0 <vTaskMissedYield>:
    xYieldPendings[ portGET_CORE_ID() ] = pdTRUE;
    28f0:	2201      	movs	r2, #1
    28f2:	4b02      	ldr	r3, [pc, #8]	; (28fc <vTaskMissedYield+0xc>)
    28f4:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
    28f8:	4770      	bx	lr
    28fa:	bf00      	nop
    28fc:	20000afc 	.word	0x20000afc

00002900 <xTaskGetSchedulerState>:
        if( xSchedulerRunning == pdFALSE )
    2900:	4b06      	ldr	r3, [pc, #24]	; (291c <xTaskGetSchedulerState+0x1c>)
    2902:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
    2906:	b12b      	cbz	r3, 2914 <xTaskGetSchedulerState+0x14>
                if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
    2908:	4b04      	ldr	r3, [pc, #16]	; (291c <xTaskGetSchedulerState+0x1c>)
    290a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
    290e:	b91b      	cbnz	r3, 2918 <xTaskGetSchedulerState+0x18>
                    xReturn = taskSCHEDULER_RUNNING;
    2910:	2002      	movs	r0, #2
    2912:	4770      	bx	lr
            xReturn = taskSCHEDULER_NOT_STARTED;
    2914:	2001      	movs	r0, #1
    2916:	4770      	bx	lr
                    xReturn = taskSCHEDULER_SUSPENDED;
    2918:	2000      	movs	r0, #0
    }
    291a:	4770      	bx	lr
    291c:	20000afc 	.word	0x20000afc

00002920 <xTaskPriorityInherit>:
        if( pxMutexHolder != NULL )
    2920:	2800      	cmp	r0, #0
    2922:	d058      	beq.n	29d6 <xTaskPriorityInherit+0xb6>
    {
    2924:	b570      	push	{r4, r5, r6, lr}
    2926:	4604      	mov	r4, r0
            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
    2928:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
    292a:	492c      	ldr	r1, [pc, #176]	; (29dc <xTaskPriorityInherit+0xbc>)
    292c:	f8d1 10c4 	ldr.w	r1, [r1, #196]	; 0xc4
    2930:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
    2932:	428a      	cmp	r2, r1
    2934:	d244      	bcs.n	29c0 <xTaskPriorityInherit+0xa0>
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == ( ( TickType_t ) 0U ) )
    2936:	6981      	ldr	r1, [r0, #24]
    2938:	2900      	cmp	r1, #0
    293a:	db06      	blt.n	294a <xTaskPriorityInherit+0x2a>
                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority );
    293c:	4927      	ldr	r1, [pc, #156]	; (29dc <xTaskPriorityInherit+0xbc>)
    293e:	f8d1 10c4 	ldr.w	r1, [r1, #196]	; 0xc4
    2942:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
    2944:	f1c1 0105 	rsb	r1, r1, #5
    2948:	6181      	str	r1, [r0, #24]
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
    294a:	6960      	ldr	r0, [r4, #20]
    294c:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    2950:	0091      	lsls	r1, r2, #2
    2952:	4a23      	ldr	r2, [pc, #140]	; (29e0 <xTaskPriorityInherit+0xc0>)
    2954:	440a      	add	r2, r1
    2956:	4290      	cmp	r0, r2
    2958:	d006      	beq.n	2968 <xTaskPriorityInherit+0x48>
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    295a:	4a20      	ldr	r2, [pc, #128]	; (29dc <xTaskPriorityInherit+0xbc>)
    295c:	f8d2 20c4 	ldr.w	r2, [r2, #196]	; 0xc4
    2960:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    2962:	62e2      	str	r2, [r4, #44]	; 0x2c
                xReturn = pdTRUE;
    2964:	2001      	movs	r0, #1
    2966:	bd70      	pop	{r4, r5, r6, pc}
                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2968:	1d25      	adds	r5, r4, #4
    296a:	4628      	mov	r0, r5
    296c:	4b1d      	ldr	r3, [pc, #116]	; (29e4 <xTaskPriorityInherit+0xc4>)
    296e:	4798      	blx	r3
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    2970:	4a1a      	ldr	r2, [pc, #104]	; (29dc <xTaskPriorityInherit+0xbc>)
    2972:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
    2976:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2978:	62e3      	str	r3, [r4, #44]	; 0x2c
                    prvAddTaskToReadyList( pxMutexHolderTCB );
    297a:	f8d2 20d0 	ldr.w	r2, [r2, #208]	; 0xd0
    297e:	4293      	cmp	r3, r2
    2980:	d902      	bls.n	2988 <xTaskPriorityInherit+0x68>
    2982:	4a16      	ldr	r2, [pc, #88]	; (29dc <xTaskPriorityInherit+0xbc>)
    2984:	f8c2 30d0 	str.w	r3, [r2, #208]	; 0xd0
    2988:	4a14      	ldr	r2, [pc, #80]	; (29dc <xTaskPriorityInherit+0xbc>)
    298a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    298e:	0099      	lsls	r1, r3, #2
    2990:	4411      	add	r1, r2
    2992:	6acb      	ldr	r3, [r1, #44]	; 0x2c
    2994:	60a3      	str	r3, [r4, #8]
    2996:	6899      	ldr	r1, [r3, #8]
    2998:	60e1      	str	r1, [r4, #12]
    299a:	6899      	ldr	r1, [r3, #8]
    299c:	604d      	str	r5, [r1, #4]
    299e:	609d      	str	r5, [r3, #8]
    29a0:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    29a2:	f102 0028 	add.w	r0, r2, #40	; 0x28
    29a6:	008b      	lsls	r3, r1, #2
    29a8:	185e      	adds	r6, r3, r1
    29aa:	00b5      	lsls	r5, r6, #2
    29ac:	4428      	add	r0, r5
    29ae:	6160      	str	r0, [r4, #20]
    29b0:	4628      	mov	r0, r5
    29b2:	4410      	add	r0, r2
    29b4:	6a80      	ldr	r0, [r0, #40]	; 0x28
    29b6:	3001      	adds	r0, #1
    29b8:	442a      	add	r2, r5
    29ba:	6290      	str	r0, [r2, #40]	; 0x28
                xReturn = pdTRUE;
    29bc:	2001      	movs	r0, #1
    29be:	bd70      	pop	{r4, r5, r6, pc}
                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
    29c0:	6c42      	ldr	r2, [r0, #68]	; 0x44
    29c2:	4b06      	ldr	r3, [pc, #24]	; (29dc <xTaskPriorityInherit+0xbc>)
    29c4:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
    29c8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    29ca:	429a      	cmp	r2, r3
    29cc:	d201      	bcs.n	29d2 <xTaskPriorityInherit+0xb2>
                    xReturn = pdTRUE;
    29ce:	2001      	movs	r0, #1
    }
    29d0:	bd70      	pop	{r4, r5, r6, pc}
        BaseType_t xReturn = pdFALSE;
    29d2:	2000      	movs	r0, #0
    29d4:	bd70      	pop	{r4, r5, r6, pc}
    29d6:	2000      	movs	r0, #0
    29d8:	4770      	bx	lr
    29da:	bf00      	nop
    29dc:	20000afc 	.word	0x20000afc
    29e0:	20000b24 	.word	0x20000b24
    29e4:	00000e45 	.word	0x00000e45

000029e8 <xTaskPriorityDisinherit>:
        if( pxMutexHolder != NULL )
    29e8:	2800      	cmp	r0, #0
    29ea:	d04f      	beq.n	2a8c <xTaskPriorityDisinherit+0xa4>
    {
    29ec:	b570      	push	{r4, r5, r6, lr}
    29ee:	4604      	mov	r4, r0
            configASSERT( pxTCB == pxCurrentTCB );
    29f0:	4b29      	ldr	r3, [pc, #164]	; (2a98 <xTaskPriorityDisinherit+0xb0>)
    29f2:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
    29f6:	4298      	cmp	r0, r3
    29f8:	d008      	beq.n	2a0c <xTaskPriorityDisinherit+0x24>
    29fa:	f04f 0380 	mov.w	r3, #128	; 0x80
    29fe:	f383 8811 	msr	BASEPRI, r3
    2a02:	f3bf 8f6f 	isb	sy
    2a06:	f3bf 8f4f 	dsb	sy
    2a0a:	e7fe      	b.n	2a0a <xTaskPriorityDisinherit+0x22>
            configASSERT( pxTCB->uxMutexesHeld );
    2a0c:	6c83      	ldr	r3, [r0, #72]	; 0x48
    2a0e:	b943      	cbnz	r3, 2a22 <xTaskPriorityDisinherit+0x3a>
    2a10:	f04f 0380 	mov.w	r3, #128	; 0x80
    2a14:	f383 8811 	msr	BASEPRI, r3
    2a18:	f3bf 8f6f 	isb	sy
    2a1c:	f3bf 8f4f 	dsb	sy
    2a20:	e7fe      	b.n	2a20 <xTaskPriorityDisinherit+0x38>
            ( pxTCB->uxMutexesHeld )--;
    2a22:	3b01      	subs	r3, #1
    2a24:	6483      	str	r3, [r0, #72]	; 0x48
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2a26:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
    2a28:	6c42      	ldr	r2, [r0, #68]	; 0x44
    2a2a:	4291      	cmp	r1, r2
    2a2c:	d030      	beq.n	2a90 <xTaskPriorityDisinherit+0xa8>
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    2a2e:	2b00      	cmp	r3, #0
    2a30:	d130      	bne.n	2a94 <xTaskPriorityDisinherit+0xac>
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2a32:	1d05      	adds	r5, r0, #4
    2a34:	4628      	mov	r0, r5
    2a36:	4b19      	ldr	r3, [pc, #100]	; (2a9c <xTaskPriorityDisinherit+0xb4>)
    2a38:	4798      	blx	r3
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    2a3a:	6c63      	ldr	r3, [r4, #68]	; 0x44
    2a3c:	62e3      	str	r3, [r4, #44]	; 0x2c
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority );
    2a3e:	f1c3 0205 	rsb	r2, r3, #5
    2a42:	61a2      	str	r2, [r4, #24]
                    prvAddTaskToReadyList( pxTCB );
    2a44:	4a14      	ldr	r2, [pc, #80]	; (2a98 <xTaskPriorityDisinherit+0xb0>)
    2a46:	f8d2 20d0 	ldr.w	r2, [r2, #208]	; 0xd0
    2a4a:	4293      	cmp	r3, r2
    2a4c:	d902      	bls.n	2a54 <xTaskPriorityDisinherit+0x6c>
    2a4e:	4a12      	ldr	r2, [pc, #72]	; (2a98 <xTaskPriorityDisinherit+0xb0>)
    2a50:	f8c2 30d0 	str.w	r3, [r2, #208]	; 0xd0
    2a54:	4a10      	ldr	r2, [pc, #64]	; (2a98 <xTaskPriorityDisinherit+0xb0>)
    2a56:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    2a5a:	0099      	lsls	r1, r3, #2
    2a5c:	4411      	add	r1, r2
    2a5e:	6acb      	ldr	r3, [r1, #44]	; 0x2c
    2a60:	60a3      	str	r3, [r4, #8]
    2a62:	6899      	ldr	r1, [r3, #8]
    2a64:	60e1      	str	r1, [r4, #12]
    2a66:	6899      	ldr	r1, [r3, #8]
    2a68:	604d      	str	r5, [r1, #4]
    2a6a:	609d      	str	r5, [r3, #8]
    2a6c:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    2a6e:	f102 0028 	add.w	r0, r2, #40	; 0x28
    2a72:	008b      	lsls	r3, r1, #2
    2a74:	185e      	adds	r6, r3, r1
    2a76:	00b5      	lsls	r5, r6, #2
    2a78:	4428      	add	r0, r5
    2a7a:	6160      	str	r0, [r4, #20]
    2a7c:	4628      	mov	r0, r5
    2a7e:	4410      	add	r0, r2
    2a80:	6a80      	ldr	r0, [r0, #40]	; 0x28
    2a82:	3001      	adds	r0, #1
    2a84:	442a      	add	r2, r5
    2a86:	6290      	str	r0, [r2, #40]	; 0x28
                    xReturn = pdTRUE;
    2a88:	2001      	movs	r0, #1
    2a8a:	bd70      	pop	{r4, r5, r6, pc}
        BaseType_t xReturn = pdFALSE;
    2a8c:	2000      	movs	r0, #0
    2a8e:	4770      	bx	lr
    2a90:	2000      	movs	r0, #0
    2a92:	bd70      	pop	{r4, r5, r6, pc}
    2a94:	2000      	movs	r0, #0
    }
    2a96:	bd70      	pop	{r4, r5, r6, pc}
    2a98:	20000afc 	.word	0x20000afc
    2a9c:	00000e45 	.word	0x00000e45

00002aa0 <vTaskPriorityDisinheritAfterTimeout>:
        if( pxMutexHolder != NULL )
    2aa0:	2800      	cmp	r0, #0
    2aa2:	d05b      	beq.n	2b5c <vTaskPriorityDisinheritAfterTimeout+0xbc>
    {
    2aa4:	b570      	push	{r4, r5, r6, lr}
    2aa6:	4604      	mov	r4, r0
            configASSERT( pxTCB->uxMutexesHeld );
    2aa8:	6c80      	ldr	r0, [r0, #72]	; 0x48
    2aaa:	b940      	cbnz	r0, 2abe <vTaskPriorityDisinheritAfterTimeout+0x1e>
    2aac:	f04f 0380 	mov.w	r3, #128	; 0x80
    2ab0:	f383 8811 	msr	BASEPRI, r3
    2ab4:	f3bf 8f6f 	isb	sy
    2ab8:	f3bf 8f4f 	dsb	sy
    2abc:	e7fe      	b.n	2abc <vTaskPriorityDisinheritAfterTimeout+0x1c>
            if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
    2abe:	6c62      	ldr	r2, [r4, #68]	; 0x44
    2ac0:	428a      	cmp	r2, r1
    2ac2:	d200      	bcs.n	2ac6 <vTaskPriorityDisinheritAfterTimeout+0x26>
                uxPriorityToUse = uxHighestPriorityWaitingTask;
    2ac4:	460a      	mov	r2, r1
            if( pxTCB->uxPriority != uxPriorityToUse )
    2ac6:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    2ac8:	428a      	cmp	r2, r1
    2aca:	d001      	beq.n	2ad0 <vTaskPriorityDisinheritAfterTimeout+0x30>
                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
    2acc:	2801      	cmp	r0, #1
    2ace:	d000      	beq.n	2ad2 <vTaskPriorityDisinheritAfterTimeout+0x32>
    2ad0:	bd70      	pop	{r4, r5, r6, pc}
                    configASSERT( pxTCB != pxCurrentTCB );
    2ad2:	4823      	ldr	r0, [pc, #140]	; (2b60 <vTaskPriorityDisinheritAfterTimeout+0xc0>)
    2ad4:	f8d0 00c4 	ldr.w	r0, [r0, #196]	; 0xc4
    2ad8:	4284      	cmp	r4, r0
    2ada:	d108      	bne.n	2aee <vTaskPriorityDisinheritAfterTimeout+0x4e>
    2adc:	f04f 0380 	mov.w	r3, #128	; 0x80
    2ae0:	f383 8811 	msr	BASEPRI, r3
    2ae4:	f3bf 8f6f 	isb	sy
    2ae8:	f3bf 8f4f 	dsb	sy
    2aec:	e7fe      	b.n	2aec <vTaskPriorityDisinheritAfterTimeout+0x4c>
                    pxTCB->uxPriority = uxPriorityToUse;
    2aee:	62e2      	str	r2, [r4, #44]	; 0x2c
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == ( ( TickType_t ) 0U ) )
    2af0:	69a0      	ldr	r0, [r4, #24]
    2af2:	2800      	cmp	r0, #0
    2af4:	db02      	blt.n	2afc <vTaskPriorityDisinheritAfterTimeout+0x5c>
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse );
    2af6:	f1c2 0205 	rsb	r2, r2, #5
    2afa:	61a2      	str	r2, [r4, #24]
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    2afc:	6963      	ldr	r3, [r4, #20]
    2afe:	eb01 0181 	add.w	r1, r1, r1, lsl #2
    2b02:	0088      	lsls	r0, r1, #2
    2b04:	4a17      	ldr	r2, [pc, #92]	; (2b64 <vTaskPriorityDisinheritAfterTimeout+0xc4>)
    2b06:	4402      	add	r2, r0
    2b08:	4293      	cmp	r3, r2
    2b0a:	d1e1      	bne.n	2ad0 <vTaskPriorityDisinheritAfterTimeout+0x30>
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2b0c:	1d25      	adds	r5, r4, #4
    2b0e:	4628      	mov	r0, r5
    2b10:	4b15      	ldr	r3, [pc, #84]	; (2b68 <vTaskPriorityDisinheritAfterTimeout+0xc8>)
    2b12:	4798      	blx	r3
                        prvAddTaskToReadyList( pxTCB );
    2b14:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    2b16:	4a12      	ldr	r2, [pc, #72]	; (2b60 <vTaskPriorityDisinheritAfterTimeout+0xc0>)
    2b18:	f8d2 20d0 	ldr.w	r2, [r2, #208]	; 0xd0
    2b1c:	4293      	cmp	r3, r2
    2b1e:	d902      	bls.n	2b26 <vTaskPriorityDisinheritAfterTimeout+0x86>
    2b20:	4a0f      	ldr	r2, [pc, #60]	; (2b60 <vTaskPriorityDisinheritAfterTimeout+0xc0>)
    2b22:	f8c2 30d0 	str.w	r3, [r2, #208]	; 0xd0
    2b26:	4a0e      	ldr	r2, [pc, #56]	; (2b60 <vTaskPriorityDisinheritAfterTimeout+0xc0>)
    2b28:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    2b2c:	0099      	lsls	r1, r3, #2
    2b2e:	4411      	add	r1, r2
    2b30:	6acb      	ldr	r3, [r1, #44]	; 0x2c
    2b32:	60a3      	str	r3, [r4, #8]
    2b34:	6899      	ldr	r1, [r3, #8]
    2b36:	60e1      	str	r1, [r4, #12]
    2b38:	6899      	ldr	r1, [r3, #8]
    2b3a:	604d      	str	r5, [r1, #4]
    2b3c:	609d      	str	r5, [r3, #8]
    2b3e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    2b40:	f102 0028 	add.w	r0, r2, #40	; 0x28
    2b44:	008b      	lsls	r3, r1, #2
    2b46:	185e      	adds	r6, r3, r1
    2b48:	00b5      	lsls	r5, r6, #2
    2b4a:	4428      	add	r0, r5
    2b4c:	6160      	str	r0, [r4, #20]
    2b4e:	4628      	mov	r0, r5
    2b50:	4410      	add	r0, r2
    2b52:	6a80      	ldr	r0, [r0, #40]	; 0x28
    2b54:	3001      	adds	r0, #1
    2b56:	442a      	add	r2, r5
    2b58:	6290      	str	r0, [r2, #40]	; 0x28
    }
    2b5a:	e7b9      	b.n	2ad0 <vTaskPriorityDisinheritAfterTimeout+0x30>
    2b5c:	4770      	bx	lr
    2b5e:	bf00      	nop
    2b60:	20000afc 	.word	0x20000afc
    2b64:	20000b24 	.word	0x20000b24
    2b68:	00000e45 	.word	0x00000e45

00002b6c <pvTaskIncrementMutexHeldCount>:
        pxTCB = pxCurrentTCB;
    2b6c:	4b03      	ldr	r3, [pc, #12]	; (2b7c <pvTaskIncrementMutexHeldCount+0x10>)
    2b6e:	f8d3 00c4 	ldr.w	r0, [r3, #196]	; 0xc4
        if( pxTCB != NULL )
    2b72:	b110      	cbz	r0, 2b7a <pvTaskIncrementMutexHeldCount+0xe>
            ( pxTCB->uxMutexesHeld )++;
    2b74:	6c83      	ldr	r3, [r0, #72]	; 0x48
    2b76:	3301      	adds	r3, #1
    2b78:	6483      	str	r3, [r0, #72]	; 0x48
    }
    2b7a:	4770      	bx	lr
    2b7c:	20000afc 	.word	0x20000afc

00002b80 <vApplicationGetIdleTaskMemory>:
 * configKERNEL_PROVIDED_STATIC_MEMORY to 0 or leaving it undefined.
 */
    void vApplicationGetIdleTaskMemory( StaticTask_t ** ppxIdleTaskTCBBuffer,
                                        StackType_t ** ppxIdleTaskStackBuffer,
                                        configSTACK_DEPTH_TYPE * puxIdleTaskStackSize )
    {
    2b80:	b410      	push	{r4}
        static StaticTask_t xIdleTaskTCB;
        static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

        *ppxIdleTaskTCBBuffer = &( xIdleTaskTCB );
    2b82:	4b06      	ldr	r3, [pc, #24]	; (2b9c <vApplicationGetIdleTaskMemory+0x1c>)
    2b84:	f103 04e8 	add.w	r4, r3, #232	; 0xe8
    2b88:	6004      	str	r4, [r0, #0]
        *ppxIdleTaskStackBuffer = &( uxIdleTaskStack[ 0 ] );
    2b8a:	f503 739e 	add.w	r3, r3, #316	; 0x13c
    2b8e:	600b      	str	r3, [r1, #0]
        *puxIdleTaskStackSize = configMINIMAL_STACK_SIZE;
    2b90:	2340      	movs	r3, #64	; 0x40
    2b92:	6013      	str	r3, [r2, #0]
    }
    2b94:	f85d 4b04 	ldr.w	r4, [sp], #4
    2b98:	4770      	bx	lr
    2b9a:	bf00      	nop
    2b9c:	20000afc 	.word	0x20000afc

00002ba0 <prvCreateIdleTasks>:
{
    2ba0:	b530      	push	{r4, r5, lr}
    2ba2:	b08b      	sub	sp, #44	; 0x2c
    for( xIdleTaskNameIndex = ( BaseType_t ) 0; xIdleTaskNameIndex < ( BaseType_t ) configMAX_TASK_NAME_LEN; xIdleTaskNameIndex++ )
    2ba4:	2300      	movs	r3, #0
    2ba6:	2b07      	cmp	r3, #7
    2ba8:	dc08      	bgt.n	2bbc <prvCreateIdleTasks+0x1c>
        cIdleName[ xIdleTaskNameIndex ] = configIDLE_TASK_NAME[ xIdleTaskNameIndex ];
    2baa:	4a15      	ldr	r2, [pc, #84]	; (2c00 <prvCreateIdleTasks+0x60>)
    2bac:	5cd2      	ldrb	r2, [r2, r3]
    2bae:	a90a      	add	r1, sp, #40	; 0x28
    2bb0:	4419      	add	r1, r3
    2bb2:	f801 2c08 	strb.w	r2, [r1, #-8]
        if( cIdleName[ xIdleTaskNameIndex ] == ( char ) 0x00 )
    2bb6:	b10a      	cbz	r2, 2bbc <prvCreateIdleTasks+0x1c>
    for( xIdleTaskNameIndex = ( BaseType_t ) 0; xIdleTaskNameIndex < ( BaseType_t ) configMAX_TASK_NAME_LEN; xIdleTaskNameIndex++ )
    2bb8:	3301      	adds	r3, #1
    2bba:	e7f4      	b.n	2ba6 <prvCreateIdleTasks+0x6>
                xReturn = pdFAIL;
    2bbc:	2500      	movs	r5, #0
    2bbe:	2001      	movs	r0, #1
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
    2bc0:	2d00      	cmp	r5, #0
    2bc2:	dd01      	ble.n	2bc8 <prvCreateIdleTasks+0x28>
}
    2bc4:	b00b      	add	sp, #44	; 0x2c
    2bc6:	bd30      	pop	{r4, r5, pc}
            StaticTask_t * pxIdleTaskTCBBuffer = NULL;
    2bc8:	2400      	movs	r4, #0
    2bca:	9405      	str	r4, [sp, #20]
            StackType_t * pxIdleTaskStackBuffer = NULL;
    2bcc:	9406      	str	r4, [sp, #24]
                vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &uxIdleTaskStackSize );
    2bce:	aa07      	add	r2, sp, #28
    2bd0:	a906      	add	r1, sp, #24
    2bd2:	a805      	add	r0, sp, #20
    2bd4:	4b0b      	ldr	r3, [pc, #44]	; (2c04 <prvCreateIdleTasks+0x64>)
    2bd6:	4798      	blx	r3
            xIdleTaskHandles[ xCoreID ] = xTaskCreateStatic( pxIdleTaskFunction,
    2bd8:	9b05      	ldr	r3, [sp, #20]
    2bda:	9302      	str	r3, [sp, #8]
    2bdc:	9b06      	ldr	r3, [sp, #24]
    2bde:	9301      	str	r3, [sp, #4]
    2be0:	9400      	str	r4, [sp, #0]
    2be2:	4623      	mov	r3, r4
    2be4:	9a07      	ldr	r2, [sp, #28]
    2be6:	a908      	add	r1, sp, #32
    2be8:	4807      	ldr	r0, [pc, #28]	; (2c08 <prvCreateIdleTasks+0x68>)
    2bea:	4c08      	ldr	r4, [pc, #32]	; (2c0c <prvCreateIdleTasks+0x6c>)
    2bec:	47a0      	blx	r4
            if( xIdleTaskHandles[ xCoreID ] != NULL )
    2bee:	b120      	cbz	r0, 2bfa <prvCreateIdleTasks+0x5a>
                xReturn = pdPASS;
    2bf0:	2001      	movs	r0, #1
        if( xReturn == pdFAIL )
    2bf2:	2800      	cmp	r0, #0
    2bf4:	d0e6      	beq.n	2bc4 <prvCreateIdleTasks+0x24>
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
    2bf6:	3501      	adds	r5, #1
    2bf8:	e7e2      	b.n	2bc0 <prvCreateIdleTasks+0x20>
                xReturn = pdFAIL;
    2bfa:	2000      	movs	r0, #0
    2bfc:	e7f9      	b.n	2bf2 <prvCreateIdleTasks+0x52>
    2bfe:	bf00      	nop
    2c00:	00003250 	.word	0x00003250
    2c04:	00002b81 	.word	0x00002b81
    2c08:	00001efd 	.word	0x00001efd
    2c0c:	00002261 	.word	0x00002261

00002c10 <vTaskStartScheduler>:
{
    2c10:	b508      	push	{r3, lr}
    xReturn = prvCreateIdleTasks();
    2c12:	4b17      	ldr	r3, [pc, #92]	; (2c70 <vTaskStartScheduler+0x60>)
    2c14:	4798      	blx	r3
        if( xReturn == pdPASS )
    2c16:	2801      	cmp	r0, #1
    2c18:	d007      	beq.n	2c2a <vTaskStartScheduler+0x1a>
    if( xReturn == pdPASS )
    2c1a:	2801      	cmp	r0, #1
    2c1c:	d008      	beq.n	2c30 <vTaskStartScheduler+0x20>
        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
    2c1e:	f1b0 3fff 	cmp.w	r0, #4294967295
    2c22:	d01b      	beq.n	2c5c <vTaskStartScheduler+0x4c>
    ( void ) uxTopUsedPriority;
    2c24:	4b13      	ldr	r3, [pc, #76]	; (2c74 <vTaskStartScheduler+0x64>)
    2c26:	681b      	ldr	r3, [r3, #0]
    2c28:	bd08      	pop	{r3, pc}
            xReturn = xTimerCreateTimerTask();
    2c2a:	4b13      	ldr	r3, [pc, #76]	; (2c78 <vTaskStartScheduler+0x68>)
    2c2c:	4798      	blx	r3
    2c2e:	e7f4      	b.n	2c1a <vTaskStartScheduler+0xa>
    2c30:	f04f 0380 	mov.w	r3, #128	; 0x80
    2c34:	f383 8811 	msr	BASEPRI, r3
    2c38:	f3bf 8f6f 	isb	sy
    2c3c:	f3bf 8f4f 	dsb	sy
        xNextTaskUnblockTime = portMAX_DELAY;
    2c40:	4b0e      	ldr	r3, [pc, #56]	; (2c7c <vTaskStartScheduler+0x6c>)
    2c42:	f04f 32ff 	mov.w	r2, #4294967295
    2c46:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
        xSchedulerRunning = pdTRUE;
    2c4a:	2201      	movs	r2, #1
    2c4c:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    2c50:	2200      	movs	r2, #0
    2c52:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
        ( void ) xPortStartScheduler();
    2c56:	4b0a      	ldr	r3, [pc, #40]	; (2c80 <vTaskStartScheduler+0x70>)
    2c58:	4798      	blx	r3
    2c5a:	e7e3      	b.n	2c24 <vTaskStartScheduler+0x14>
    2c5c:	f04f 0380 	mov.w	r3, #128	; 0x80
    2c60:	f383 8811 	msr	BASEPRI, r3
    2c64:	f3bf 8f6f 	isb	sy
    2c68:	f3bf 8f4f 	dsb	sy
    2c6c:	e7fe      	b.n	2c6c <vTaskStartScheduler+0x5c>
    2c6e:	bf00      	nop
    2c70:	00002ba1 	.word	0x00002ba1
    2c74:	20000008 	.word	0x20000008
    2c78:	00002ff9 	.word	0x00002ff9
    2c7c:	20000afc 	.word	0x20000afc
    2c80:	00001069 	.word	0x00001069

00002c84 <vApplicationGetTimerTaskMemory>:
 * configKERNEL_PROVIDED_STATIC_MEMORY to 0 or leaving it undefined.
 */
    void vApplicationGetTimerTaskMemory( StaticTask_t ** ppxTimerTaskTCBBuffer,
                                         StackType_t ** ppxTimerTaskStackBuffer,
                                         configSTACK_DEPTH_TYPE * puxTimerTaskStackSize )
    {
    2c84:	b410      	push	{r4}
        static StaticTask_t xTimerTaskTCB;
        static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

        *ppxTimerTaskTCBBuffer = &( xTimerTaskTCB );
    2c86:	4b06      	ldr	r3, [pc, #24]	; (2ca0 <vApplicationGetTimerTaskMemory+0x1c>)
    2c88:	f503 740f 	add.w	r4, r3, #572	; 0x23c
    2c8c:	6004      	str	r4, [r0, #0]
        *ppxTimerTaskStackBuffer = &( uxTimerTaskStack[ 0 ] );
    2c8e:	f503 7324 	add.w	r3, r3, #656	; 0x290
    2c92:	600b      	str	r3, [r1, #0]
        *puxTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
    2c94:	2340      	movs	r3, #64	; 0x40
    2c96:	6013      	str	r3, [r2, #0]
    }
    2c98:	f85d 4b04 	ldr.w	r4, [sp], #4
    2c9c:	4770      	bx	lr
    2c9e:	bf00      	nop
    2ca0:	20000afc 	.word	0x20000afc

00002ca4 <prvGetNextExpireTime>:
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    2ca4:	4b06      	ldr	r3, [pc, #24]	; (2cc0 <prvGetNextExpireTime+0x1c>)
    2ca6:	681a      	ldr	r2, [r3, #0]
    2ca8:	6813      	ldr	r3, [r2, #0]
    2caa:	b92b      	cbnz	r3, 2cb8 <prvGetNextExpireTime+0x14>
    2cac:	2301      	movs	r3, #1
    2cae:	6003      	str	r3, [r0, #0]

        if( *pxListWasEmpty == pdFALSE )
    2cb0:	b923      	cbnz	r3, 2cbc <prvGetNextExpireTime+0x18>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2cb2:	68d3      	ldr	r3, [r2, #12]
    2cb4:	6818      	ldr	r0, [r3, #0]
    2cb6:	4770      	bx	lr
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    2cb8:	2300      	movs	r3, #0
    2cba:	e7f8      	b.n	2cae <prvGetNextExpireTime+0xa>
        }
        else
        {
            /* Ensure the task unblocks when the tick count rolls over. */
            xNextExpireTime = ( TickType_t ) 0U;
    2cbc:	2000      	movs	r0, #0
        }

        return xNextExpireTime;
    }
    2cbe:	4770      	bx	lr
    2cc0:	20000e8c 	.word	0x20000e8c

00002cc4 <prvInsertTimerInActiveList>:

    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
    2cc4:	b508      	push	{r3, lr}
        BaseType_t xProcessTimerNow = pdFALSE;

        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    2cc6:	6041      	str	r1, [r0, #4]
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2cc8:	6100      	str	r0, [r0, #16]

        if( xNextExpiryTime <= xTimeNow )
    2cca:	4291      	cmp	r1, r2
    2ccc:	d80c      	bhi.n	2ce8 <prvInsertTimerInActiveList+0x24>
        {
            /* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
    2cce:	1ad2      	subs	r2, r2, r3
    2cd0:	6983      	ldr	r3, [r0, #24]
    2cd2:	429a      	cmp	r2, r3
    2cd4:	d301      	bcc.n	2cda <prvInsertTimerInActiveList+0x16>
            {
                /* The time between a command being issued and the command being
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
    2cd6:	2001      	movs	r0, #1
    2cd8:	bd08      	pop	{r3, pc}
            }
            else
            {
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    2cda:	1d01      	adds	r1, r0, #4
    2cdc:	4b09      	ldr	r3, [pc, #36]	; (2d04 <prvInsertTimerInActiveList+0x40>)
    2cde:	6858      	ldr	r0, [r3, #4]
    2ce0:	4b09      	ldr	r3, [pc, #36]	; (2d08 <prvInsertTimerInActiveList+0x44>)
    2ce2:	4798      	blx	r3
        BaseType_t xProcessTimerNow = pdFALSE;
    2ce4:	2000      	movs	r0, #0
    2ce6:	bd08      	pop	{r3, pc}
            }
        }
        else
        {
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    2ce8:	429a      	cmp	r2, r3
    2cea:	d201      	bcs.n	2cf0 <prvInsertTimerInActiveList+0x2c>
    2cec:	4299      	cmp	r1, r3
    2cee:	d206      	bcs.n	2cfe <prvInsertTimerInActiveList+0x3a>
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
            }
            else
            {
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2cf0:	1d01      	adds	r1, r0, #4
    2cf2:	4b04      	ldr	r3, [pc, #16]	; (2d04 <prvInsertTimerInActiveList+0x40>)
    2cf4:	6818      	ldr	r0, [r3, #0]
    2cf6:	4b04      	ldr	r3, [pc, #16]	; (2d08 <prvInsertTimerInActiveList+0x44>)
    2cf8:	4798      	blx	r3
        BaseType_t xProcessTimerNow = pdFALSE;
    2cfa:	2000      	movs	r0, #0
    2cfc:	bd08      	pop	{r3, pc}
                xProcessTimerNow = pdTRUE;
    2cfe:	2001      	movs	r0, #1
            }
        }

        return xProcessTimerNow;
    }
    2d00:	bd08      	pop	{r3, pc}
    2d02:	bf00      	nop
    2d04:	20000e8c 	.word	0x20000e8c
    2d08:	00000e11 	.word	0x00000e11

00002d0c <prvReloadTimer>:
    {
    2d0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2d0e:	4604      	mov	r4, r0
    2d10:	460d      	mov	r5, r1
    2d12:	4617      	mov	r7, r2
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
    2d14:	e004      	b.n	2d20 <prvReloadTimer+0x14>
            xExpiredTime += pxTimer->xTimerPeriodInTicks;
    2d16:	69a3      	ldr	r3, [r4, #24]
    2d18:	441d      	add	r5, r3
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2d1a:	6a23      	ldr	r3, [r4, #32]
    2d1c:	4620      	mov	r0, r4
    2d1e:	4798      	blx	r3
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
    2d20:	69a1      	ldr	r1, [r4, #24]
    2d22:	462b      	mov	r3, r5
    2d24:	463a      	mov	r2, r7
    2d26:	4429      	add	r1, r5
    2d28:	4620      	mov	r0, r4
    2d2a:	4e02      	ldr	r6, [pc, #8]	; (2d34 <prvReloadTimer+0x28>)
    2d2c:	47b0      	blx	r6
    2d2e:	2800      	cmp	r0, #0
    2d30:	d1f1      	bne.n	2d16 <prvReloadTimer+0xa>
    }
    2d32:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2d34:	00002cc5 	.word	0x00002cc5

00002d38 <prvProcessExpiredTimer>:
    {
    2d38:	b570      	push	{r4, r5, r6, lr}
    2d3a:	4605      	mov	r5, r0
    2d3c:	460e      	mov	r6, r1
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    2d3e:	4b0d      	ldr	r3, [pc, #52]	; (2d74 <prvProcessExpiredTimer+0x3c>)
    2d40:	681b      	ldr	r3, [r3, #0]
    2d42:	68db      	ldr	r3, [r3, #12]
    2d44:	68dc      	ldr	r4, [r3, #12]
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2d46:	1d20      	adds	r0, r4, #4
    2d48:	4b0b      	ldr	r3, [pc, #44]	; (2d78 <prvProcessExpiredTimer+0x40>)
    2d4a:	4798      	blx	r3
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0U )
    2d4c:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
    2d50:	f013 0f04 	tst.w	r3, #4
    2d54:	d107      	bne.n	2d66 <prvProcessExpiredTimer+0x2e>
            pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    2d56:	f023 0301 	bic.w	r3, r3, #1
    2d5a:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2d5e:	6a23      	ldr	r3, [r4, #32]
    2d60:	4620      	mov	r0, r4
    2d62:	4798      	blx	r3
    2d64:	bd70      	pop	{r4, r5, r6, pc}
            prvReloadTimer( pxTimer, xNextExpireTime, xTimeNow );
    2d66:	4632      	mov	r2, r6
    2d68:	4629      	mov	r1, r5
    2d6a:	4620      	mov	r0, r4
    2d6c:	4b03      	ldr	r3, [pc, #12]	; (2d7c <prvProcessExpiredTimer+0x44>)
    2d6e:	4798      	blx	r3
    2d70:	e7f5      	b.n	2d5e <prvProcessExpiredTimer+0x26>
    2d72:	bf00      	nop
    2d74:	20000e8c 	.word	0x20000e8c
    2d78:	00000e45 	.word	0x00000e45
    2d7c:	00002d0d 	.word	0x00002d0d

00002d80 <prvSwitchTimerLists>:
        }
    }
/*-----------------------------------------------------------*/

    static void prvSwitchTimerLists( void )
    {
    2d80:	b508      	push	{r3, lr}

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2d82:	e005      	b.n	2d90 <prvSwitchTimerLists+0x10>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2d84:	68db      	ldr	r3, [r3, #12]

            /* Process the expired timer.  For auto-reload timers, be careful to
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
    2d86:	f04f 31ff 	mov.w	r1, #4294967295
    2d8a:	6818      	ldr	r0, [r3, #0]
    2d8c:	4b05      	ldr	r3, [pc, #20]	; (2da4 <prvSwitchTimerLists+0x24>)
    2d8e:	4798      	blx	r3
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2d90:	4b05      	ldr	r3, [pc, #20]	; (2da8 <prvSwitchTimerLists+0x28>)
    2d92:	681b      	ldr	r3, [r3, #0]
    2d94:	681a      	ldr	r2, [r3, #0]
    2d96:	2a00      	cmp	r2, #0
    2d98:	d1f4      	bne.n	2d84 <prvSwitchTimerLists+0x4>
        }

        pxTemp = pxCurrentTimerList;
        pxCurrentTimerList = pxOverflowTimerList;
    2d9a:	4a03      	ldr	r2, [pc, #12]	; (2da8 <prvSwitchTimerLists+0x28>)
    2d9c:	6851      	ldr	r1, [r2, #4]
    2d9e:	6011      	str	r1, [r2, #0]
        pxOverflowTimerList = pxTemp;
    2da0:	6053      	str	r3, [r2, #4]
    2da2:	bd08      	pop	{r3, pc}
    2da4:	00002d39 	.word	0x00002d39
    2da8:	20000e8c 	.word	0x20000e8c

00002dac <prvSampleTimeNow>:
    {
    2dac:	b538      	push	{r3, r4, r5, lr}
    2dae:	4605      	mov	r5, r0
        xTimeNow = xTaskGetTickCount();
    2db0:	4b08      	ldr	r3, [pc, #32]	; (2dd4 <prvSampleTimeNow+0x28>)
    2db2:	4798      	blx	r3
    2db4:	4604      	mov	r4, r0
        if( xTimeNow < xLastTime )
    2db6:	4b08      	ldr	r3, [pc, #32]	; (2dd8 <prvSampleTimeNow+0x2c>)
    2db8:	689b      	ldr	r3, [r3, #8]
    2dba:	4298      	cmp	r0, r3
    2dbc:	d305      	bcc.n	2dca <prvSampleTimeNow+0x1e>
            *pxTimerListsWereSwitched = pdFALSE;
    2dbe:	2300      	movs	r3, #0
    2dc0:	602b      	str	r3, [r5, #0]
        xLastTime = xTimeNow;
    2dc2:	4b05      	ldr	r3, [pc, #20]	; (2dd8 <prvSampleTimeNow+0x2c>)
    2dc4:	609c      	str	r4, [r3, #8]
    }
    2dc6:	4620      	mov	r0, r4
    2dc8:	bd38      	pop	{r3, r4, r5, pc}
            prvSwitchTimerLists();
    2dca:	4b04      	ldr	r3, [pc, #16]	; (2ddc <prvSampleTimeNow+0x30>)
    2dcc:	4798      	blx	r3
            *pxTimerListsWereSwitched = pdTRUE;
    2dce:	2301      	movs	r3, #1
    2dd0:	602b      	str	r3, [r5, #0]
    2dd2:	e7f6      	b.n	2dc2 <prvSampleTimeNow+0x16>
    2dd4:	000022a9 	.word	0x000022a9
    2dd8:	20000e8c 	.word	0x20000e8c
    2ddc:	00002d81 	.word	0x00002d81

00002de0 <prvProcessTimerOrBlockTask>:
    {
    2de0:	b570      	push	{r4, r5, r6, lr}
    2de2:	b082      	sub	sp, #8
    2de4:	4606      	mov	r6, r0
    2de6:	460c      	mov	r4, r1
        vTaskSuspendAll();
    2de8:	4b17      	ldr	r3, [pc, #92]	; (2e48 <prvProcessTimerOrBlockTask+0x68>)
    2dea:	4798      	blx	r3
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2dec:	a801      	add	r0, sp, #4
    2dee:	4b17      	ldr	r3, [pc, #92]	; (2e4c <prvProcessTimerOrBlockTask+0x6c>)
    2df0:	4798      	blx	r3
            if( xTimerListsWereSwitched == pdFALSE )
    2df2:	9b01      	ldr	r3, [sp, #4]
    2df4:	bb2b      	cbnz	r3, 2e42 <prvProcessTimerOrBlockTask+0x62>
    2df6:	4605      	mov	r5, r0
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2df8:	b90c      	cbnz	r4, 2dfe <prvProcessTimerOrBlockTask+0x1e>
    2dfa:	42b0      	cmp	r0, r6
    2dfc:	d218      	bcs.n	2e30 <prvProcessTimerOrBlockTask+0x50>
                    if( xListWasEmpty != pdFALSE )
    2dfe:	b124      	cbz	r4, 2e0a <prvProcessTimerOrBlockTask+0x2a>
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2e00:	4b13      	ldr	r3, [pc, #76]	; (2e50 <prvProcessTimerOrBlockTask+0x70>)
    2e02:	685b      	ldr	r3, [r3, #4]
    2e04:	681b      	ldr	r3, [r3, #0]
    2e06:	b9d3      	cbnz	r3, 2e3e <prvProcessTimerOrBlockTask+0x5e>
    2e08:	2401      	movs	r4, #1
                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    2e0a:	4622      	mov	r2, r4
    2e0c:	1b71      	subs	r1, r6, r5
    2e0e:	4b10      	ldr	r3, [pc, #64]	; (2e50 <prvProcessTimerOrBlockTask+0x70>)
    2e10:	68d8      	ldr	r0, [r3, #12]
    2e12:	4b10      	ldr	r3, [pc, #64]	; (2e54 <prvProcessTimerOrBlockTask+0x74>)
    2e14:	4798      	blx	r3
                    if( xTaskResumeAll() == pdFALSE )
    2e16:	4b10      	ldr	r3, [pc, #64]	; (2e58 <prvProcessTimerOrBlockTask+0x78>)
    2e18:	4798      	blx	r3
    2e1a:	b938      	cbnz	r0, 2e2c <prvProcessTimerOrBlockTask+0x4c>
                        taskYIELD_WITHIN_API();
    2e1c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    2e20:	4b0e      	ldr	r3, [pc, #56]	; (2e5c <prvProcessTimerOrBlockTask+0x7c>)
    2e22:	601a      	str	r2, [r3, #0]
    2e24:	f3bf 8f4f 	dsb	sy
    2e28:	f3bf 8f6f 	isb	sy
    }
    2e2c:	b002      	add	sp, #8
    2e2e:	bd70      	pop	{r4, r5, r6, pc}
                    ( void ) xTaskResumeAll();
    2e30:	4b09      	ldr	r3, [pc, #36]	; (2e58 <prvProcessTimerOrBlockTask+0x78>)
    2e32:	4798      	blx	r3
                    prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    2e34:	4629      	mov	r1, r5
    2e36:	4630      	mov	r0, r6
    2e38:	4b09      	ldr	r3, [pc, #36]	; (2e60 <prvProcessTimerOrBlockTask+0x80>)
    2e3a:	4798      	blx	r3
    2e3c:	e7f6      	b.n	2e2c <prvProcessTimerOrBlockTask+0x4c>
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2e3e:	2400      	movs	r4, #0
    2e40:	e7e3      	b.n	2e0a <prvProcessTimerOrBlockTask+0x2a>
                ( void ) xTaskResumeAll();
    2e42:	4b05      	ldr	r3, [pc, #20]	; (2e58 <prvProcessTimerOrBlockTask+0x78>)
    2e44:	4798      	blx	r3
    }
    2e46:	e7f1      	b.n	2e2c <prvProcessTimerOrBlockTask+0x4c>
    2e48:	00002295 	.word	0x00002295
    2e4c:	00002dad 	.word	0x00002dad
    2e50:	20000e8c 	.word	0x20000e8c
    2e54:	00001e99 	.word	0x00001e99
    2e58:	00002445 	.word	0x00002445
    2e5c:	e000ed04 	.word	0xe000ed04
    2e60:	00002d39 	.word	0x00002d39

00002e64 <prvProcessReceivedCommands>:
    {
    2e64:	b570      	push	{r4, r5, r6, lr}
    2e66:	b084      	sub	sp, #16
        DaemonTaskMessage_t xMessage = { 0 };
    2e68:	2300      	movs	r3, #0
    2e6a:	9301      	str	r3, [sp, #4]
    2e6c:	9302      	str	r3, [sp, #8]
    2e6e:	9303      	str	r3, [sp, #12]
        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
    2e70:	2200      	movs	r2, #0
    2e72:	a901      	add	r1, sp, #4
    2e74:	4b39      	ldr	r3, [pc, #228]	; (2f5c <prvProcessReceivedCommands+0xf8>)
    2e76:	68d8      	ldr	r0, [r3, #12]
    2e78:	4b39      	ldr	r3, [pc, #228]	; (2f60 <prvProcessReceivedCommands+0xfc>)
    2e7a:	4798      	blx	r3
    2e7c:	2800      	cmp	r0, #0
    2e7e:	d06a      	beq.n	2f56 <prvProcessReceivedCommands+0xf2>
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    2e80:	9b01      	ldr	r3, [sp, #4]
    2e82:	2b00      	cmp	r3, #0
    2e84:	dbf4      	blt.n	2e70 <prvProcessReceivedCommands+0xc>
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
    2e86:	9c03      	ldr	r4, [sp, #12]
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    2e88:	6963      	ldr	r3, [r4, #20]
    2e8a:	b113      	cbz	r3, 2e92 <prvProcessReceivedCommands+0x2e>
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2e8c:	1d20      	adds	r0, r4, #4
    2e8e:	4b35      	ldr	r3, [pc, #212]	; (2f64 <prvProcessReceivedCommands+0x100>)
    2e90:	4798      	blx	r3
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2e92:	4668      	mov	r0, sp
    2e94:	4b34      	ldr	r3, [pc, #208]	; (2f68 <prvProcessReceivedCommands+0x104>)
    2e96:	4798      	blx	r3
    2e98:	4605      	mov	r5, r0
                switch( xMessage.xMessageID )
    2e9a:	9b01      	ldr	r3, [sp, #4]
    2e9c:	3b01      	subs	r3, #1
    2e9e:	2b08      	cmp	r3, #8
    2ea0:	d8e6      	bhi.n	2e70 <prvProcessReceivedCommands+0xc>
    2ea2:	e8df f003 	tbb	[pc, r3]
    2ea6:	0505      	.short	0x0505
    2ea8:	054a312a 	.word	0x054a312a
    2eac:	2a05      	.short	0x2a05
    2eae:	31          	.byte	0x31
    2eaf:	00          	.byte	0x00
                        pxTimer->ucStatus |= ( uint8_t ) tmrSTATUS_IS_ACTIVE;
    2eb0:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
    2eb4:	f043 0301 	orr.w	r3, r3, #1
    2eb8:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    2ebc:	9902      	ldr	r1, [sp, #8]
    2ebe:	69a0      	ldr	r0, [r4, #24]
    2ec0:	460b      	mov	r3, r1
    2ec2:	462a      	mov	r2, r5
    2ec4:	4401      	add	r1, r0
    2ec6:	4620      	mov	r0, r4
    2ec8:	4e28      	ldr	r6, [pc, #160]	; (2f6c <prvProcessReceivedCommands+0x108>)
    2eca:	47b0      	blx	r6
    2ecc:	2800      	cmp	r0, #0
    2ece:	d0cf      	beq.n	2e70 <prvProcessReceivedCommands+0xc>
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0U )
    2ed0:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
    2ed4:	f013 0f04 	tst.w	r3, #4
    2ed8:	d107      	bne.n	2eea <prvProcessReceivedCommands+0x86>
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    2eda:	f023 0301 	bic.w	r3, r3, #1
    2ede:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2ee2:	6a23      	ldr	r3, [r4, #32]
    2ee4:	4620      	mov	r0, r4
    2ee6:	4798      	blx	r3
    2ee8:	e7c2      	b.n	2e70 <prvProcessReceivedCommands+0xc>
                                prvReloadTimer( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow );
    2eea:	69a3      	ldr	r3, [r4, #24]
    2eec:	462a      	mov	r2, r5
    2eee:	9902      	ldr	r1, [sp, #8]
    2ef0:	4419      	add	r1, r3
    2ef2:	4620      	mov	r0, r4
    2ef4:	4b1e      	ldr	r3, [pc, #120]	; (2f70 <prvProcessReceivedCommands+0x10c>)
    2ef6:	4798      	blx	r3
    2ef8:	e7f3      	b.n	2ee2 <prvProcessReceivedCommands+0x7e>
                        pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    2efa:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
    2efe:	f023 0301 	bic.w	r3, r3, #1
    2f02:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
                        break;
    2f06:	e7b3      	b.n	2e70 <prvProcessReceivedCommands+0xc>
                        pxTimer->ucStatus |= ( uint8_t ) tmrSTATUS_IS_ACTIVE;
    2f08:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
    2f0c:	f043 0301 	orr.w	r3, r3, #1
    2f10:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    2f14:	9902      	ldr	r1, [sp, #8]
    2f16:	61a1      	str	r1, [r4, #24]
                        configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    2f18:	b131      	cbz	r1, 2f28 <prvProcessReceivedCommands+0xc4>
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    2f1a:	4603      	mov	r3, r0
    2f1c:	4602      	mov	r2, r0
    2f1e:	4401      	add	r1, r0
    2f20:	4620      	mov	r0, r4
    2f22:	4c12      	ldr	r4, [pc, #72]	; (2f6c <prvProcessReceivedCommands+0x108>)
    2f24:	47a0      	blx	r4
                        break;
    2f26:	e7a3      	b.n	2e70 <prvProcessReceivedCommands+0xc>
    2f28:	f04f 0380 	mov.w	r3, #128	; 0x80
    2f2c:	f383 8811 	msr	BASEPRI, r3
    2f30:	f3bf 8f6f 	isb	sy
    2f34:	f3bf 8f4f 	dsb	sy
    2f38:	e7fe      	b.n	2f38 <prvProcessReceivedCommands+0xd4>
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    2f3a:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
    2f3e:	f013 0f02 	tst.w	r3, #2
    2f42:	d004      	beq.n	2f4e <prvProcessReceivedCommands+0xea>
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    2f44:	f023 0301 	bic.w	r3, r3, #1
    2f48:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
    2f4c:	e790      	b.n	2e70 <prvProcessReceivedCommands+0xc>
                                vPortFree( pxTimer );
    2f4e:	4620      	mov	r0, r4
    2f50:	4b08      	ldr	r3, [pc, #32]	; (2f74 <prvProcessReceivedCommands+0x110>)
    2f52:	4798      	blx	r3
    2f54:	e78c      	b.n	2e70 <prvProcessReceivedCommands+0xc>
    }
    2f56:	b004      	add	sp, #16
    2f58:	bd70      	pop	{r4, r5, r6, pc}
    2f5a:	bf00      	nop
    2f5c:	20000e8c 	.word	0x20000e8c
    2f60:	00001b19 	.word	0x00001b19
    2f64:	00000e45 	.word	0x00000e45
    2f68:	00002dad 	.word	0x00002dad
    2f6c:	00002cc5 	.word	0x00002cc5
    2f70:	00002d0d 	.word	0x00002d0d
    2f74:	00001365 	.word	0x00001365

00002f78 <prvTimerTask>:
    {
    2f78:	b500      	push	{lr}
    2f7a:	b083      	sub	sp, #12
            xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    2f7c:	a801      	add	r0, sp, #4
    2f7e:	4b04      	ldr	r3, [pc, #16]	; (2f90 <prvTimerTask+0x18>)
    2f80:	4798      	blx	r3
            prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    2f82:	9901      	ldr	r1, [sp, #4]
    2f84:	4b03      	ldr	r3, [pc, #12]	; (2f94 <prvTimerTask+0x1c>)
    2f86:	4798      	blx	r3
            prvProcessReceivedCommands();
    2f88:	4b03      	ldr	r3, [pc, #12]	; (2f98 <prvTimerTask+0x20>)
    2f8a:	4798      	blx	r3
    2f8c:	e7f6      	b.n	2f7c <prvTimerTask+0x4>
    2f8e:	bf00      	nop
    2f90:	00002ca5 	.word	0x00002ca5
    2f94:	00002de1 	.word	0x00002de1
    2f98:	00002e65 	.word	0x00002e65

00002f9c <prvCheckForValidListAndQueue>:
    }
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
    2f9c:	b5f0      	push	{r4, r5, r6, r7, lr}
    2f9e:	b083      	sub	sp, #12
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
    2fa0:	4b10      	ldr	r3, [pc, #64]	; (2fe4 <prvCheckForValidListAndQueue+0x48>)
    2fa2:	4798      	blx	r3
        {
            if( xTimerQueue == NULL )
    2fa4:	4b10      	ldr	r3, [pc, #64]	; (2fe8 <prvCheckForValidListAndQueue+0x4c>)
    2fa6:	68db      	ldr	r3, [r3, #12]
    2fa8:	b11b      	cbz	r3, 2fb2 <prvCheckForValidListAndQueue+0x16>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    2faa:	4b10      	ldr	r3, [pc, #64]	; (2fec <prvCheckForValidListAndQueue+0x50>)
    2fac:	4798      	blx	r3
    }
    2fae:	b003      	add	sp, #12
    2fb0:	bdf0      	pop	{r4, r5, r6, r7, pc}
                vListInitialise( &xActiveTimerList1 );
    2fb2:	4c0d      	ldr	r4, [pc, #52]	; (2fe8 <prvCheckForValidListAndQueue+0x4c>)
    2fb4:	f104 0610 	add.w	r6, r4, #16
    2fb8:	4630      	mov	r0, r6
    2fba:	4f0d      	ldr	r7, [pc, #52]	; (2ff0 <prvCheckForValidListAndQueue+0x54>)
    2fbc:	47b8      	blx	r7
                vListInitialise( &xActiveTimerList2 );
    2fbe:	f104 0524 	add.w	r5, r4, #36	; 0x24
    2fc2:	4628      	mov	r0, r5
    2fc4:	47b8      	blx	r7
                pxCurrentTimerList = &xActiveTimerList1;
    2fc6:	6026      	str	r6, [r4, #0]
                pxOverflowTimerList = &xActiveTimerList2;
    2fc8:	6065      	str	r5, [r4, #4]
                    xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
    2fca:	2300      	movs	r3, #0
    2fcc:	9300      	str	r3, [sp, #0]
    2fce:	f104 0338 	add.w	r3, r4, #56	; 0x38
    2fd2:	f104 028c 	add.w	r2, r4, #140	; 0x8c
    2fd6:	210c      	movs	r1, #12
    2fd8:	2002      	movs	r0, #2
    2fda:	4d06      	ldr	r5, [pc, #24]	; (2ff4 <prvCheckForValidListAndQueue+0x58>)
    2fdc:	47a8      	blx	r5
    2fde:	60e0      	str	r0, [r4, #12]
    2fe0:	e7e3      	b.n	2faa <prvCheckForValidListAndQueue+0xe>
    2fe2:	bf00      	nop
    2fe4:	00000fa5 	.word	0x00000fa5
    2fe8:	20000e8c 	.word	0x20000e8c
    2fec:	00000fe9 	.word	0x00000fe9
    2ff0:	00000df5 	.word	0x00000df5
    2ff4:	00001721 	.word	0x00001721

00002ff8 <xTimerCreateTimerTask>:
    {
    2ff8:	b510      	push	{r4, lr}
    2ffa:	b088      	sub	sp, #32
        prvCheckForValidListAndQueue();
    2ffc:	4b15      	ldr	r3, [pc, #84]	; (3054 <xTimerCreateTimerTask+0x5c>)
    2ffe:	4798      	blx	r3
        if( xTimerQueue != NULL )
    3000:	4b15      	ldr	r3, [pc, #84]	; (3058 <xTimerCreateTimerTask+0x60>)
    3002:	68db      	ldr	r3, [r3, #12]
    3004:	b313      	cbz	r3, 304c <xTimerCreateTimerTask+0x54>
                    StaticTask_t * pxTimerTaskTCBBuffer = NULL;
    3006:	2400      	movs	r4, #0
    3008:	9405      	str	r4, [sp, #20]
                    StackType_t * pxTimerTaskStackBuffer = NULL;
    300a:	9406      	str	r4, [sp, #24]
                    vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &uxTimerTaskStackSize );
    300c:	aa07      	add	r2, sp, #28
    300e:	a906      	add	r1, sp, #24
    3010:	a805      	add	r0, sp, #20
    3012:	4b12      	ldr	r3, [pc, #72]	; (305c <xTimerCreateTimerTask+0x64>)
    3014:	4798      	blx	r3
                    xTimerTaskHandle = xTaskCreateStatic( prvTimerTask,
    3016:	9b05      	ldr	r3, [sp, #20]
    3018:	9302      	str	r3, [sp, #8]
    301a:	9b06      	ldr	r3, [sp, #24]
    301c:	9301      	str	r3, [sp, #4]
    301e:	2302      	movs	r3, #2
    3020:	9300      	str	r3, [sp, #0]
    3022:	4623      	mov	r3, r4
    3024:	9a07      	ldr	r2, [sp, #28]
    3026:	490e      	ldr	r1, [pc, #56]	; (3060 <xTimerCreateTimerTask+0x68>)
    3028:	480e      	ldr	r0, [pc, #56]	; (3064 <xTimerCreateTimerTask+0x6c>)
    302a:	4c0f      	ldr	r4, [pc, #60]	; (3068 <xTimerCreateTimerTask+0x70>)
    302c:	47a0      	blx	r4
    302e:	4b0a      	ldr	r3, [pc, #40]	; (3058 <xTimerCreateTimerTask+0x60>)
    3030:	f8c3 00a4 	str.w	r0, [r3, #164]	; 0xa4
                    if( xTimerTaskHandle != NULL )
    3034:	b100      	cbz	r0, 3038 <xTimerCreateTimerTask+0x40>
                        xReturn = pdPASS;
    3036:	2001      	movs	r0, #1
        configASSERT( xReturn );
    3038:	b950      	cbnz	r0, 3050 <xTimerCreateTimerTask+0x58>
    303a:	f04f 0380 	mov.w	r3, #128	; 0x80
    303e:	f383 8811 	msr	BASEPRI, r3
    3042:	f3bf 8f6f 	isb	sy
    3046:	f3bf 8f4f 	dsb	sy
    304a:	e7fe      	b.n	304a <xTimerCreateTimerTask+0x52>
        BaseType_t xReturn = pdFAIL;
    304c:	2000      	movs	r0, #0
    304e:	e7f3      	b.n	3038 <xTimerCreateTimerTask+0x40>
    }
    3050:	b008      	add	sp, #32
    3052:	bd10      	pop	{r4, pc}
    3054:	00002f9d 	.word	0x00002f9d
    3058:	20000e8c 	.word	0x20000e8c
    305c:	00002c85 	.word	0x00002c85
    3060:	00003258 	.word	0x00003258
    3064:	00002f79 	.word	0x00002f79
    3068:	00002261 	.word	0x00002261

0000306c <__libc_init_array>:
    306c:	b570      	push	{r4, r5, r6, lr}
    306e:	4e0d      	ldr	r6, [pc, #52]	; (30a4 <__libc_init_array+0x38>)
    3070:	4c0d      	ldr	r4, [pc, #52]	; (30a8 <__libc_init_array+0x3c>)
    3072:	1ba4      	subs	r4, r4, r6
    3074:	10a4      	asrs	r4, r4, #2
    3076:	2500      	movs	r5, #0
    3078:	42a5      	cmp	r5, r4
    307a:	d109      	bne.n	3090 <__libc_init_array+0x24>
    307c:	4e0b      	ldr	r6, [pc, #44]	; (30ac <__libc_init_array+0x40>)
    307e:	4c0c      	ldr	r4, [pc, #48]	; (30b0 <__libc_init_array+0x44>)
    3080:	f000 f8ee 	bl	3260 <_init>
    3084:	1ba4      	subs	r4, r4, r6
    3086:	10a4      	asrs	r4, r4, #2
    3088:	2500      	movs	r5, #0
    308a:	42a5      	cmp	r5, r4
    308c:	d105      	bne.n	309a <__libc_init_array+0x2e>
    308e:	bd70      	pop	{r4, r5, r6, pc}
    3090:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
    3094:	4798      	blx	r3
    3096:	3501      	adds	r5, #1
    3098:	e7ee      	b.n	3078 <__libc_init_array+0xc>
    309a:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
    309e:	4798      	blx	r3
    30a0:	3501      	adds	r5, #1
    30a2:	e7f2      	b.n	308a <__libc_init_array+0x1e>
    30a4:	0000326c 	.word	0x0000326c
    30a8:	0000326c 	.word	0x0000326c
    30ac:	0000326c 	.word	0x0000326c
    30b0:	00003270 	.word	0x00003270

000030b4 <memcpy>:
    30b4:	b510      	push	{r4, lr}
    30b6:	1e43      	subs	r3, r0, #1
    30b8:	440a      	add	r2, r1
    30ba:	4291      	cmp	r1, r2
    30bc:	d100      	bne.n	30c0 <memcpy+0xc>
    30be:	bd10      	pop	{r4, pc}
    30c0:	f811 4b01 	ldrb.w	r4, [r1], #1
    30c4:	f803 4f01 	strb.w	r4, [r3, #1]!
    30c8:	e7f7      	b.n	30ba <memcpy+0x6>

000030ca <memset>:
    30ca:	4402      	add	r2, r0
    30cc:	4603      	mov	r3, r0
    30ce:	4293      	cmp	r3, r2
    30d0:	d100      	bne.n	30d4 <memset+0xa>
    30d2:	4770      	bx	lr
    30d4:	f803 1b01 	strb.w	r1, [r3], #1
    30d8:	e7f9      	b.n	30ce <memset+0x4>

000030da <strlen>:
    30da:	4603      	mov	r3, r0
    30dc:	f813 2b01 	ldrb.w	r2, [r3], #1
    30e0:	2a00      	cmp	r2, #0
    30e2:	d1fb      	bne.n	30dc <strlen+0x2>
    30e4:	1a18      	subs	r0, r3, r0
    30e6:	3801      	subs	r0, #1
    30e8:	4770      	bx	lr
    30ea:	0000      	movs	r0, r0
    30ec:	682f2e2e 	.word	0x682f2e2e
    30f0:	732f6c61 	.word	0x732f6c61
    30f4:	682f6372 	.word	0x682f6372
    30f8:	695f6c61 	.word	0x695f6c61
    30fc:	00632e6f 	.word	0x00632e6f
    3100:	682f2e2e 	.word	0x682f2e2e
    3104:	732f6c61 	.word	0x732f6c61
    3108:	682f6372 	.word	0x682f6372
    310c:	755f6c61 	.word	0x755f6c61
    3110:	74726173 	.word	0x74726173
    3114:	2e736f5f 	.word	0x2e736f5f
    3118:	00000063 	.word	0x00000063
    311c:	682f2e2e 	.word	0x682f2e2e
    3120:	752f6c61 	.word	0x752f6c61
    3124:	736c6974 	.word	0x736c6974
    3128:	6372732f 	.word	0x6372732f
    312c:	6974752f 	.word	0x6974752f
    3130:	725f736c 	.word	0x725f736c
    3134:	62676e69 	.word	0x62676e69
    3138:	65666675 	.word	0x65666675
    313c:	00632e72 	.word	0x00632e72
    3140:	40003000 	.word	0x40003000
    3144:	40003400 	.word	0x40003400
    3148:	41012000 	.word	0x41012000
    314c:	41014000 	.word	0x41014000
    3150:	43000000 	.word	0x43000000
    3154:	43000400 	.word	0x43000400
    3158:	43000800 	.word	0x43000800
    315c:	43000c00 	.word	0x43000c00

00003160 <_usarts>:
    3160:	00000002 40100004 00030000 00700002     .......@......p.
    3170:	0000d8ad 00000000                       ........

00003178 <_i2cms>:
	...

00003190 <_i2css>:
	...

000031a0 <sercomspi_regs>:
	...
    31b4:	682f2e2e 732f6c70 6f637265 70682f6d     ../hpl/sercom/hp
    31c4:	65735f6c 6d6f6372 0000632e 6d617865     l_sercom.c..exam
    31d4:	54656c70 206b7361 00000a0d 78450a0d     pleTask ......Ex
    31e4:	6c706d61 72462065 54526565 5020534f     ample FreeRTOS P
    31f4:	656a6f72 0a0d7463 00000000 6d617865     roject......exam
    3204:	00656c70 742f2e2e 64726968 74726170     ple.../thirdpart
    3214:	54522f79 662f534f 72656572 2f736f74     y/RTOS/freertos/
    3224:	65657246 534f5452 2e303156 2f302e30     FreeRTOSV10.0.0/
    3234:	736f7472 726f705f 00632e74 09632509     rtos_port.c..%c.
    3244:	25097525 75250975 00000a0d 454c4449     %u.%u.%u....IDLE
    3254:	00000000 20726d54 00637653              ....Tmr Svc.

00003260 <_init>:
    3260:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3262:	bf00      	nop
    3264:	bcf8      	pop	{r3, r4, r5, r6, r7}
    3266:	bc08      	pop	{r3}
    3268:	469e      	mov	lr, r3
    326a:	4770      	bx	lr

0000326c <__init_array_start>:
    326c:	00000289 	.word	0x00000289

00003270 <_fini>:
    3270:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3272:	bf00      	nop
    3274:	bcf8      	pop	{r3, r4, r5, r6, r7}
    3276:	bc08      	pop	{r3}
    3278:	469e      	mov	lr, r3
    327a:	4770      	bx	lr

0000327c <__fini_array_start>:
    327c:	00000265 	.word	0x00000265
